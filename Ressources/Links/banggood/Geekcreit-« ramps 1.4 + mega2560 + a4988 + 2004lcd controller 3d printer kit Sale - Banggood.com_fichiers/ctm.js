// [AIV]  Build version: 4.3.1-4 - Tuesday, May 19th, 2020, 3:26:48 PM  
 /*! 31d48c3062c707a4a381 */
!function(t){function n(I){if(g[I])return g[I].exports;var e=g[I]={i:I,l:!1,exports:{}};return t[I].call(e.exports,e,e.exports,n),e.l=!0,e.exports}var g={};n.m=t,n.c=g,n.i=function(t){return t},n.d=function(t,g,I){n.o(t,g)||Object.defineProperty(t,g,{configurable:!1,enumerable:!0,get:I})},n.n=function(t){var g=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(g,"a",g),g},n.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},n.p="",n(n.s=29)}([function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.7.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (true) {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.7.0';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var createCallback = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result â€” either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  _.iteratee = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return createCallback(value, context, argCount);\n    if (_.isObject(value)) return _.matches(value);\n    return _.property(value);\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    if (obj == null) return obj;\n    iteratee = createCallback(iteratee, context);\n    var i, length = obj.length;\n    if (length === +length) {\n      for (i = 0; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    if (obj == null) return [];\n    iteratee = _.iteratee(iteratee, context);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length),\n        currentKey;\n    for (var index = 0; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {\n    if (obj == null) obj = [];\n    iteratee = createCallback(iteratee, context, 4);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        index = 0, currentKey;\n    if (arguments.length < 3) {\n      if (!length) throw new TypeError(reduceError);\n      memo = obj[keys ? keys[index++] : index++];\n    }\n    for (; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      memo = iteratee(memo, obj[currentKey], currentKey, obj);\n    }\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {\n    if (obj == null) obj = [];\n    iteratee = createCallback(iteratee, context, 4);\n    var keys = obj.length !== + obj.length && _.keys(obj),\n        index = (keys || obj).length,\n        currentKey;\n    if (arguments.length < 3) {\n      if (!index) throw new TypeError(reduceError);\n      memo = obj[keys ? keys[--index] : --index];\n    }\n    while (index--) {\n      currentKey = keys ? keys[index] : index;\n      memo = iteratee(memo, obj[currentKey], currentKey, obj);\n    }\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var result;\n    predicate = _.iteratee(predicate, context);\n    _.some(obj, function(value, index, list) {\n      if (predicate(value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    if (obj == null) return results;\n    predicate = _.iteratee(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(_.iteratee(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    if (obj == null) return true;\n    predicate = _.iteratee(predicate, context);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        index, currentKey;\n    for (index = 0; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    if (obj == null) return false;\n    predicate = _.iteratee(predicate, context);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        index, currentKey;\n    for (index = 0; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (obj.length !== +obj.length) obj = _.values(obj);\n    return _.indexOf(obj, target) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matches(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matches(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = obj.length === +obj.length ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = _.iteratee(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = obj.length === +obj.length ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = _.iteratee(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle).\n  _.shuffle = function(obj) {\n    var set = obj && obj.length === +obj.length ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (obj.length !== +obj.length) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = _.iteratee(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = _.iteratee(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = _.iteratee(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = low + high >>> 1;\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return obj.length === +obj.length ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = _.iteratee(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    if (n < 0) return [];\n    return slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return slice.call(array, Math.max(array.length - n, 0));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    for (var i = 0, length = input.length; i < length; i++) {\n      var value = input[i];\n      if (!_.isArray(value) && !_.isArguments(value)) {\n        if (!strict) output.push(value);\n      } else if (shallow) {\n        push.apply(output, value);\n      } else {\n        flatten(value, shallow, strict, output);\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (array == null) return [];\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = _.iteratee(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = array.length; i < length; i++) {\n      var value = array[i];\n      if (isSorted) {\n        if (!i || seen !== value) result.push(value);\n        seen = value;\n      } else if (iteratee) {\n        var computed = iteratee(value, i, array);\n        if (_.indexOf(seen, computed) < 0) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (_.indexOf(result, value) < 0) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true, []));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    if (array == null) return [];\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = array.length; i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(slice.call(arguments, 1), true, true, []);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function(array) {\n    if (array == null) return [];\n    var length = _.max(arguments, 'length').length;\n    var results = Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var idx = array.length;\n    if (typeof from == 'number') {\n      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);\n    }\n    while (--idx >= 0) if (array[idx] === item) return idx;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var Ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    args = slice.call(arguments, 2);\n    bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      Ctor.prototype = func.prototype;\n      var self = new Ctor;\n      Ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (_.isObject(result)) return result;\n      return self;\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    return function() {\n      var position = 0;\n      var args = boundArgs.slice();\n      for (var i = 0, length = args.length; i < length; i++) {\n        if (args[i] === _) args[i] = arguments[position++];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return func.apply(this, args);\n    };\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = hasher ? hasher.apply(this, arguments) : key;\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last > 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed before being called N times.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      } else {\n        func = null;\n      }\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      source = arguments[i];\n      for (prop in source) {\n        if (hasOwnProperty.call(source, prop)) {\n            obj[prop] = source[prop];\n        }\n      }\n    }\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj, iteratee, context) {\n    var result = {}, key;\n    if (obj == null) return result;\n    if (_.isFunction(iteratee)) {\n      iteratee = createCallback(iteratee, context);\n      for (key in obj) {\n        var value = obj[key];\n        if (iteratee(value, key, obj)) result[key] = value;\n      }\n    } else {\n      var keys = concat.apply([], slice.call(arguments, 1));\n      obj = new Object(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        key = keys[i];\n        if (key in obj) result[key] = obj[key];\n      }\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      var source = arguments[i];\n      for (var prop in source) {\n        if (obj[prop] === void 0) obj[prop] = source[prop];\n      }\n    }\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (\n      aCtor !== bCtor &&\n      // Handle Object.create(x) cases\n      'constructor' in a && 'constructor' in b &&\n      !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n        _.isFunction(bCtor) && bCtor instanceof bCtor)\n    ) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size, result;\n    // Recursively compare objects and arrays.\n    if (className === '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size === b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      size = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      result = _.keys(b).length === size;\n      if (result) {\n        while (size--) {\n          // Deep compare each member\n          key = keys[size];\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around an IE 11 bug.\n  if (true) {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = function(key) {\n    return function(obj) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n  _.matches = function(attrs) {\n    var pairs = _.pairs(attrs), length = pairs.length;\n    return function(obj) {\n      if (obj == null) return !length;\n      obj = new Object(obj);\n      for (var i = 0; i < length; i++) {\n        var pair = pairs[i], key = pair[0];\n        if (pair[1] !== obj[key] || !(key in obj)) return false;\n      }\n      return true;\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = createCallback(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? object[property]() : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n      return _;\n    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}.call(this));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcz8zMWE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQThCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZUFBZTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCOztBQUVqQjtBQUNBLGtEQUFrRCxFQUFFLGlCQUFpQjs7QUFFckU7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3RELDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBMEM7QUFDaEQsSUFBSSxpQ0FBcUIsRUFBRSxrQ0FBRTtBQUM3QjtBQUNBLEtBQUs7QUFBQSxvR0FBQztBQUNOO0FBQ0EsQ0FBQyIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgIFVuZGVyc2NvcmUuanMgMS43LjBcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICBjb25jYXQgICAgICAgICAgID0gQXJyYXlQcm90by5jb25jYXQsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQ7XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjcuMCc7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVDYWxsYmFjayA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIF8uaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBjcmVhdGVDYWxsYmFjayh2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcyh2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICBpdGVyYXRlZSA9IGNyZWF0ZUNhbGxiYWNrKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgaSwgbGVuZ3RoID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoID09PSArbGVuZ3RoKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIGl0ZXJhdGVlID0gXy5pdGVyYXRlZShpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBvYmoubGVuZ3RoICE9PSArb2JqLmxlbmd0aCAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICBjdXJyZW50S2V5O1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICB2YXIgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIG9iaiA9IFtdO1xuICAgIGl0ZXJhdGVlID0gY3JlYXRlQ2FsbGJhY2soaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgIHZhciBrZXlzID0gb2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGggJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IDAsIGN1cnJlbnRLZXk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICBpZiAoIWxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcihyZWR1Y2VFcnJvcik7XG4gICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4KytdIDogaW5kZXgrK107XG4gICAgfVxuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XG4gICAgaXRlcmF0ZWUgPSBjcmVhdGVDYWxsYmFjayhpdGVyYXRlZSwgY29udGV4dCwgNCk7XG4gICAgdmFyIGtleXMgPSBvYmoubGVuZ3RoICE9PSArIG9iai5sZW5ndGggJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGluZGV4ID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIGN1cnJlbnRLZXk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICBpZiAoIWluZGV4KSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbLS1pbmRleF0gOiAtLWluZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgcHJlZGljYXRlID0gXy5pdGVyYXRlZShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uc29tZShvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcbiAgICBwcmVkaWNhdGUgPSBfLml0ZXJhdGVlKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubmVnYXRlKF8uaXRlcmF0ZWUocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgcHJlZGljYXRlID0gXy5pdGVyYXRlZShwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gb2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGggJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICBpbmRleCwgY3VycmVudEtleTtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIHByZWRpY2F0ZSA9IF8uaXRlcmF0ZWUocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IG9iai5sZW5ndGggIT09ICtvYmoubGVuZ3RoICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgaW5kZXgsIGN1cnJlbnRLZXk7XG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIHZhbHVlICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICBpZiAob2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGgpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIHRhcmdldCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIChpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdKS5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVzKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVzKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gb2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGggPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBfLml0ZXJhdGVlKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IF8uaXRlcmF0ZWUoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSBJbmZpbml0eSAmJiByZXN1bHQgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLCB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4gIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHNldCA9IG9iaiAmJiBvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAob2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGgpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IF8uaXRlcmF0ZWUoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gXy5pdGVyYXRlZShpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCB2YWx1ZSwga2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldLnB1c2godmFsdWUpOyBlbHNlIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gXy5pdGVyYXRlZShpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IGxvdyArIGhpZ2ggPj4+IDE7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gU3BsaXQgYSBjb2xsZWN0aW9uIGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBfLml0ZXJhdGVlKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICBpZiAobiA8IDApIHJldHVybiBbXTtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aFxuICAvLyBgXy5tYXBgLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgTWF0aC5tYXgoYXJyYXkubGVuZ3RoIC0gbiwgMCkpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqXG4gIC8vIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgb3V0cHV0KSB7XG4gICAgaWYgKHNoYWxsb3cgJiYgXy5ldmVyeShpbnB1dCwgXy5pc0FycmF5KSkge1xuICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShvdXRwdXQsIGlucHV0KTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGlucHV0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmICghXy5pc0FycmF5KHZhbHVlKSAmJiAhXy5pc0FyZ3VtZW50cyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCFzdHJpY3QpIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hhbGxvdykge1xuICAgICAgICBwdXNoLmFwcGx5KG91dHB1dCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0LCBvdXRwdXQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UsIFtdKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiBbXTtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IF8uaXRlcmF0ZWUoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV07XG4gICAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgICAgaWYgKCFpIHx8IHNlZW4gIT09IHZhbHVlKSByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHNlZW4gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KTtcbiAgICAgICAgaWYgKF8uaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoXy5pbmRleE9mKHJlc3VsdCwgdmFsdWUpIDwgMCkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgW10pKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gZmxhdHRlbihzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIHRydWUsIHRydWUsIFtdKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gW107XG4gICAgdmFyIGxlbmd0aCA9IF8ubWF4KGFyZ3VtZW50cywgJ2xlbmd0aCcpLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0c1tpXSA9IF8ucGx1Y2soYXJndW1lbnRzLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIGlmIChsaXN0ID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgICBpID0gaXNTb3J0ZWQgPCAwID8gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaXNTb3J0ZWQpIDogaXNTb3J0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpID0gXy5zb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICAgIHJldHVybiBhcnJheVtpXSA9PT0gaXRlbSA/IGkgOiAtMTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICB2YXIgaWR4ID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZnJvbSA9PSAnbnVtYmVyJykge1xuICAgICAgaWR4ID0gZnJvbSA8IDAgPyBpZHggKyBmcm9tICsgMSA6IE1hdGgubWluKGlkeCwgZnJvbSArIDEpO1xuICAgIH1cbiAgICB3aGlsZSAoLS1pZHggPj0gMCkgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmV1c2FibGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHByb3RvdHlwZSBzZXR0aW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICB2YXIgYXJncywgYm91bmQ7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYm91bmQpKSByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgIEN0b3IucHJvdG90eXBlID0gZnVuYy5wcm90b3R5cGU7XG4gICAgICB2YXIgc2VsZiA9IG5ldyBDdG9yO1xuICAgICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkoc2VsZiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXG4gIC8vIGFzIGEgcGxhY2Vob2xkZXIsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmUgcHJlLWZpbGxlZC5cbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJncy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJnc1tpXSA9PT0gXykgYXJnc1tpXSA9IGFyZ3VtZW50c1twb3NpdGlvbisrXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbiAgLy8gYXJlIHRoZSBtZXRob2QgbmFtZXMgdG8gYmUgYm91bmQuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBhbGwgY2FsbGJhY2tzXG4gIC8vIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGksIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGtleTtcbiAgICBpZiAobGVuZ3RoIDw9IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gYXJndW1lbnRzW2ldO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9IGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5O1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICByZXR1cm4gXy5kZWxheS5hcHBseShfLCBbZnVuYywgMV0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID4gMCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB0aW1lc3RhbXAgPSBfLm5vdygpO1xuICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIHBhc3NlZC1pbiBwcmVkaWNhdGUuXG4gIF8ubmVnYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHN0YXJ0O1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYmVpbmcgY2FsbGVkIE4gdGltZXMuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGJlZm9yZSBiZWluZyBjYWxsZWQgTiB0aW1lcy5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgdmFyIHNvdXJjZSwgcHJvcDtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIGtleTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gY3JlYXRlQ2FsbGJhY2soaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBjb25jYXQuYXBwbHkoW10sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgICBvYmogPSBuZXcgT2JqZWN0KG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBpZiAoa2V5IGluIG9iaikgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoY29uY2F0LmFwcGx5KFtdLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChvYmpbcHJvcF0gPT09IHZvaWQgMCkgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gJycgKyBhID09PSAnJyArIGI7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTlxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG4gICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXG4gICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgaWYgKFxuICAgICAgYUN0b3IgIT09IGJDdG9yICYmXG4gICAgICAvLyBIYW5kbGUgT2JqZWN0LmNyZWF0ZSh4KSBjYXNlc1xuICAgICAgJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYiAmJlxuICAgICAgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG4gICAgdmFyIHNpemUsIHJlc3VsdDtcbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIHNpemUgPSBhLmxlbmd0aDtcbiAgICAgIHJlc3VsdCA9IHNpemUgPT09IGIubGVuZ3RoO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gZXEoYVtzaXplXSwgYltzaXplXSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgc2l6ZSA9IGtleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgcmVzdWx0ID0gXy5rZXlzKGIpLmxlbmd0aCA9PT0gc2l6ZTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgd2hpbGUgKHNpemUtLSkge1xuICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICAgIGtleSA9IGtleXNbc2l6ZV07XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIsIFtdLCBbXSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cC5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFKSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgYW4gSUUgMTEgYnVnLlxuICBpZiAodHlwZW9mIC8uLyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT09ICtvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdGVlcy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICBfLnByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xuICAgIHZhciBwYWlycyA9IF8ucGFpcnMoYXR0cnMpLCBsZW5ndGggPSBwYWlycy5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICAgIG9iaiA9IG5ldyBPYmplY3Qob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpXSwga2V5ID0gcGFpclswXTtcbiAgICAgICAgaWYgKHBhaXJbMV0gIT09IG9ialtrZXldIHx8ICEoa2V5IGluIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBpdGVyYXRlZSA9IGNyZWF0ZUNhbGxiYWNrKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyBvYmplY3RbcHJvcGVydHldKCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,exports){eval("//     Zepto.js\n//     (c) 2010-2017 Thomas Fuchs\n//     Zepto.js may be freely distributed under the MIT license.\n\n\n// MONKEY PATCHES\n// Changed each function because Prototype.js messes with array.prototype.every\n\nmodule.exports = (function() {\n  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,\n    document = window.document,\n    elementDisplay = {}, classCache = {},\n    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\n    fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\n    singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\n    rootNodeRE = /^(?:body|html)$/i,\n    capitalRE = /([A-Z])/g,\n\n    // special attributes that should be get/set via method calls\n    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\n\n    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\n    table = document.createElement('table'),\n    tableRow = document.createElement('tr'),\n    containers = {\n      'tr': document.createElement('tbody'),\n      'tbody': table, 'thead': table, 'tfoot': table,\n      'td': tableRow, 'th': tableRow,\n      '*': document.createElement('div')\n    },\n    simpleSelectorRE = /^[\\w-]*$/,\n    class2type = {},\n    toString = class2type.toString,\n    zepto = {},\n    camelize, uniq,\n    tempParent = document.createElement('div'),\n    propMap = {\n      'tabindex': 'tabIndex',\n      'readonly': 'readOnly',\n      'for': 'htmlFor',\n      'class': 'className',\n      'maxlength': 'maxLength',\n      'cellspacing': 'cellSpacing',\n      'cellpadding': 'cellPadding',\n      'rowspan': 'rowSpan',\n      'colspan': 'colSpan',\n      'usemap': 'useMap',\n      'frameborder': 'frameBorder',\n      'contenteditable': 'contentEditable'\n    },\n    isArray = Array.isArray ||\n      function(object){ return object instanceof Array }\n\n  zepto.matches = function(element, selector) {\n    if (!selector || !element || element.nodeType !== 1) return false\n    var matchesSelector = element.matches || element.webkitMatchesSelector ||\n                          element.mozMatchesSelector || element.oMatchesSelector ||\n                          element.matchesSelector\n    if (matchesSelector) return matchesSelector.call(element, selector)\n    // fall back to performing a selector:\n    var match, parent = element.parentNode, temp = !parent\n    if (temp) (parent = tempParent).appendChild(element)\n    match = ~zepto.qsa(parent, selector).indexOf(element)\n    temp && tempParent.removeChild(element)\n    return match\n  }\n\n  function type(obj) {\n    return obj == null ? String(obj) :\n      class2type[toString.call(obj)] || \"object\"\n  }\n\n  function isFunction(value) { return type(value) == \"function\" }\n  function isWindow(obj)     { return obj != null && obj == obj.window }\n  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\n  function isObject(obj)     { return type(obj) == \"object\" }\n  function isPlainObject(obj) {\n    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\n  }\n\n  function likeArray(obj) {\n    var length = !!obj && 'length' in obj && obj.length,\n      type = $.type(obj)\n\n    return 'function' != type && !isWindow(obj) && (\n      'array' == type || length === 0 ||\n        (typeof length == 'number' && length > 0 && (length - 1) in obj)\n    )\n  }\n\n  function compact(array) { return filter.call(array, function(item){ return item != null }) }\n  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\n  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\n  function dasherize(str) {\n    return str.replace(/::/g, '/')\n           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n           .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n           .replace(/_/g, '-')\n           .toLowerCase()\n  }\n  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\n\n  function classRE(name) {\n    return name in classCache ?\n      classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'))\n  }\n\n  function maybeAddPx(name, value) {\n    return (typeof value == \"number\" && !cssNumber[dasherize(name)]) ? value + \"px\" : value\n  }\n\n  function defaultDisplay(nodeName) {\n    var element, display\n    if (!elementDisplay[nodeName]) {\n      element = document.createElement(nodeName)\n      document.body.appendChild(element)\n      display = getComputedStyle(element, '').getPropertyValue(\"display\")\n      element.parentNode.removeChild(element)\n      display == \"none\" && (display = \"block\")\n      elementDisplay[nodeName] = display\n    }\n    return elementDisplay[nodeName]\n  }\n\n  function children(element) {\n    return 'children' in element ?\n      slice.call(element.children) :\n      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\n  }\n\n  function Z(dom, selector) {\n    var i, len = dom ? dom.length : 0\n    for (i = 0; i < len; i++) this[i] = dom[i]\n    this.length = len\n    this.selector = selector || ''\n  }\n\n  // `$.zepto.fragment` takes a html string and an optional tag name\n  // to generate DOM nodes from the given html string.\n  // The generated DOM nodes are returned as an array.\n  // This function can be overridden in plugins for example to make\n  // it compatible with browsers that don't support the DOM fully.\n  zepto.fragment = function(html, name, properties) {\n    var dom, nodes, container\n\n    // A special case optimization for a single tag\n    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\n\n    if (!dom) {\n      if (html.replace) html = html.replace(tagExpanderRE, \"<$1></$2>\")\n      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\n      if (!(name in containers)) name = '*'\n\n      container = containers[name]\n      container.innerHTML = '' + html\n      dom = $.each(slice.call(container.childNodes), function(){\n        container.removeChild(this)\n      })\n    }\n\n    if (isPlainObject(properties)) {\n      nodes = $(dom)\n      $.each(properties, function(key, value) {\n        if (methodAttributes.indexOf(key) > -1) nodes[key](value)\n        else nodes.attr(key, value)\n      })\n    }\n\n    return dom\n  }\n\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\n  // to the array. This method can be overridden in plugins.\n  zepto.Z = function(dom, selector) {\n    return new Z(dom, selector)\n  }\n\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\n  // collection. This method can be overridden in plugins.\n  zepto.isZ = function(object) {\n    return object instanceof zepto.Z\n  }\n\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\n  // takes a CSS selector and an optional context (and handles various\n  // special cases).\n  // This method can be overridden in plugins.\n  zepto.init = function(selector, context) {\n    var dom\n    // If nothing given, return an empty Zepto collection\n    if (!selector) return zepto.Z()\n    // Optimize for string selectors\n    else if (typeof selector == 'string') {\n      selector = selector.trim()\n      // If it's a html fragment, create nodes from it\n      // Note: In both Chrome 21 and Firefox 15, DOM error 12\n      // is thrown if the fragment doesn't begin with <\n      if (selector[0] == '<' && fragmentRE.test(selector))\n        dom = zepto.fragment(selector, RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // If it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // If a function is given, call it when the DOM is ready\n    else if (isFunction(selector)) return $(document).ready(selector)\n    // If a Zepto collection is given, just return it\n    else if (zepto.isZ(selector)) return selector\n    else {\n      // normalize array if an array of nodes is given\n      if (isArray(selector)) dom = compact(selector)\n      // Wrap DOM nodes.\n      else if (isObject(selector))\n        dom = [selector], selector = null\n      // If it's a html fragment, create nodes from it\n      else if (fragmentRE.test(selector))\n        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // And last but no least, if it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // create a new Zepto collection from the nodes found\n    return zepto.Z(dom, selector)\n  }\n\n  // `$` will be the base `Zepto` object. When calling this\n  // function just call `$.zepto.init, which makes the implementation\n  // details of selecting nodes and creating Zepto collections\n  // patchable in plugins.\n  $ = function(selector, context){\n    return zepto.init(selector, context)\n  }\n\n  function extend(target, source, deep) {\n    for (key in source)\n      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n        if (isPlainObject(source[key]) && !isPlainObject(target[key]))\n          target[key] = {}\n        if (isArray(source[key]) && !isArray(target[key]))\n          target[key] = []\n        extend(target[key], source[key], deep)\n      }\n      else if (source[key] !== undefined) target[key] = source[key]\n  }\n\n  // Copy all but undefined properties from one or more\n  // objects to the `target` object.\n  $.extend = function(target){\n    var deep, args = slice.call(arguments, 1)\n    if (typeof target == 'boolean') {\n      deep = target\n      target = args.shift()\n    }\n    args.forEach(function(arg){ extend(target, arg, deep) })\n    return target\n  }\n\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\n  // This method can be overridden in plugins.\n  zepto.qsa = function(element, selector){\n    var found,\n        maybeID = selector[0] == '#',\n        maybeClass = !maybeID && selector[0] == '.',\n        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\n        isSimple = simpleSelectorRE.test(nameOnly)\n    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById\n      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\n      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :\n      slice.call(\n        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName\n          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\n          element.getElementsByTagName(selector) : // Or a tag\n          element.querySelectorAll(selector) // Or it's not simple, and we need to query all\n      )\n  }\n\n  function filtered(nodes, selector) {\n    return selector == null ? $(nodes) : $(nodes).filter(selector)\n  }\n\n  $.contains = document.documentElement.contains ?\n    function(parent, node) {\n      return parent !== node && parent.contains(node)\n    } :\n    function(parent, node) {\n      while (node && (node = node.parentNode))\n        if (node === parent) return true\n      return false\n    }\n\n  function funcArg(context, arg, idx, payload) {\n    return isFunction(arg) ? arg.call(context, idx, payload) : arg\n  }\n\n  function setAttribute(node, name, value) {\n    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\n  }\n\n  // access className property while respecting SVGAnimatedString\n  function className(node, value){\n    var klass = node.className || '',\n        svg   = klass && klass.baseVal !== undefined\n\n    if (value === undefined) return svg ? klass.baseVal : klass\n    svg ? (klass.baseVal = value) : (node.className = value)\n  }\n\n  // \"true\"  => true\n  // \"false\" => false\n  // \"null\"  => null\n  // \"42\"    => 42\n  // \"42.5\"  => 42.5\n  // \"08\"    => \"08\"\n  // JSON    => parse if valid\n  // String  => self\n  function deserializeValue(value) {\n    try {\n      return value ?\n        value == \"true\" ||\n        ( value == \"false\" ? false :\n          value == \"null\" ? null :\n          +value + \"\" == value ? +value :\n          /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\n          value )\n        : value\n    } catch(e) {\n      return value\n    }\n  }\n\n  $.type = type\n  $.isFunction = isFunction\n  $.isWindow = isWindow\n  $.isArray = isArray\n  $.isPlainObject = isPlainObject\n\n  $.isEmptyObject = function(obj) {\n    var name\n    for (name in obj) return false\n    return true\n  }\n\n  $.isNumeric = function(val) {\n    var num = Number(val), type = typeof val\n    return val != null && type != 'boolean' &&\n      (type != 'string' || val.length) &&\n      !isNaN(num) && isFinite(num) || false\n  }\n\n  $.inArray = function(elem, array, i){\n    return emptyArray.indexOf.call(array, elem, i)\n  }\n\n  $.camelCase = camelize\n  $.trim = function(str) {\n    return str == null ? \"\" : String.prototype.trim.call(str)\n  }\n\n  // plugin compatibility\n  $.uuid = 0\n  $.support = { }\n  $.expr = { }\n  $.noop = function() {}\n\n  $.map = function(elements, callback){\n    var value, values = [], i, key\n    if (likeArray(elements))\n      for (i = 0; i < elements.length; i++) {\n        value = callback(elements[i], i)\n        if (value != null) values.push(value)\n      }\n    else\n      for (key in elements) {\n        value = callback(elements[key], key)\n        if (value != null) values.push(value)\n      }\n    return flatten(values)\n  }\n\n  $.each = function(elements, callback){\n    var i, key\n    if (likeArray(elements)) {\n      for (i = 0; i < elements.length; i++)\n        if (callback.call(elements[i], i, elements[i]) === false) return elements\n    } else {\n      for (key in elements)\n        if (callback.call(elements[key], key, elements[key]) === false) return elements\n    }\n\n    return elements\n  }\n\n  $.grep = function(elements, callback){\n    return filter.call(elements, callback)\n  }\n\n  if (window.JSON) $.parseJSON = JSON.parse\n\n  // Populate the class2type map\n  $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase()\n  })\n\n  // Define methods that will be available on all\n  // Zepto collections\n  $.fn = {\n    constructor: zepto.Z,\n    length: 0,\n\n    // Because a collection acts like an array\n    // copy over these useful array functions.\n    forEach: emptyArray.forEach,\n    reduce: emptyArray.reduce,\n    push: emptyArray.push,\n    sort: emptyArray.sort,\n    splice: emptyArray.splice,\n    indexOf: emptyArray.indexOf,\n    concat: function(){\n      var i, value, args = []\n      for (i = 0; i < arguments.length; i++) {\n        value = arguments[i]\n        args[i] = zepto.isZ(value) ? value.toArray() : value\n      }\n      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)\n    },\n\n    // `map` and `slice` in the jQuery API work differently\n    // from their array counterparts\n    map: function(fn){\n      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\n    },\n    slice: function(){\n      return $(slice.apply(this, arguments))\n    },\n\n    ready: function(callback){\n      // don't use \"interactive\" on IE <= 10 (it can fired premature)\n      if (document.readyState === \"complete\" ||\n          (document.readyState !== \"loading\" && !document.documentElement.doScroll))\n        setTimeout(function(){ callback($) }, 0)\n      else {\n        var handler = function() {\n          document.removeEventListener(\"DOMContentLoaded\", handler, false)\n          window.removeEventListener(\"load\", handler, false)\n          callback($)\n        }\n        document.addEventListener(\"DOMContentLoaded\", handler, false)\n        window.addEventListener(\"load\", handler, false)\n      }\n      return this\n    },\n    get: function(idx){\n      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\n    },\n    toArray: function(){ return this.get() },\n    size: function(){\n      return this.length\n    },\n    remove: function(){\n      return this.each(function(){\n        if (this.parentNode != null)\n          this.parentNode.removeChild(this)\n      })\n    },\n    each: function(callback){\n\t\t\tvar errBreak = {};\n\t\t\ttry {\n\n\t\t\t\tthis.forEach.call(this, function (el, idx) {\n\n\t\t\t\t\tvar result = callback.call(el, idx, el);\n\n\t\t\t\t\tif (result  === false) {\n\t\t\t\t\t\tthrow errBreak;\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t} catch (err) {\n\t\t\t\tif (err !== errBreak) {\n\t\t\t\t\tthrow err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n    },\n    filter: function(selector){\n      if (isFunction(selector)) return this.not(this.not(selector))\n      return $(filter.call(this, function(element){\n        return zepto.matches(element, selector)\n      }))\n    },\n    add: function(selector,context){\n      return $(uniq(this.concat($(selector,context))))\n    },\n    is: function(selector){\n      return this.length > 0 && zepto.matches(this[0], selector)\n    },\n    not: function(selector){\n      var nodes=[]\n      if (isFunction(selector) && selector.call !== undefined)\n        this.each(function(idx){\n          if (!selector.call(this,idx)) nodes.push(this)\n        })\n      else {\n        var excludes = typeof selector == 'string' ? this.filter(selector) :\n          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\n        this.forEach(function(el){\n          if (excludes.indexOf(el) < 0) nodes.push(el)\n        })\n      }\n      return $(nodes)\n    },\n    has: function(selector){\n      return this.filter(function(){\n        return isObject(selector) ?\n          $.contains(this, selector) :\n          $(this).find(selector).size()\n      })\n    },\n    eq: function(idx){\n      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\n    },\n    first: function(){\n      var el = this[0]\n      return el && !isObject(el) ? el : $(el)\n    },\n    last: function(){\n      var el = this[this.length - 1]\n      return el && !isObject(el) ? el : $(el)\n    },\n    find: function(selector){\n      var result, $this = this\n      if (!selector) result = $()\n      else if (typeof selector == 'object')\n        result = $(selector).filter(function(){\n          var node = this\n          return emptyArray.some.call($this, function(parent){\n            return $.contains(parent, node)\n          })\n        })\n      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\n      else result = this.map(function(){ return zepto.qsa(this, selector) })\n      return result\n    },\n    closest: function(selector, context){\n      var nodes = [], collection = typeof selector == 'object' && $(selector)\n      this.each(function(_, node){\n        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\n          node = node !== context && !isDocument(node) && node.parentNode\n        if (node && nodes.indexOf(node) < 0) nodes.push(node)\n      })\n      return $(nodes)\n    },\n    parents: function(selector){\n      var ancestors = [], nodes = this\n      while (nodes.length > 0)\n        nodes = $.map(nodes, function(node){\n          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\n            ancestors.push(node)\n            return node\n          }\n        })\n      return filtered(ancestors, selector)\n    },\n    parent: function(selector){\n      return filtered(uniq(this.pluck('parentNode')), selector)\n    },\n    children: function(selector){\n      return filtered(this.map(function(){ return children(this) }), selector)\n    },\n    contents: function() {\n      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })\n    },\n    siblings: function(selector){\n      return filtered(this.map(function(i, el){\n        return filter.call(children(el.parentNode), function(child){ return child!==el })\n      }), selector)\n    },\n    empty: function(){\n      return this.each(function(){ this.innerHTML = '' })\n    },\n    // `pluck` is borrowed from Prototype.js\n    pluck: function(property){\n      return $.map(this, function(el){ return el[property] })\n    },\n    show: function(){\n      return this.each(function(){\n        this.style.display == \"none\" && (this.style.display = '')\n        if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\")\n          this.style.display = defaultDisplay(this.nodeName)\n      })\n    },\n    replaceWith: function(newContent){\n      return this.before(newContent).remove()\n    },\n    wrap: function(structure){\n      var func = isFunction(structure)\n      if (this[0] && !func)\n        var dom   = $(structure).get(0),\n            clone = dom.parentNode || this.length > 1\n\n      return this.each(function(index){\n        $(this).wrapAll(\n          func ? structure.call(this, index) :\n            clone ? dom.cloneNode(true) : dom\n        )\n      })\n    },\n    wrapAll: function(structure){\n      if (this[0]) {\n        $(this[0]).before(structure = $(structure))\n        var children\n        // drill down to the inmost element\n        while ((children = structure.children()).length) structure = children.first()\n        $(structure).append(this)\n      }\n      return this\n    },\n    wrapInner: function(structure){\n      var func = isFunction(structure)\n      return this.each(function(index){\n        var self = $(this), contents = self.contents(),\n            dom  = func ? structure.call(this, index) : structure\n        contents.length ? contents.wrapAll(dom) : self.append(dom)\n      })\n    },\n    unwrap: function(){\n      this.parent().each(function(){\n        $(this).replaceWith($(this).children())\n      })\n      return this\n    },\n    clone: function(){\n      return this.map(function(){ return this.cloneNode(true) })\n    },\n    hide: function(){\n      return this.css(\"display\", \"none\")\n    },\n    toggle: function(setting){\n      return this.each(function(){\n        var el = $(this)\n        ;(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide()\n      })\n    },\n    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\n    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\n    html: function(html){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var originHtml = this.innerHTML\n          $(this).empty().append( funcArg(this, html, idx, originHtml) )\n        }) :\n        (0 in this ? this[0].innerHTML : null)\n    },\n    text: function(text){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var newText = funcArg(this, text, idx, this.textContent)\n          this.textContent = newText == null ? '' : ''+newText\n        }) :\n        (0 in this ? this.pluck('textContent').join(\"\") : null)\n    },\n    attr: function(name, value){\n      var result\n      return (typeof name == 'string' && !(1 in arguments)) ?\n        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :\n        this.each(function(idx){\n          if (this.nodeType !== 1) return\n          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\n          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\n        })\n    },\n    removeAttr: function(name){\n      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\n        setAttribute(this, attribute)\n      }, this)})\n    },\n    prop: function(name, value){\n      name = propMap[name] || name\n      return (1 in arguments) ?\n        this.each(function(idx){\n          this[name] = funcArg(this, value, idx, this[name])\n        }) :\n        (this[0] && this[0][name])\n    },\n    removeProp: function(name){\n      name = propMap[name] || name\n      return this.each(function(){ delete this[name] })\n    },\n    data: function(name, value){\n      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\n\n      var data = (1 in arguments) ?\n        this.attr(attrName, value) :\n        this.attr(attrName)\n\n      return data !== null ? deserializeValue(data) : undefined\n    },\n    val: function(value){\n      if (0 in arguments) {\n        if (value == null) value = \"\"\n        return this.each(function(idx){\n          this.value = funcArg(this, value, idx, this.value)\n        })\n      } else {\n        return this[0] && (this[0].multiple ?\n           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\n           this[0].value)\n      }\n    },\n    offset: function(coordinates){\n      if (coordinates) return this.each(function(index){\n        var $this = $(this),\n            coords = funcArg(this, coordinates, index, $this.offset()),\n            parentOffset = $this.offsetParent().offset(),\n            props = {\n              top:  coords.top  - parentOffset.top,\n              left: coords.left - parentOffset.left\n            }\n\n        if ($this.css('position') == 'static') props['position'] = 'relative'\n        $this.css(props)\n      })\n      if (!this.length) return null\n      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))\n        return {top: 0, left: 0}\n      var obj = this[0].getBoundingClientRect()\n      return {\n        left: obj.left + window.pageXOffset,\n        top: obj.top + window.pageYOffset,\n        width: Math.round(obj.width),\n        height: Math.round(obj.height)\n      }\n    },\n    css: function(property, value){\n      if (arguments.length < 2) {\n        var element = this[0]\n        if (typeof property == 'string') {\n          if (!element) return\n          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)\n        } else if (isArray(property)) {\n          if (!element) return\n          var props = {}\n          var computedStyle = getComputedStyle(element, '')\n          $.each(property, function(_, prop){\n            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\n          })\n          return props\n        }\n      }\n\n      var css = ''\n      if (type(property) == 'string') {\n        if (!value && value !== 0)\n          this.each(function(){ this.style.removeProperty(dasherize(property)) })\n        else\n          css = dasherize(property) + \":\" + maybeAddPx(property, value)\n      } else {\n        for (key in property)\n          if (!property[key] && property[key] !== 0)\n            this.each(function(){ this.style.removeProperty(dasherize(key)) })\n          else\n            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\n      }\n\n      return this.each(function(){ this.style.cssText += ';' + css })\n    },\n    index: function(element){\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\n    },\n    hasClass: function(name){\n      if (!name) return false\n      return emptyArray.some.call(this, function(el){\n        return this.test(className(el))\n      }, classRE(name))\n    },\n    addClass: function(name){\n      if (!name) return this\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        classList = []\n        var cls = className(this), newName = funcArg(this, name, idx, cls)\n        newName.split(/\\s+/g).forEach(function(klass){\n          if (!$(this).hasClass(klass)) classList.push(klass)\n        }, this)\n        classList.length && className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \"))\n      })\n    },\n    removeClass: function(name){\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        if (name === undefined) return className(this, '')\n        classList = className(this)\n        funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass){\n          classList = classList.replace(classRE(klass), \" \")\n        })\n        className(this, classList.trim())\n      })\n    },\n    toggleClass: function(name, when){\n      if (!name) return this\n      return this.each(function(idx){\n        var $this = $(this), names = funcArg(this, name, idx, className(this))\n        names.split(/\\s+/g).forEach(function(klass){\n          (when === undefined ? !$this.hasClass(klass) : when) ?\n            $this.addClass(klass) : $this.removeClass(klass)\n        })\n      })\n    },\n    scrollTop: function(value){\n      if (!this.length) return\n      var hasScrollTop = 'scrollTop' in this[0]\n      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\n      return this.each(hasScrollTop ?\n        function(){ this.scrollTop = value } :\n        function(){ this.scrollTo(this.scrollX, value) })\n    },\n    scrollLeft: function(value){\n      if (!this.length) return\n      var hasScrollLeft = 'scrollLeft' in this[0]\n      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\n      return this.each(hasScrollLeft ?\n        function(){ this.scrollLeft = value } :\n        function(){ this.scrollTo(value, this.scrollY) })\n    },\n    position: function() {\n      if (!this.length) return\n\n      var elem = this[0],\n        // Get *real* offsetParent\n        offsetParent = this.offsetParent(),\n        // Get correct offsets\n        offset       = this.offset(),\n        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\n\n      // Subtract element margins\n      // note: when an element has margin: auto the offsetLeft and marginLeft\n      // are the same in Safari causing offset.left to incorrectly be 0\n      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\n      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\n\n      // Add offsetParent borders\n      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\n      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\n\n      // Subtract the two offsets\n      return {\n        top:  offset.top  - parentOffset.top,\n        left: offset.left - parentOffset.left\n      }\n    },\n    offsetParent: function() {\n      return this.map(function(){\n        var parent = this.offsetParent || document.body\n        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\"position\") == \"static\")\n          parent = parent.offsetParent\n        return parent\n      })\n    }\n  }\n\n  // for now\n  $.fn.detach = $.fn.remove\n\n  // Generate the `width` and `height` functions\n  ;['width', 'height'].forEach(function(dimension){\n    var dimensionProperty =\n      dimension.replace(/./, function(m){ return m[0].toUpperCase() })\n\n    $.fn[dimension] = function(value){\n      var offset, el = this[0]\n      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\n        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\n        (offset = this.offset()) && offset[dimension]\n      else return this.each(function(idx){\n        el = $(this)\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()))\n      })\n    }\n  })\n\n  function traverseNode(node, fun) {\n    fun(node)\n    for (var i = 0, len = node.childNodes.length; i < len; i++)\n      traverseNode(node.childNodes[i], fun)\n  }\n\n  // Generate the `after`, `prepend`, `before`, `append`,\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\n  adjacencyOperators.forEach(function(operator, operatorIndex) {\n    var inside = operatorIndex % 2 //=> prepend, append\n\n    $.fn[operator] = function(){\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\n      var argType, nodes = $.map(arguments, function(arg) {\n            var arr = []\n            argType = type(arg)\n            if (argType == \"array\") {\n              arg.forEach(function(el) {\n                if (el.nodeType !== undefined) return arr.push(el)\n                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())\n                arr = arr.concat(zepto.fragment(el))\n              })\n              return arr\n            }\n            return argType == \"object\" || arg == null ?\n              arg : zepto.fragment(arg)\n          }),\n          parent, copyByClone = this.length > 1\n      if (nodes.length < 1) return this\n\n      return this.each(function(_, target){\n        parent = inside ? target : target.parentNode\n\n        // convert all methods to a \"before\" operation\n        target = operatorIndex == 0 ? target.nextSibling :\n                 operatorIndex == 1 ? target.firstChild :\n                 operatorIndex == 2 ? target :\n                 null\n\n        var parentInDocument = $.contains(document.documentElement, parent)\n\n        nodes.forEach(function(node){\n          if (copyByClone) node = node.cloneNode(true)\n          else if (!parent) return $(node).remove()\n\n          parent.insertBefore(node, target)\n          if (parentInDocument) traverseNode(node, function(el){\n            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\n               (!el.type || el.type === 'text/javascript') && !el.src){\n              var target = el.ownerDocument ? el.ownerDocument.defaultView : window\n              target['eval'].call(target, el.innerHTML)\n            }\n          })\n        })\n      })\n    }\n\n    // after    => insertAfter\n    // prepend  => prependTo\n    // before   => insertBefore\n    // append   => appendTo\n    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\n      $(html)[operator](this)\n      return this\n    }\n  })\n\n  zepto.Z.prototype = Z.prototype = $.fn\n\n  // Export internal API functions in the `$.zepto` namespace\n  zepto.uniq = uniq\n  zepto.deserializeValue = deserializeValue\n  $.zepto = zepto\n\n  return $\n})()\n\n//     Zepto.js\n//     (c) 2010-2016 Thomas Fuchs\n//     Zepto.js may be freely distributed under the MIT license.\n\n;(function(){\n  // getComputedStyle shouldn't freak out when called\n  // without a valid element as argument\n  try {\n    getComputedStyle(undefined)\n  } catch(e) {\n    var nativeGetComputedStyle = getComputedStyle\n    window.getComputedStyle = function(element, pseudoElement){\n      try {\n        return nativeGetComputedStyle(element, pseudoElement)\n      } catch(e) {\n        return null\n      }\n    }\n  }\n})()\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbGliL3plcHRvLmpzPzg3NTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEMsaUJBQWlCLDRHQUE0RztBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDBDQUEwQyxzQkFBc0I7QUFDM0YsMkJBQTJCO0FBQzNCLDJCQUEyQixvREFBb0Qsc0NBQXNDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtDQUErQyxvQ0FBb0M7O0FBRTVHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHNDQUFzQztBQUNyRjs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0QkFBNEI7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDRCQUE0QjtBQUN2RSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0Esd0NBQXdDLG1DQUFtQztBQUMzRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsNkRBQTZEO0FBQy9GLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0VBQW9FLG9CQUFvQjtBQUN4RixPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0Esa0NBQWtDLHNCQUFzQjtBQUN4RCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUMsOEJBQThCO0FBQy9ELEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLDZCQUE2Qix5RUFBeUU7QUFDdEcsNkJBQTZCLHFFQUFxRTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxPQUFPLFFBQVE7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSx1REFBdUQsdUJBQXVCO0FBQzlFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUFpRDtBQUNoRjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpQ0FBaUMsNENBQTRDO0FBQzdFO0FBQ0EsNkVBQTZFO0FBQzdFOztBQUVBLGtDQUFrQyx5QkFBeUIsU0FBUztBQUNwRSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUMsbUJBQW1CLHFDQUFxQztBQUN4RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0MsbUJBQW1CLHFDQUFxQztBQUN4RCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGtCQUFrQjs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUNBQXlDLDRCQUE0Qjs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGlEQUFpRCxTQUFTO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAgICAgWmVwdG8uanNcbi8vICAgICAoYykgMjAxMC0yMDE3IFRob21hcyBGdWNoc1xuLy8gICAgIFplcHRvLmpzIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG5cbi8vIE1PTktFWSBQQVRDSEVTXG4vLyBDaGFuZ2VkIGVhY2ggZnVuY3Rpb24gYmVjYXVzZSBQcm90b3R5cGUuanMgbWVzc2VzIHdpdGggYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdW5kZWZpbmVkLCBrZXksICQsIGNsYXNzTGlzdCwgZW1wdHlBcnJheSA9IFtdLCBjb25jYXQgPSBlbXB0eUFycmF5LmNvbmNhdCwgZmlsdGVyID0gZW1wdHlBcnJheS5maWx0ZXIsIHNsaWNlID0gZW1wdHlBcnJheS5zbGljZSxcbiAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICBlbGVtZW50RGlzcGxheSA9IHt9LCBjbGFzc0NhY2hlID0ge30sXG4gICAgY3NzTnVtYmVyID0geyAnY29sdW1uLWNvdW50JzogMSwgJ2NvbHVtbnMnOiAxLCAnZm9udC13ZWlnaHQnOiAxLCAnbGluZS1oZWlnaHQnOiAxLCdvcGFjaXR5JzogMSwgJ3otaW5kZXgnOiAxLCAnem9vbSc6IDEgfSxcbiAgICBmcmFnbWVudFJFID0gL15cXHMqPChcXHcrfCEpW14+XSo+LyxcbiAgICBzaW5nbGVUYWdSRSA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyxcbiAgICB0YWdFeHBhbmRlclJFID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2lnLFxuICAgIHJvb3ROb2RlUkUgPSAvXig/OmJvZHl8aHRtbCkkL2ksXG4gICAgY2FwaXRhbFJFID0gLyhbQS1aXSkvZyxcblxuICAgIC8vIHNwZWNpYWwgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBnZXQvc2V0IHZpYSBtZXRob2QgY2FsbHNcbiAgICBtZXRob2RBdHRyaWJ1dGVzID0gWyd2YWwnLCAnY3NzJywgJ2h0bWwnLCAndGV4dCcsICdkYXRhJywgJ3dpZHRoJywgJ2hlaWdodCcsICdvZmZzZXQnXSxcblxuICAgIGFkamFjZW5jeU9wZXJhdG9ycyA9IFsgJ2FmdGVyJywgJ3ByZXBlbmQnLCAnYmVmb3JlJywgJ2FwcGVuZCcgXSxcbiAgICB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyksXG4gICAgdGFibGVSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpLFxuICAgIGNvbnRhaW5lcnMgPSB7XG4gICAgICAndHInOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpLFxuICAgICAgJ3Rib2R5JzogdGFibGUsICd0aGVhZCc6IHRhYmxlLCAndGZvb3QnOiB0YWJsZSxcbiAgICAgICd0ZCc6IHRhYmxlUm93LCAndGgnOiB0YWJsZVJvdyxcbiAgICAgICcqJzogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9LFxuICAgIHNpbXBsZVNlbGVjdG9yUkUgPSAvXltcXHctXSokLyxcbiAgICBjbGFzczJ0eXBlID0ge30sXG4gICAgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nLFxuICAgIHplcHRvID0ge30sXG4gICAgY2FtZWxpemUsIHVuaXEsXG4gICAgdGVtcFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgIHByb3BNYXAgPSB7XG4gICAgICAndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxuICAgICAgJ3JlYWRvbmx5JzogJ3JlYWRPbmx5JyxcbiAgICAgICdmb3InOiAnaHRtbEZvcicsXG4gICAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgICAgICdtYXhsZW5ndGgnOiAnbWF4TGVuZ3RoJyxcbiAgICAgICdjZWxsc3BhY2luZyc6ICdjZWxsU3BhY2luZycsXG4gICAgICAnY2VsbHBhZGRpbmcnOiAnY2VsbFBhZGRpbmcnLFxuICAgICAgJ3Jvd3NwYW4nOiAncm93U3BhbicsXG4gICAgICAnY29sc3Bhbic6ICdjb2xTcGFuJyxcbiAgICAgICd1c2VtYXAnOiAndXNlTWFwJyxcbiAgICAgICdmcmFtZWJvcmRlcic6ICdmcmFtZUJvcmRlcicsXG4gICAgICAnY29udGVudGVkaXRhYmxlJzogJ2NvbnRlbnRFZGl0YWJsZSdcbiAgICB9LFxuICAgIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8XG4gICAgICBmdW5jdGlvbihvYmplY3QpeyByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgQXJyYXkgfVxuXG4gIHplcHRvLm1hdGNoZXMgPSBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGlmICghc2VsZWN0b3IgfHwgIWVsZW1lbnQgfHwgZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuIGZhbHNlXG4gICAgdmFyIG1hdGNoZXNTZWxlY3RvciA9IGVsZW1lbnQubWF0Y2hlcyB8fCBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvciB8fCBlbGVtZW50Lm9NYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5tYXRjaGVzU2VsZWN0b3JcbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKSByZXR1cm4gbWF0Y2hlc1NlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpXG4gICAgLy8gZmFsbCBiYWNrIHRvIHBlcmZvcm1pbmcgYSBzZWxlY3RvcjpcbiAgICB2YXIgbWF0Y2gsIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSwgdGVtcCA9ICFwYXJlbnRcbiAgICBpZiAodGVtcCkgKHBhcmVudCA9IHRlbXBQYXJlbnQpLmFwcGVuZENoaWxkKGVsZW1lbnQpXG4gICAgbWF0Y2ggPSB+emVwdG8ucXNhKHBhcmVudCwgc2VsZWN0b3IpLmluZGV4T2YoZWxlbWVudClcbiAgICB0ZW1wICYmIHRlbXBQYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbWVudClcbiAgICByZXR1cm4gbWF0Y2hcbiAgfVxuXG4gIGZ1bmN0aW9uIHR5cGUob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gU3RyaW5nKG9iaikgOlxuICAgICAgY2xhc3MydHlwZVt0b1N0cmluZy5jYWxsKG9iaildIHx8IFwib2JqZWN0XCJcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHR5cGUodmFsdWUpID09IFwiZnVuY3Rpb25cIiB9XG4gIGZ1bmN0aW9uIGlzV2luZG93KG9iaikgICAgIHsgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PSBvYmoud2luZG93IH1cbiAgZnVuY3Rpb24gaXNEb2N1bWVudChvYmopICAgeyByZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqLm5vZGVUeXBlID09IG9iai5ET0NVTUVOVF9OT0RFIH1cbiAgZnVuY3Rpb24gaXNPYmplY3Qob2JqKSAgICAgeyByZXR1cm4gdHlwZShvYmopID09IFwib2JqZWN0XCIgfVxuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBpc09iamVjdChvYmopICYmICFpc1dpbmRvdyhvYmopICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09IE9iamVjdC5wcm90b3R5cGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpa2VBcnJheShvYmopIHtcbiAgICB2YXIgbGVuZ3RoID0gISFvYmogJiYgJ2xlbmd0aCcgaW4gb2JqICYmIG9iai5sZW5ndGgsXG4gICAgICB0eXBlID0gJC50eXBlKG9iailcblxuICAgIHJldHVybiAnZnVuY3Rpb24nICE9IHR5cGUgJiYgIWlzV2luZG93KG9iaikgJiYgKFxuICAgICAgJ2FycmF5JyA9PSB0eXBlIHx8IGxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPiAwICYmIChsZW5ndGggLSAxKSBpbiBvYmopXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkgeyByZXR1cm4gZmlsdGVyLmNhbGwoYXJyYXksIGZ1bmN0aW9uKGl0ZW0peyByZXR1cm4gaXRlbSAhPSBudWxsIH0pIH1cbiAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkgeyByZXR1cm4gYXJyYXkubGVuZ3RoID4gMCA/ICQuZm4uY29uY2F0LmFwcGx5KFtdLCBhcnJheSkgOiBhcnJheSB9XG4gIGNhbWVsaXplID0gZnVuY3Rpb24oc3RyKXsgcmV0dXJuIHN0ci5yZXBsYWNlKC8tKyguKT8vZywgZnVuY3Rpb24obWF0Y2gsIGNocil7IHJldHVybiBjaHIgPyBjaHIudG9VcHBlckNhc2UoKSA6ICcnIH0pIH1cbiAgZnVuY3Rpb24gZGFzaGVyaXplKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvOjovZywgJy8nKVxuICAgICAgICAgICAucmVwbGFjZSgvKFtBLVpdKykoW0EtWl1bYS16XSkvZywgJyQxXyQyJylcbiAgICAgICAgICAgLnJlcGxhY2UoLyhbYS16XFxkXSkoW0EtWl0pL2csICckMV8kMicpXG4gICAgICAgICAgIC5yZXBsYWNlKC9fL2csICctJylcbiAgICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgfVxuICB1bmlxID0gZnVuY3Rpb24oYXJyYXkpeyByZXR1cm4gZmlsdGVyLmNhbGwoYXJyYXksIGZ1bmN0aW9uKGl0ZW0sIGlkeCl7IHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pID09IGlkeCB9KSB9XG5cbiAgZnVuY3Rpb24gY2xhc3NSRShuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gY2xhc3NDYWNoZSA/XG4gICAgICBjbGFzc0NhY2hlW25hbWVdIDogKGNsYXNzQ2FjaGVbbmFtZV0gPSBuZXcgUmVnRXhwKCcoXnxcXFxccyknICsgbmFtZSArICcoXFxcXHN8JCknKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIG1heWJlQWRkUHgobmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiICYmICFjc3NOdW1iZXJbZGFzaGVyaXplKG5hbWUpXSkgPyB2YWx1ZSArIFwicHhcIiA6IHZhbHVlXG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0RGlzcGxheShub2RlTmFtZSkge1xuICAgIHZhciBlbGVtZW50LCBkaXNwbGF5XG4gICAgaWYgKCFlbGVtZW50RGlzcGxheVtub2RlTmFtZV0pIHtcbiAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KVxuICAgICAgZGlzcGxheSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgJycpLmdldFByb3BlcnR5VmFsdWUoXCJkaXNwbGF5XCIpXG4gICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudClcbiAgICAgIGRpc3BsYXkgPT0gXCJub25lXCIgJiYgKGRpc3BsYXkgPSBcImJsb2NrXCIpXG4gICAgICBlbGVtZW50RGlzcGxheVtub2RlTmFtZV0gPSBkaXNwbGF5XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50RGlzcGxheVtub2RlTmFtZV1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gJ2NoaWxkcmVuJyBpbiBlbGVtZW50ID9cbiAgICAgIHNsaWNlLmNhbGwoZWxlbWVudC5jaGlsZHJlbikgOlxuICAgICAgJC5tYXAoZWxlbWVudC5jaGlsZE5vZGVzLCBmdW5jdGlvbihub2RlKXsgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkgcmV0dXJuIG5vZGUgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIFooZG9tLCBzZWxlY3Rvcikge1xuICAgIHZhciBpLCBsZW4gPSBkb20gPyBkb20ubGVuZ3RoIDogMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgdGhpc1tpXSA9IGRvbVtpXVxuICAgIHRoaXMubGVuZ3RoID0gbGVuXG4gICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yIHx8ICcnXG4gIH1cblxuICAvLyBgJC56ZXB0by5mcmFnbWVudGAgdGFrZXMgYSBodG1sIHN0cmluZyBhbmQgYW4gb3B0aW9uYWwgdGFnIG5hbWVcbiAgLy8gdG8gZ2VuZXJhdGUgRE9NIG5vZGVzIGZyb20gdGhlIGdpdmVuIGh0bWwgc3RyaW5nLlxuICAvLyBUaGUgZ2VuZXJhdGVkIERPTSBub2RlcyBhcmUgcmV0dXJuZWQgYXMgYW4gYXJyYXkuXG4gIC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucyBmb3IgZXhhbXBsZSB0byBtYWtlXG4gIC8vIGl0IGNvbXBhdGlibGUgd2l0aCBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIERPTSBmdWxseS5cbiAgemVwdG8uZnJhZ21lbnQgPSBmdW5jdGlvbihodG1sLCBuYW1lLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGRvbSwgbm9kZXMsIGNvbnRhaW5lclxuXG4gICAgLy8gQSBzcGVjaWFsIGNhc2Ugb3B0aW1pemF0aW9uIGZvciBhIHNpbmdsZSB0YWdcbiAgICBpZiAoc2luZ2xlVGFnUkUudGVzdChodG1sKSkgZG9tID0gJChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFJlZ0V4cC4kMSkpXG5cbiAgICBpZiAoIWRvbSkge1xuICAgICAgaWYgKGh0bWwucmVwbGFjZSkgaHRtbCA9IGh0bWwucmVwbGFjZSh0YWdFeHBhbmRlclJFLCBcIjwkMT48LyQyPlwiKVxuICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgbmFtZSA9IGZyYWdtZW50UkUudGVzdChodG1sKSAmJiBSZWdFeHAuJDFcbiAgICAgIGlmICghKG5hbWUgaW4gY29udGFpbmVycykpIG5hbWUgPSAnKidcblxuICAgICAgY29udGFpbmVyID0gY29udGFpbmVyc1tuYW1lXVxuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnICsgaHRtbFxuICAgICAgZG9tID0gJC5lYWNoKHNsaWNlLmNhbGwoY29udGFpbmVyLmNoaWxkTm9kZXMpLCBmdW5jdGlvbigpe1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGlzUGxhaW5PYmplY3QocHJvcGVydGllcykpIHtcbiAgICAgIG5vZGVzID0gJChkb20pXG4gICAgICAkLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAobWV0aG9kQXR0cmlidXRlcy5pbmRleE9mKGtleSkgPiAtMSkgbm9kZXNba2V5XSh2YWx1ZSlcbiAgICAgICAgZWxzZSBub2Rlcy5hdHRyKGtleSwgdmFsdWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIC8vIGAkLnplcHRvLlpgIHN3YXBzIG91dCB0aGUgcHJvdG90eXBlIG9mIHRoZSBnaXZlbiBgZG9tYCBhcnJheVxuICAvLyBvZiBub2RlcyB3aXRoIGAkLmZuYCBhbmQgdGh1cyBzdXBwbHlpbmcgYWxsIHRoZSBaZXB0byBmdW5jdGlvbnNcbiAgLy8gdG8gdGhlIGFycmF5LiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBwbHVnaW5zLlxuICB6ZXB0by5aID0gZnVuY3Rpb24oZG9tLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBuZXcgWihkb20sIHNlbGVjdG9yKVxuICB9XG5cbiAgLy8gYCQuemVwdG8uaXNaYCBzaG91bGQgcmV0dXJuIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgWmVwdG9cbiAgLy8gY29sbGVjdGlvbi4gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucy5cbiAgemVwdG8uaXNaID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHplcHRvLlpcbiAgfVxuXG4gIC8vIGAkLnplcHRvLmluaXRgIGlzIFplcHRvJ3MgY291bnRlcnBhcnQgdG8galF1ZXJ5J3MgYCQuZm4uaW5pdGAgYW5kXG4gIC8vIHRha2VzIGEgQ1NTIHNlbGVjdG9yIGFuZCBhbiBvcHRpb25hbCBjb250ZXh0IChhbmQgaGFuZGxlcyB2YXJpb3VzXG4gIC8vIHNwZWNpYWwgY2FzZXMpLlxuICAvLyBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBwbHVnaW5zLlxuICB6ZXB0by5pbml0ID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgZG9tXG4gICAgLy8gSWYgbm90aGluZyBnaXZlbiwgcmV0dXJuIGFuIGVtcHR5IFplcHRvIGNvbGxlY3Rpb25cbiAgICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gemVwdG8uWigpXG4gICAgLy8gT3B0aW1pemUgZm9yIHN0cmluZyBzZWxlY3RvcnNcbiAgICBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT0gJ3N0cmluZycpIHtcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IudHJpbSgpXG4gICAgICAvLyBJZiBpdCdzIGEgaHRtbCBmcmFnbWVudCwgY3JlYXRlIG5vZGVzIGZyb20gaXRcbiAgICAgIC8vIE5vdGU6IEluIGJvdGggQ2hyb21lIDIxIGFuZCBGaXJlZm94IDE1LCBET00gZXJyb3IgMTJcbiAgICAgIC8vIGlzIHRocm93biBpZiB0aGUgZnJhZ21lbnQgZG9lc24ndCBiZWdpbiB3aXRoIDxcbiAgICAgIGlmIChzZWxlY3RvclswXSA9PSAnPCcgJiYgZnJhZ21lbnRSRS50ZXN0KHNlbGVjdG9yKSlcbiAgICAgICAgZG9tID0gemVwdG8uZnJhZ21lbnQoc2VsZWN0b3IsIFJlZ0V4cC4kMSwgY29udGV4dCksIHNlbGVjdG9yID0gbnVsbFxuICAgICAgLy8gSWYgdGhlcmUncyBhIGNvbnRleHQsIGNyZWF0ZSBhIGNvbGxlY3Rpb24gb24gdGhhdCBjb250ZXh0IGZpcnN0LCBhbmQgc2VsZWN0XG4gICAgICAvLyBub2RlcyBmcm9tIHRoZXJlXG4gICAgICBlbHNlIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIHJldHVybiAkKGNvbnRleHQpLmZpbmQoc2VsZWN0b3IpXG4gICAgICAvLyBJZiBpdCdzIGEgQ1NTIHNlbGVjdG9yLCB1c2UgaXQgdG8gc2VsZWN0IG5vZGVzLlxuICAgICAgZWxzZSBkb20gPSB6ZXB0by5xc2EoZG9jdW1lbnQsIHNlbGVjdG9yKVxuICAgIH1cbiAgICAvLyBJZiBhIGZ1bmN0aW9uIGlzIGdpdmVuLCBjYWxsIGl0IHdoZW4gdGhlIERPTSBpcyByZWFkeVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpKSByZXR1cm4gJChkb2N1bWVudCkucmVhZHkoc2VsZWN0b3IpXG4gICAgLy8gSWYgYSBaZXB0byBjb2xsZWN0aW9uIGlzIGdpdmVuLCBqdXN0IHJldHVybiBpdFxuICAgIGVsc2UgaWYgKHplcHRvLmlzWihzZWxlY3RvcikpIHJldHVybiBzZWxlY3RvclxuICAgIGVsc2Uge1xuICAgICAgLy8gbm9ybWFsaXplIGFycmF5IGlmIGFuIGFycmF5IG9mIG5vZGVzIGlzIGdpdmVuXG4gICAgICBpZiAoaXNBcnJheShzZWxlY3RvcikpIGRvbSA9IGNvbXBhY3Qoc2VsZWN0b3IpXG4gICAgICAvLyBXcmFwIERPTSBub2Rlcy5cbiAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHNlbGVjdG9yKSlcbiAgICAgICAgZG9tID0gW3NlbGVjdG9yXSwgc2VsZWN0b3IgPSBudWxsXG4gICAgICAvLyBJZiBpdCdzIGEgaHRtbCBmcmFnbWVudCwgY3JlYXRlIG5vZGVzIGZyb20gaXRcbiAgICAgIGVsc2UgaWYgKGZyYWdtZW50UkUudGVzdChzZWxlY3RvcikpXG4gICAgICAgIGRvbSA9IHplcHRvLmZyYWdtZW50KHNlbGVjdG9yLnRyaW0oKSwgUmVnRXhwLiQxLCBjb250ZXh0KSwgc2VsZWN0b3IgPSBudWxsXG4gICAgICAvLyBJZiB0aGVyZSdzIGEgY29udGV4dCwgY3JlYXRlIGEgY29sbGVjdGlvbiBvbiB0aGF0IGNvbnRleHQgZmlyc3QsIGFuZCBzZWxlY3RcbiAgICAgIC8vIG5vZGVzIGZyb20gdGhlcmVcbiAgICAgIGVsc2UgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgcmV0dXJuICQoY29udGV4dCkuZmluZChzZWxlY3RvcilcbiAgICAgIC8vIEFuZCBsYXN0IGJ1dCBubyBsZWFzdCwgaWYgaXQncyBhIENTUyBzZWxlY3RvciwgdXNlIGl0IHRvIHNlbGVjdCBub2Rlcy5cbiAgICAgIGVsc2UgZG9tID0gemVwdG8ucXNhKGRvY3VtZW50LCBzZWxlY3RvcilcbiAgICB9XG4gICAgLy8gY3JlYXRlIGEgbmV3IFplcHRvIGNvbGxlY3Rpb24gZnJvbSB0aGUgbm9kZXMgZm91bmRcbiAgICByZXR1cm4gemVwdG8uWihkb20sIHNlbGVjdG9yKVxuICB9XG5cbiAgLy8gYCRgIHdpbGwgYmUgdGhlIGJhc2UgYFplcHRvYCBvYmplY3QuIFdoZW4gY2FsbGluZyB0aGlzXG4gIC8vIGZ1bmN0aW9uIGp1c3QgY2FsbCBgJC56ZXB0by5pbml0LCB3aGljaCBtYWtlcyB0aGUgaW1wbGVtZW50YXRpb25cbiAgLy8gZGV0YWlscyBvZiBzZWxlY3Rpbmcgbm9kZXMgYW5kIGNyZWF0aW5nIFplcHRvIGNvbGxlY3Rpb25zXG4gIC8vIHBhdGNoYWJsZSBpbiBwbHVnaW5zLlxuICAkID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpe1xuICAgIHJldHVybiB6ZXB0by5pbml0KHNlbGVjdG9yLCBjb250ZXh0KVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlLCBkZWVwKSB7XG4gICAgZm9yIChrZXkgaW4gc291cmNlKVxuICAgICAgaWYgKGRlZXAgJiYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pIHx8IGlzQXJyYXkoc291cmNlW2tleV0pKSkge1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgJiYgIWlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pKVxuICAgICAgICAgIHRhcmdldFtrZXldID0ge31cbiAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlW2tleV0pICYmICFpc0FycmF5KHRhcmdldFtrZXldKSlcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IFtdXG4gICAgICAgIGV4dGVuZCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIGRlZXApXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzb3VyY2Vba2V5XSAhPT0gdW5kZWZpbmVkKSB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gIH1cblxuICAvLyBDb3B5IGFsbCBidXQgdW5kZWZpbmVkIHByb3BlcnRpZXMgZnJvbSBvbmUgb3IgbW9yZVxuICAvLyBvYmplY3RzIHRvIHRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gICQuZXh0ZW5kID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgICB2YXIgZGVlcCwgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09ICdib29sZWFuJykge1xuICAgICAgZGVlcCA9IHRhcmdldFxuICAgICAgdGFyZ2V0ID0gYXJncy5zaGlmdCgpXG4gICAgfVxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmcpeyBleHRlbmQodGFyZ2V0LCBhcmcsIGRlZXApIH0pXG4gICAgcmV0dXJuIHRhcmdldFxuICB9XG5cbiAgLy8gYCQuemVwdG8ucXNhYCBpcyBaZXB0bydzIENTUyBzZWxlY3RvciBpbXBsZW1lbnRhdGlvbiB3aGljaFxuICAvLyB1c2VzIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsYCBhbmQgb3B0aW1pemVzIGZvciBzb21lIHNwZWNpYWwgY2FzZXMsIGxpa2UgYCNpZGAuXG4gIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGluIHBsdWdpbnMuXG4gIHplcHRvLnFzYSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHNlbGVjdG9yKXtcbiAgICB2YXIgZm91bmQsXG4gICAgICAgIG1heWJlSUQgPSBzZWxlY3RvclswXSA9PSAnIycsXG4gICAgICAgIG1heWJlQ2xhc3MgPSAhbWF5YmVJRCAmJiBzZWxlY3RvclswXSA9PSAnLicsXG4gICAgICAgIG5hbWVPbmx5ID0gbWF5YmVJRCB8fCBtYXliZUNsYXNzID8gc2VsZWN0b3Iuc2xpY2UoMSkgOiBzZWxlY3RvciwgLy8gRW5zdXJlIHRoYXQgYSAxIGNoYXIgdGFnIG5hbWUgc3RpbGwgZ2V0cyBjaGVja2VkXG4gICAgICAgIGlzU2ltcGxlID0gc2ltcGxlU2VsZWN0b3JSRS50ZXN0KG5hbWVPbmx5KVxuICAgIHJldHVybiAoZWxlbWVudC5nZXRFbGVtZW50QnlJZCAmJiBpc1NpbXBsZSAmJiBtYXliZUlEKSA/IC8vIFNhZmFyaSBEb2N1bWVudEZyYWdtZW50IGRvZXNuJ3QgaGF2ZSBnZXRFbGVtZW50QnlJZFxuICAgICAgKCAoZm91bmQgPSBlbGVtZW50LmdldEVsZW1lbnRCeUlkKG5hbWVPbmx5KSkgPyBbZm91bmRdIDogW10gKSA6XG4gICAgICAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSA5ICYmIGVsZW1lbnQubm9kZVR5cGUgIT09IDExKSA/IFtdIDpcbiAgICAgIHNsaWNlLmNhbGwoXG4gICAgICAgIGlzU2ltcGxlICYmICFtYXliZUlEICYmIGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA/IC8vIERvY3VtZW50RnJhZ21lbnQgZG9lc24ndCBoYXZlIGdldEVsZW1lbnRzQnlDbGFzc05hbWUvVGFnTmFtZVxuICAgICAgICAgIG1heWJlQ2xhc3MgPyBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobmFtZU9ubHkpIDogLy8gSWYgaXQncyBzaW1wbGUsIGl0IGNvdWxkIGJlIGEgY2xhc3NcbiAgICAgICAgICBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHNlbGVjdG9yKSA6IC8vIE9yIGEgdGFnXG4gICAgICAgICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSAvLyBPciBpdCdzIG5vdCBzaW1wbGUsIGFuZCB3ZSBuZWVkIHRvIHF1ZXJ5IGFsbFxuICAgICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyZWQobm9kZXMsIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyAkKG5vZGVzKSA6ICQobm9kZXMpLmZpbHRlcihzZWxlY3RvcilcbiAgfVxuXG4gICQuY29udGFpbnMgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMgP1xuICAgIGZ1bmN0aW9uKHBhcmVudCwgbm9kZSkge1xuICAgICAgcmV0dXJuIHBhcmVudCAhPT0gbm9kZSAmJiBwYXJlbnQuY29udGFpbnMobm9kZSlcbiAgICB9IDpcbiAgICBmdW5jdGlvbihwYXJlbnQsIG5vZGUpIHtcbiAgICAgIHdoaWxlIChub2RlICYmIChub2RlID0gbm9kZS5wYXJlbnROb2RlKSlcbiAgICAgICAgaWYgKG5vZGUgPT09IHBhcmVudCkgcmV0dXJuIHRydWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICBmdW5jdGlvbiBmdW5jQXJnKGNvbnRleHQsIGFyZywgaWR4LCBwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oYXJnKSA/IGFyZy5jYWxsKGNvbnRleHQsIGlkeCwgcGF5bG9hZCkgOiBhcmdcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhbHVlID09IG51bGwgPyBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKSA6IG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKVxuICB9XG5cbiAgLy8gYWNjZXNzIGNsYXNzTmFtZSBwcm9wZXJ0eSB3aGlsZSByZXNwZWN0aW5nIFNWR0FuaW1hdGVkU3RyaW5nXG4gIGZ1bmN0aW9uIGNsYXNzTmFtZShub2RlLCB2YWx1ZSl7XG4gICAgdmFyIGtsYXNzID0gbm9kZS5jbGFzc05hbWUgfHwgJycsXG4gICAgICAgIHN2ZyAgID0ga2xhc3MgJiYga2xhc3MuYmFzZVZhbCAhPT0gdW5kZWZpbmVkXG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHN2ZyA/IGtsYXNzLmJhc2VWYWwgOiBrbGFzc1xuICAgIHN2ZyA/IChrbGFzcy5iYXNlVmFsID0gdmFsdWUpIDogKG5vZGUuY2xhc3NOYW1lID0gdmFsdWUpXG4gIH1cblxuICAvLyBcInRydWVcIiAgPT4gdHJ1ZVxuICAvLyBcImZhbHNlXCIgPT4gZmFsc2VcbiAgLy8gXCJudWxsXCIgID0+IG51bGxcbiAgLy8gXCI0MlwiICAgID0+IDQyXG4gIC8vIFwiNDIuNVwiICA9PiA0Mi41XG4gIC8vIFwiMDhcIiAgICA9PiBcIjA4XCJcbiAgLy8gSlNPTiAgICA9PiBwYXJzZSBpZiB2YWxpZFxuICAvLyBTdHJpbmcgID0+IHNlbGZcbiAgZnVuY3Rpb24gZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdmFsdWUgP1xuICAgICAgICB2YWx1ZSA9PSBcInRydWVcIiB8fFxuICAgICAgICAoIHZhbHVlID09IFwiZmFsc2VcIiA/IGZhbHNlIDpcbiAgICAgICAgICB2YWx1ZSA9PSBcIm51bGxcIiA/IG51bGwgOlxuICAgICAgICAgICt2YWx1ZSArIFwiXCIgPT0gdmFsdWUgPyArdmFsdWUgOlxuICAgICAgICAgIC9eW1xcW1xce10vLnRlc3QodmFsdWUpID8gJC5wYXJzZUpTT04odmFsdWUpIDpcbiAgICAgICAgICB2YWx1ZSApXG4gICAgICAgIDogdmFsdWVcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gICQudHlwZSA9IHR5cGVcbiAgJC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvblxuICAkLmlzV2luZG93ID0gaXNXaW5kb3dcbiAgJC5pc0FycmF5ID0gaXNBcnJheVxuICAkLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0XG5cbiAgJC5pc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVcbiAgICBmb3IgKG5hbWUgaW4gb2JqKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgJC5pc051bWVyaWMgPSBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgbnVtID0gTnVtYmVyKHZhbCksIHR5cGUgPSB0eXBlb2YgdmFsXG4gICAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHR5cGUgIT0gJ2Jvb2xlYW4nICYmXG4gICAgICAodHlwZSAhPSAnc3RyaW5nJyB8fCB2YWwubGVuZ3RoKSAmJlxuICAgICAgIWlzTmFOKG51bSkgJiYgaXNGaW5pdGUobnVtKSB8fCBmYWxzZVxuICB9XG5cbiAgJC5pbkFycmF5ID0gZnVuY3Rpb24oZWxlbSwgYXJyYXksIGkpe1xuICAgIHJldHVybiBlbXB0eUFycmF5LmluZGV4T2YuY2FsbChhcnJheSwgZWxlbSwgaSlcbiAgfVxuXG4gICQuY2FtZWxDYXNlID0gY2FtZWxpemVcbiAgJC50cmltID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ciA9PSBudWxsID8gXCJcIiA6IFN0cmluZy5wcm90b3R5cGUudHJpbS5jYWxsKHN0cilcbiAgfVxuXG4gIC8vIHBsdWdpbiBjb21wYXRpYmlsaXR5XG4gICQudXVpZCA9IDBcbiAgJC5zdXBwb3J0ID0geyB9XG4gICQuZXhwciA9IHsgfVxuICAkLm5vb3AgPSBmdW5jdGlvbigpIHt9XG5cbiAgJC5tYXAgPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spe1xuICAgIHZhciB2YWx1ZSwgdmFsdWVzID0gW10sIGksIGtleVxuICAgIGlmIChsaWtlQXJyYXkoZWxlbWVudHMpKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gY2FsbGJhY2soZWxlbWVudHNbaV0sIGkpXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZXMucHVzaCh2YWx1ZSlcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBmb3IgKGtleSBpbiBlbGVtZW50cykge1xuICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGVsZW1lbnRzW2tleV0sIGtleSlcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgfVxuICAgIHJldHVybiBmbGF0dGVuKHZhbHVlcylcbiAgfVxuXG4gICQuZWFjaCA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjayl7XG4gICAgdmFyIGksIGtleVxuICAgIGlmIChsaWtlQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGVsZW1lbnRzW2ldLCBpLCBlbGVtZW50c1tpXSkgPT09IGZhbHNlKSByZXR1cm4gZWxlbWVudHNcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChrZXkgaW4gZWxlbWVudHMpXG4gICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGVsZW1lbnRzW2tleV0sIGtleSwgZWxlbWVudHNba2V5XSkgPT09IGZhbHNlKSByZXR1cm4gZWxlbWVudHNcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudHNcbiAgfVxuXG4gICQuZ3JlcCA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjayl7XG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKGVsZW1lbnRzLCBjYWxsYmFjaylcbiAgfVxuXG4gIGlmICh3aW5kb3cuSlNPTikgJC5wYXJzZUpTT04gPSBKU09OLnBhcnNlXG5cbiAgLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG4gICQuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKGksIG5hbWUpIHtcbiAgICBjbGFzczJ0eXBlWyBcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKVxuICB9KVxuXG4gIC8vIERlZmluZSBtZXRob2RzIHRoYXQgd2lsbCBiZSBhdmFpbGFibGUgb24gYWxsXG4gIC8vIFplcHRvIGNvbGxlY3Rpb25zXG4gICQuZm4gPSB7XG4gICAgY29uc3RydWN0b3I6IHplcHRvLlosXG4gICAgbGVuZ3RoOiAwLFxuXG4gICAgLy8gQmVjYXVzZSBhIGNvbGxlY3Rpb24gYWN0cyBsaWtlIGFuIGFycmF5XG4gICAgLy8gY29weSBvdmVyIHRoZXNlIHVzZWZ1bCBhcnJheSBmdW5jdGlvbnMuXG4gICAgZm9yRWFjaDogZW1wdHlBcnJheS5mb3JFYWNoLFxuICAgIHJlZHVjZTogZW1wdHlBcnJheS5yZWR1Y2UsXG4gICAgcHVzaDogZW1wdHlBcnJheS5wdXNoLFxuICAgIHNvcnQ6IGVtcHR5QXJyYXkuc29ydCxcbiAgICBzcGxpY2U6IGVtcHR5QXJyYXkuc3BsaWNlLFxuICAgIGluZGV4T2Y6IGVtcHR5QXJyYXkuaW5kZXhPZixcbiAgICBjb25jYXQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgaSwgdmFsdWUsIGFyZ3MgPSBbXVxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IGFyZ3VtZW50c1tpXVxuICAgICAgICBhcmdzW2ldID0gemVwdG8uaXNaKHZhbHVlKSA/IHZhbHVlLnRvQXJyYXkoKSA6IHZhbHVlXG4gICAgICB9XG4gICAgICByZXR1cm4gY29uY2F0LmFwcGx5KHplcHRvLmlzWih0aGlzKSA/IHRoaXMudG9BcnJheSgpIDogdGhpcywgYXJncylcbiAgICB9LFxuXG4gICAgLy8gYG1hcGAgYW5kIGBzbGljZWAgaW4gdGhlIGpRdWVyeSBBUEkgd29yayBkaWZmZXJlbnRseVxuICAgIC8vIGZyb20gdGhlaXIgYXJyYXkgY291bnRlcnBhcnRzXG4gICAgbWFwOiBmdW5jdGlvbihmbil7XG4gICAgICByZXR1cm4gJCgkLm1hcCh0aGlzLCBmdW5jdGlvbihlbCwgaSl7IHJldHVybiBmbi5jYWxsKGVsLCBpLCBlbCkgfSkpXG4gICAgfSxcbiAgICBzbGljZTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiAkKHNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpXG4gICAgfSxcblxuICAgIHJlYWR5OiBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgICAvLyBkb24ndCB1c2UgXCJpbnRlcmFjdGl2ZVwiIG9uIElFIDw9IDEwIChpdCBjYW4gZmlyZWQgcHJlbWF0dXJlKVxuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuICAgICAgICAgIChkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsKSlcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpeyBjYWxsYmFjaygkKSB9LCAwKVxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgaGFuZGxlciwgZmFsc2UpXG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGhhbmRsZXIsIGZhbHNlKVxuICAgICAgICAgIGNhbGxiYWNrKCQpXG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgaGFuZGxlciwgZmFsc2UpXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBoYW5kbGVyLCBmYWxzZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKGlkeCl7XG4gICAgICByZXR1cm4gaWR4ID09PSB1bmRlZmluZWQgPyBzbGljZS5jYWxsKHRoaXMpIDogdGhpc1tpZHggPj0gMCA/IGlkeCA6IGlkeCArIHRoaXMubGVuZ3RoXVxuICAgIH0sXG4gICAgdG9BcnJheTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZ2V0KCkgfSxcbiAgICBzaXplOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoXG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUgIT0gbnVsbClcbiAgICAgICAgICB0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcylcbiAgICAgIH0pXG4gICAgfSxcbiAgICBlYWNoOiBmdW5jdGlvbihjYWxsYmFjayl7XG5cdFx0XHR2YXIgZXJyQnJlYWsgPSB7fTtcblx0XHRcdHRyeSB7XG5cblx0XHRcdFx0dGhpcy5mb3JFYWNoLmNhbGwodGhpcywgZnVuY3Rpb24gKGVsLCBpZHgpIHtcblxuXHRcdFx0XHRcdHZhciByZXN1bHQgPSBjYWxsYmFjay5jYWxsKGVsLCBpZHgsIGVsKTtcblxuXHRcdFx0XHRcdGlmIChyZXN1bHQgID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZXJyQnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0aWYgKGVyciAhPT0gZXJyQnJlYWspIHtcblx0XHRcdFx0XHR0aHJvdyBlcnJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkgcmV0dXJuIHRoaXMubm90KHRoaXMubm90KHNlbGVjdG9yKSlcbiAgICAgIHJldHVybiAkKGZpbHRlci5jYWxsKHRoaXMsIGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgICAgICByZXR1cm4gemVwdG8ubWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcilcbiAgICAgIH0pKVxuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbihzZWxlY3Rvcixjb250ZXh0KXtcbiAgICAgIHJldHVybiAkKHVuaXEodGhpcy5jb25jYXQoJChzZWxlY3Rvcixjb250ZXh0KSkpKVxuICAgIH0sXG4gICAgaXM6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDAgJiYgemVwdG8ubWF0Y2hlcyh0aGlzWzBdLCBzZWxlY3RvcilcbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgdmFyIG5vZGVzPVtdXG4gICAgICBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikgJiYgc2VsZWN0b3IuY2FsbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcbiAgICAgICAgICBpZiAoIXNlbGVjdG9yLmNhbGwodGhpcyxpZHgpKSBub2Rlcy5wdXNoKHRoaXMpXG4gICAgICAgIH0pXG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGV4Y2x1ZGVzID0gdHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnID8gdGhpcy5maWx0ZXIoc2VsZWN0b3IpIDpcbiAgICAgICAgICAobGlrZUFycmF5KHNlbGVjdG9yKSAmJiBpc0Z1bmN0aW9uKHNlbGVjdG9yLml0ZW0pKSA/IHNsaWNlLmNhbGwoc2VsZWN0b3IpIDogJChzZWxlY3RvcilcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICBpZiAoZXhjbHVkZXMuaW5kZXhPZihlbCkgPCAwKSBub2Rlcy5wdXNoKGVsKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuICQobm9kZXMpXG4gICAgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gaXNPYmplY3Qoc2VsZWN0b3IpID9cbiAgICAgICAgICAkLmNvbnRhaW5zKHRoaXMsIHNlbGVjdG9yKSA6XG4gICAgICAgICAgJCh0aGlzKS5maW5kKHNlbGVjdG9yKS5zaXplKClcbiAgICAgIH0pXG4gICAgfSxcbiAgICBlcTogZnVuY3Rpb24oaWR4KXtcbiAgICAgIHJldHVybiBpZHggPT09IC0xID8gdGhpcy5zbGljZShpZHgpIDogdGhpcy5zbGljZShpZHgsICsgaWR4ICsgMSlcbiAgICB9LFxuICAgIGZpcnN0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsID0gdGhpc1swXVxuICAgICAgcmV0dXJuIGVsICYmICFpc09iamVjdChlbCkgPyBlbCA6ICQoZWwpXG4gICAgfSxcbiAgICBsYXN0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsID0gdGhpc1t0aGlzLmxlbmd0aCAtIDFdXG4gICAgICByZXR1cm4gZWwgJiYgIWlzT2JqZWN0KGVsKSA/IGVsIDogJChlbClcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHZhciByZXN1bHQsICR0aGlzID0gdGhpc1xuICAgICAgaWYgKCFzZWxlY3RvcikgcmVzdWx0ID0gJCgpXG4gICAgICBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT0gJ29iamVjdCcpXG4gICAgICAgIHJlc3VsdCA9ICQoc2VsZWN0b3IpLmZpbHRlcihmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBub2RlID0gdGhpc1xuICAgICAgICAgIHJldHVybiBlbXB0eUFycmF5LnNvbWUuY2FsbCgkdGhpcywgZnVuY3Rpb24ocGFyZW50KXtcbiAgICAgICAgICAgIHJldHVybiAkLmNvbnRhaW5zKHBhcmVudCwgbm9kZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPT0gMSkgcmVzdWx0ID0gJCh6ZXB0by5xc2EodGhpc1swXSwgc2VsZWN0b3IpKVxuICAgICAgZWxzZSByZXN1bHQgPSB0aGlzLm1hcChmdW5jdGlvbigpeyByZXR1cm4gemVwdG8ucXNhKHRoaXMsIHNlbGVjdG9yKSB9KVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0sXG4gICAgY2xvc2VzdDogZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpe1xuICAgICAgdmFyIG5vZGVzID0gW10sIGNvbGxlY3Rpb24gPSB0eXBlb2Ygc2VsZWN0b3IgPT0gJ29iamVjdCcgJiYgJChzZWxlY3RvcilcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihfLCBub2RlKXtcbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgIShjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5pbmRleE9mKG5vZGUpID49IDAgOiB6ZXB0by5tYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSkpXG4gICAgICAgICAgbm9kZSA9IG5vZGUgIT09IGNvbnRleHQgJiYgIWlzRG9jdW1lbnQobm9kZSkgJiYgbm9kZS5wYXJlbnROb2RlXG4gICAgICAgIGlmIChub2RlICYmIG5vZGVzLmluZGV4T2Yobm9kZSkgPCAwKSBub2Rlcy5wdXNoKG5vZGUpXG4gICAgICB9KVxuICAgICAgcmV0dXJuICQobm9kZXMpXG4gICAgfSxcbiAgICBwYXJlbnRzOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgICB2YXIgYW5jZXN0b3JzID0gW10sIG5vZGVzID0gdGhpc1xuICAgICAgd2hpbGUgKG5vZGVzLmxlbmd0aCA+IDApXG4gICAgICAgIG5vZGVzID0gJC5tYXAobm9kZXMsIGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgIGlmICgobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkgJiYgIWlzRG9jdW1lbnQobm9kZSkgJiYgYW5jZXN0b3JzLmluZGV4T2Yobm9kZSkgPCAwKSB7XG4gICAgICAgICAgICBhbmNlc3RvcnMucHVzaChub2RlKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICByZXR1cm4gZmlsdGVyZWQoYW5jZXN0b3JzLCBzZWxlY3RvcilcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgcmV0dXJuIGZpbHRlcmVkKHVuaXEodGhpcy5wbHVjaygncGFyZW50Tm9kZScpKSwgc2VsZWN0b3IpXG4gICAgfSxcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgcmV0dXJuIGZpbHRlcmVkKHRoaXMubWFwKGZ1bmN0aW9uKCl7IHJldHVybiBjaGlsZHJlbih0aGlzKSB9KSwgc2VsZWN0b3IpXG4gICAgfSxcbiAgICBjb250ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbnRlbnREb2N1bWVudCB8fCBzbGljZS5jYWxsKHRoaXMuY2hpbGROb2RlcykgfSlcbiAgICB9LFxuICAgIHNpYmxpbmdzOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgICByZXR1cm4gZmlsdGVyZWQodGhpcy5tYXAoZnVuY3Rpb24oaSwgZWwpe1xuICAgICAgICByZXR1cm4gZmlsdGVyLmNhbGwoY2hpbGRyZW4oZWwucGFyZW50Tm9kZSksIGZ1bmN0aW9uKGNoaWxkKXsgcmV0dXJuIGNoaWxkIT09ZWwgfSlcbiAgICAgIH0pLCBzZWxlY3RvcilcbiAgICB9LFxuICAgIGVtcHR5OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLmlubmVySFRNTCA9ICcnIH0pXG4gICAgfSxcbiAgICAvLyBgcGx1Y2tgIGlzIGJvcnJvd2VkIGZyb20gUHJvdG90eXBlLmpzXG4gICAgcGx1Y2s6IGZ1bmN0aW9uKHByb3BlcnR5KXtcbiAgICAgIHJldHVybiAkLm1hcCh0aGlzLCBmdW5jdGlvbihlbCl7IHJldHVybiBlbFtwcm9wZXJ0eV0gfSlcbiAgICB9LFxuICAgIHNob3c6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIiAmJiAodGhpcy5zdHlsZS5kaXNwbGF5ID0gJycpXG4gICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKHRoaXMsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlzcGxheVwiKSA9PSBcIm5vbmVcIilcbiAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheSh0aGlzLm5vZGVOYW1lKVxuICAgICAgfSlcbiAgICB9LFxuICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbihuZXdDb250ZW50KXtcbiAgICAgIHJldHVybiB0aGlzLmJlZm9yZShuZXdDb250ZW50KS5yZW1vdmUoKVxuICAgIH0sXG4gICAgd3JhcDogZnVuY3Rpb24oc3RydWN0dXJlKXtcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jdGlvbihzdHJ1Y3R1cmUpXG4gICAgICBpZiAodGhpc1swXSAmJiAhZnVuYylcbiAgICAgICAgdmFyIGRvbSAgID0gJChzdHJ1Y3R1cmUpLmdldCgwKSxcbiAgICAgICAgICAgIGNsb25lID0gZG9tLnBhcmVudE5vZGUgfHwgdGhpcy5sZW5ndGggPiAxXG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICAkKHRoaXMpLndyYXBBbGwoXG4gICAgICAgICAgZnVuYyA/IHN0cnVjdHVyZS5jYWxsKHRoaXMsIGluZGV4KSA6XG4gICAgICAgICAgICBjbG9uZSA/IGRvbS5jbG9uZU5vZGUodHJ1ZSkgOiBkb21cbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9LFxuICAgIHdyYXBBbGw6IGZ1bmN0aW9uKHN0cnVjdHVyZSl7XG4gICAgICBpZiAodGhpc1swXSkge1xuICAgICAgICAkKHRoaXNbMF0pLmJlZm9yZShzdHJ1Y3R1cmUgPSAkKHN0cnVjdHVyZSkpXG4gICAgICAgIHZhciBjaGlsZHJlblxuICAgICAgICAvLyBkcmlsbCBkb3duIHRvIHRoZSBpbm1vc3QgZWxlbWVudFxuICAgICAgICB3aGlsZSAoKGNoaWxkcmVuID0gc3RydWN0dXJlLmNoaWxkcmVuKCkpLmxlbmd0aCkgc3RydWN0dXJlID0gY2hpbGRyZW4uZmlyc3QoKVxuICAgICAgICAkKHN0cnVjdHVyZSkuYXBwZW5kKHRoaXMpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgd3JhcElubmVyOiBmdW5jdGlvbihzdHJ1Y3R1cmUpe1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmN0aW9uKHN0cnVjdHVyZSlcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICB2YXIgc2VsZiA9ICQodGhpcyksIGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpLFxuICAgICAgICAgICAgZG9tICA9IGZ1bmMgPyBzdHJ1Y3R1cmUuY2FsbCh0aGlzLCBpbmRleCkgOiBzdHJ1Y3R1cmVcbiAgICAgICAgY29udGVudHMubGVuZ3RoID8gY29udGVudHMud3JhcEFsbChkb20pIDogc2VsZi5hcHBlbmQoZG9tKVxuICAgICAgfSlcbiAgICB9LFxuICAgIHVud3JhcDogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAkKHRoaXMpLnJlcGxhY2VXaXRoKCQodGhpcykuY2hpbGRyZW4oKSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuY2xvbmVOb2RlKHRydWUpIH0pXG4gICAgfSxcbiAgICBoaWRlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICB9LFxuICAgIHRvZ2dsZTogZnVuY3Rpb24oc2V0dGluZyl7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBlbCA9ICQodGhpcylcbiAgICAgICAgOyhzZXR0aW5nID09PSB1bmRlZmluZWQgPyBlbC5jc3MoXCJkaXNwbGF5XCIpID09IFwibm9uZVwiIDogc2V0dGluZykgPyBlbC5zaG93KCkgOiBlbC5oaWRlKClcbiAgICAgIH0pXG4gICAgfSxcbiAgICBwcmV2OiBmdW5jdGlvbihzZWxlY3Rvcil7IHJldHVybiAkKHRoaXMucGx1Y2soJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnKSkuZmlsdGVyKHNlbGVjdG9yIHx8ICcqJykgfSxcbiAgICBuZXh0OiBmdW5jdGlvbihzZWxlY3Rvcil7IHJldHVybiAkKHRoaXMucGx1Y2soJ25leHRFbGVtZW50U2libGluZycpKS5maWx0ZXIoc2VsZWN0b3IgfHwgJyonKSB9LFxuICAgIGh0bWw6IGZ1bmN0aW9uKGh0bWwpe1xuICAgICAgcmV0dXJuIDAgaW4gYXJndW1lbnRzID9cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XG4gICAgICAgICAgdmFyIG9yaWdpbkh0bWwgPSB0aGlzLmlubmVySFRNTFxuICAgICAgICAgICQodGhpcykuZW1wdHkoKS5hcHBlbmQoIGZ1bmNBcmcodGhpcywgaHRtbCwgaWR4LCBvcmlnaW5IdG1sKSApXG4gICAgICAgIH0pIDpcbiAgICAgICAgKDAgaW4gdGhpcyA/IHRoaXNbMF0uaW5uZXJIVE1MIDogbnVsbClcbiAgICB9LFxuICAgIHRleHQ6IGZ1bmN0aW9uKHRleHQpe1xuICAgICAgcmV0dXJuIDAgaW4gYXJndW1lbnRzID9cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmdW5jQXJnKHRoaXMsIHRleHQsIGlkeCwgdGhpcy50ZXh0Q29udGVudClcbiAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gbmV3VGV4dCA9PSBudWxsID8gJycgOiAnJytuZXdUZXh0XG4gICAgICAgIH0pIDpcbiAgICAgICAgKDAgaW4gdGhpcyA/IHRoaXMucGx1Y2soJ3RleHRDb250ZW50Jykuam9pbihcIlwiKSA6IG51bGwpXG4gICAgfSxcbiAgICBhdHRyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSl7XG4gICAgICB2YXIgcmVzdWx0XG4gICAgICByZXR1cm4gKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnICYmICEoMSBpbiBhcmd1bWVudHMpKSA/XG4gICAgICAgICgwIGluIHRoaXMgJiYgdGhpc1swXS5ub2RlVHlwZSA9PSAxICYmIChyZXN1bHQgPSB0aGlzWzBdLmdldEF0dHJpYnV0ZShuYW1lKSkgIT0gbnVsbCA/IHJlc3VsdCA6IHVuZGVmaW5lZCkgOlxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcbiAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuXG4gICAgICAgICAgaWYgKGlzT2JqZWN0KG5hbWUpKSBmb3IgKGtleSBpbiBuYW1lKSBzZXRBdHRyaWJ1dGUodGhpcywga2V5LCBuYW1lW2tleV0pXG4gICAgICAgICAgZWxzZSBzZXRBdHRyaWJ1dGUodGhpcywgbmFtZSwgZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKSkpXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICByZW1vdmVBdHRyOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiBuYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuICAgICAgICBzZXRBdHRyaWJ1dGUodGhpcywgYXR0cmlidXRlKVxuICAgICAgfSwgdGhpcyl9KVxuICAgIH0sXG4gICAgcHJvcDogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xuICAgICAgbmFtZSA9IHByb3BNYXBbbmFtZV0gfHwgbmFtZVxuICAgICAgcmV0dXJuICgxIGluIGFyZ3VtZW50cykgP1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcbiAgICAgICAgICB0aGlzW25hbWVdID0gZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzW25hbWVdKVxuICAgICAgICB9KSA6XG4gICAgICAgICh0aGlzWzBdICYmIHRoaXNbMF1bbmFtZV0pXG4gICAgfSxcbiAgICByZW1vdmVQcm9wOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgIG5hbWUgPSBwcm9wTWFwW25hbWVdIHx8IG5hbWVcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsgZGVsZXRlIHRoaXNbbmFtZV0gfSlcbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKXtcbiAgICAgIHZhciBhdHRyTmFtZSA9ICdkYXRhLScgKyBuYW1lLnJlcGxhY2UoY2FwaXRhbFJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxuXG4gICAgICB2YXIgZGF0YSA9ICgxIGluIGFyZ3VtZW50cykgP1xuICAgICAgICB0aGlzLmF0dHIoYXR0ck5hbWUsIHZhbHVlKSA6XG4gICAgICAgIHRoaXMuYXR0cihhdHRyTmFtZSlcblxuICAgICAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkZXNlcmlhbGl6ZVZhbHVlKGRhdGEpIDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2YWw6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmICgwIGluIGFyZ3VtZW50cykge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgdmFsdWUgPSBcIlwiXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzLnZhbHVlKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgKHRoaXNbMF0ubXVsdGlwbGUgP1xuICAgICAgICAgICAkKHRoaXNbMF0pLmZpbmQoJ29wdGlvbicpLmZpbHRlcihmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5zZWxlY3RlZCB9KS5wbHVjaygndmFsdWUnKSA6XG4gICAgICAgICAgIHRoaXNbMF0udmFsdWUpXG4gICAgICB9XG4gICAgfSxcbiAgICBvZmZzZXQ6IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKXtcbiAgICAgIGlmIChjb29yZGluYXRlcykgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpbmRleCl7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICBjb29yZHMgPSBmdW5jQXJnKHRoaXMsIGNvb3JkaW5hdGVzLCBpbmRleCwgJHRoaXMub2Zmc2V0KCkpLFxuICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gJHRoaXMub2Zmc2V0UGFyZW50KCkub2Zmc2V0KCksXG4gICAgICAgICAgICBwcm9wcyA9IHtcbiAgICAgICAgICAgICAgdG9wOiAgY29vcmRzLnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wLFxuICAgICAgICAgICAgICBsZWZ0OiBjb29yZHMubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgaWYgKCR0aGlzLmNzcygncG9zaXRpb24nKSA9PSAnc3RhdGljJykgcHJvcHNbJ3Bvc2l0aW9uJ10gPSAncmVsYXRpdmUnXG4gICAgICAgICR0aGlzLmNzcyhwcm9wcylcbiAgICAgIH0pXG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gdGhpc1swXSAmJiAhJC5jb250YWlucyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXNbMF0pKVxuICAgICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogMH1cbiAgICAgIHZhciBvYmogPSB0aGlzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBvYmoubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgdG9wOiBvYmoudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChvYmoud2lkdGgpLFxuICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQob2JqLmhlaWdodClcbiAgICAgIH1cbiAgICB9LFxuICAgIGNzczogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKXtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbMF1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbY2FtZWxpemUocHJvcGVydHkpXSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocHJvcGVydHkpKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm5cbiAgICAgICAgICB2YXIgcHJvcHMgPSB7fVxuICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnJylcbiAgICAgICAgICAkLmVhY2gocHJvcGVydHksIGZ1bmN0aW9uKF8sIHByb3Ape1xuICAgICAgICAgICAgcHJvcHNbcHJvcF0gPSAoZWxlbWVudC5zdHlsZVtjYW1lbGl6ZShwcm9wKV0gfHwgY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIHByb3BzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNzcyA9ICcnXG4gICAgICBpZiAodHlwZShwcm9wZXJ0eSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMClcbiAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShkYXNoZXJpemUocHJvcGVydHkpKSB9KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgY3NzID0gZGFzaGVyaXplKHByb3BlcnR5KSArIFwiOlwiICsgbWF5YmVBZGRQeChwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGtleSBpbiBwcm9wZXJ0eSlcbiAgICAgICAgICBpZiAoIXByb3BlcnR5W2tleV0gJiYgcHJvcGVydHlba2V5XSAhPT0gMClcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KGRhc2hlcml6ZShrZXkpKSB9KVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNzcyArPSBkYXNoZXJpemUoa2V5KSArICc6JyArIG1heWJlQWRkUHgoa2V5LCBwcm9wZXJ0eVtrZXldKSArICc7J1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7IHRoaXMuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBjc3MgfSlcbiAgICB9LFxuICAgIGluZGV4OiBmdW5jdGlvbihlbGVtZW50KXtcbiAgICAgIHJldHVybiBlbGVtZW50ID8gdGhpcy5pbmRleE9mKCQoZWxlbWVudClbMF0pIDogdGhpcy5wYXJlbnQoKS5jaGlsZHJlbigpLmluZGV4T2YodGhpc1swXSlcbiAgICB9LFxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgIGlmICghbmFtZSkgcmV0dXJuIGZhbHNlXG4gICAgICByZXR1cm4gZW1wdHlBcnJheS5zb21lLmNhbGwodGhpcywgZnVuY3Rpb24oZWwpe1xuICAgICAgICByZXR1cm4gdGhpcy50ZXN0KGNsYXNzTmFtZShlbCkpXG4gICAgICB9LCBjbGFzc1JFKG5hbWUpKVxuICAgIH0sXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gdGhpc1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xuICAgICAgICBpZiAoISgnY2xhc3NOYW1lJyBpbiB0aGlzKSkgcmV0dXJuXG4gICAgICAgIGNsYXNzTGlzdCA9IFtdXG4gICAgICAgIHZhciBjbHMgPSBjbGFzc05hbWUodGhpcyksIG5ld05hbWUgPSBmdW5jQXJnKHRoaXMsIG5hbWUsIGlkeCwgY2xzKVxuICAgICAgICBuZXdOYW1lLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xuICAgICAgICAgIGlmICghJCh0aGlzKS5oYXNDbGFzcyhrbGFzcykpIGNsYXNzTGlzdC5wdXNoKGtsYXNzKVxuICAgICAgICB9LCB0aGlzKVxuICAgICAgICBjbGFzc0xpc3QubGVuZ3RoICYmIGNsYXNzTmFtZSh0aGlzLCBjbHMgKyAoY2xzID8gXCIgXCIgOiBcIlwiKSArIGNsYXNzTGlzdC5qb2luKFwiIFwiKSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24obmFtZSl7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XG4gICAgICAgIGlmICghKCdjbGFzc05hbWUnIGluIHRoaXMpKSByZXR1cm5cbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNsYXNzTmFtZSh0aGlzLCAnJylcbiAgICAgICAgY2xhc3NMaXN0ID0gY2xhc3NOYW1lKHRoaXMpXG4gICAgICAgIGZ1bmNBcmcodGhpcywgbmFtZSwgaWR4LCBjbGFzc0xpc3QpLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xuICAgICAgICAgIGNsYXNzTGlzdCA9IGNsYXNzTGlzdC5yZXBsYWNlKGNsYXNzUkUoa2xhc3MpLCBcIiBcIilcbiAgICAgICAgfSlcbiAgICAgICAgY2xhc3NOYW1lKHRoaXMsIGNsYXNzTGlzdC50cmltKCkpXG4gICAgICB9KVxuICAgIH0sXG4gICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKG5hbWUsIHdoZW4pe1xuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gdGhpc1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLCBuYW1lcyA9IGZ1bmNBcmcodGhpcywgbmFtZSwgaWR4LCBjbGFzc05hbWUodGhpcykpXG4gICAgICAgIG5hbWVzLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xuICAgICAgICAgICh3aGVuID09PSB1bmRlZmluZWQgPyAhJHRoaXMuaGFzQ2xhc3Moa2xhc3MpIDogd2hlbikgP1xuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3Moa2xhc3MpIDogJHRoaXMucmVtb3ZlQ2xhc3Moa2xhc3MpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0sXG4gICAgc2Nyb2xsVG9wOiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cbiAgICAgIHZhciBoYXNTY3JvbGxUb3AgPSAnc2Nyb2xsVG9wJyBpbiB0aGlzWzBdXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGhhc1Njcm9sbFRvcCA/IHRoaXNbMF0uc2Nyb2xsVG9wIDogdGhpc1swXS5wYWdlWU9mZnNldFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChoYXNTY3JvbGxUb3AgP1xuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvcCA9IHZhbHVlIH0gOlxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvKHRoaXMuc2Nyb2xsWCwgdmFsdWUpIH0pXG4gICAgfSxcbiAgICBzY3JvbGxMZWZ0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cbiAgICAgIHZhciBoYXNTY3JvbGxMZWZ0ID0gJ3Njcm9sbExlZnQnIGluIHRoaXNbMF1cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gaGFzU2Nyb2xsTGVmdCA/IHRoaXNbMF0uc2Nyb2xsTGVmdCA6IHRoaXNbMF0ucGFnZVhPZmZzZXRcbiAgICAgIHJldHVybiB0aGlzLmVhY2goaGFzU2Nyb2xsTGVmdCA/XG4gICAgICAgIGZ1bmN0aW9uKCl7IHRoaXMuc2Nyb2xsTGVmdCA9IHZhbHVlIH0gOlxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvKHZhbHVlLCB0aGlzLnNjcm9sbFkpIH0pXG4gICAgfSxcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cblxuICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdLFxuICAgICAgICAvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuICAgICAgICBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpLFxuICAgICAgICAvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG4gICAgICAgIG9mZnNldCAgICAgICA9IHRoaXMub2Zmc2V0KCksXG4gICAgICAgIHBhcmVudE9mZnNldCA9IHJvb3ROb2RlUkUudGVzdChvZmZzZXRQYXJlbnRbMF0ubm9kZU5hbWUpID8geyB0b3A6IDAsIGxlZnQ6IDAgfSA6IG9mZnNldFBhcmVudC5vZmZzZXQoKVxuXG4gICAgICAvLyBTdWJ0cmFjdCBlbGVtZW50IG1hcmdpbnNcbiAgICAgIC8vIG5vdGU6IHdoZW4gYW4gZWxlbWVudCBoYXMgbWFyZ2luOiBhdXRvIHRoZSBvZmZzZXRMZWZ0IGFuZCBtYXJnaW5MZWZ0XG4gICAgICAvLyBhcmUgdGhlIHNhbWUgaW4gU2FmYXJpIGNhdXNpbmcgb2Zmc2V0LmxlZnQgdG8gaW5jb3JyZWN0bHkgYmUgMFxuICAgICAgb2Zmc2V0LnRvcCAgLT0gcGFyc2VGbG9hdCggJChlbGVtKS5jc3MoJ21hcmdpbi10b3AnKSApIHx8IDBcbiAgICAgIG9mZnNldC5sZWZ0IC09IHBhcnNlRmxvYXQoICQoZWxlbSkuY3NzKCdtYXJnaW4tbGVmdCcpICkgfHwgMFxuXG4gICAgICAvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcbiAgICAgIHBhcmVudE9mZnNldC50b3AgICs9IHBhcnNlRmxvYXQoICQob2Zmc2V0UGFyZW50WzBdKS5jc3MoJ2JvcmRlci10b3Atd2lkdGgnKSApIHx8IDBcbiAgICAgIHBhcmVudE9mZnNldC5sZWZ0ICs9IHBhcnNlRmxvYXQoICQob2Zmc2V0UGFyZW50WzBdKS5jc3MoJ2JvcmRlci1sZWZ0LXdpZHRoJykgKSB8fCAwXG5cbiAgICAgIC8vIFN1YnRyYWN0IHRoZSB0d28gb2Zmc2V0c1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiAgb2Zmc2V0LnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wLFxuICAgICAgICBsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XG4gICAgICB9XG4gICAgfSxcbiAgICBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5ib2R5XG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgIXJvb3ROb2RlUkUudGVzdChwYXJlbnQubm9kZU5hbWUpICYmICQocGFyZW50KS5jc3MoXCJwb3NpdGlvblwiKSA9PSBcInN0YXRpY1wiKVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5vZmZzZXRQYXJlbnRcbiAgICAgICAgcmV0dXJuIHBhcmVudFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBmb3Igbm93XG4gICQuZm4uZGV0YWNoID0gJC5mbi5yZW1vdmVcblxuICAvLyBHZW5lcmF0ZSB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgZnVuY3Rpb25zXG4gIDtbJ3dpZHRoJywgJ2hlaWdodCddLmZvckVhY2goZnVuY3Rpb24oZGltZW5zaW9uKXtcbiAgICB2YXIgZGltZW5zaW9uUHJvcGVydHkgPVxuICAgICAgZGltZW5zaW9uLnJlcGxhY2UoLy4vLCBmdW5jdGlvbihtKXsgcmV0dXJuIG1bMF0udG9VcHBlckNhc2UoKSB9KVxuXG4gICAgJC5mbltkaW1lbnNpb25dID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgdmFyIG9mZnNldCwgZWwgPSB0aGlzWzBdXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGlzV2luZG93KGVsKSA/IGVsWydpbm5lcicgKyBkaW1lbnNpb25Qcm9wZXJ0eV0gOlxuICAgICAgICBpc0RvY3VtZW50KGVsKSA/IGVsLmRvY3VtZW50RWxlbWVudFsnc2Nyb2xsJyArIGRpbWVuc2lvblByb3BlcnR5XSA6XG4gICAgICAgIChvZmZzZXQgPSB0aGlzLm9mZnNldCgpKSAmJiBvZmZzZXRbZGltZW5zaW9uXVxuICAgICAgZWxzZSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XG4gICAgICAgIGVsID0gJCh0aGlzKVxuICAgICAgICBlbC5jc3MoZGltZW5zaW9uLCBmdW5jQXJnKHRoaXMsIHZhbHVlLCBpZHgsIGVsW2RpbWVuc2lvbl0oKSkpXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICBmdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgZnVuKSB7XG4gICAgZnVuKG5vZGUpXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgIHRyYXZlcnNlTm9kZShub2RlLmNoaWxkTm9kZXNbaV0sIGZ1bilcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHRoZSBgYWZ0ZXJgLCBgcHJlcGVuZGAsIGBiZWZvcmVgLCBgYXBwZW5kYCxcbiAgLy8gYGluc2VydEFmdGVyYCwgYGluc2VydEJlZm9yZWAsIGBhcHBlbmRUb2AsIGFuZCBgcHJlcGVuZFRvYCBtZXRob2RzLlxuICBhZGphY2VuY3lPcGVyYXRvcnMuZm9yRWFjaChmdW5jdGlvbihvcGVyYXRvciwgb3BlcmF0b3JJbmRleCkge1xuICAgIHZhciBpbnNpZGUgPSBvcGVyYXRvckluZGV4ICUgMiAvLz0+IHByZXBlbmQsIGFwcGVuZFxuXG4gICAgJC5mbltvcGVyYXRvcl0gPSBmdW5jdGlvbigpe1xuICAgICAgLy8gYXJndW1lbnRzIGNhbiBiZSBub2RlcywgYXJyYXlzIG9mIG5vZGVzLCBaZXB0byBvYmplY3RzIGFuZCBIVE1MIHN0cmluZ3NcbiAgICAgIHZhciBhcmdUeXBlLCBub2RlcyA9ICQubWFwKGFyZ3VtZW50cywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gW11cbiAgICAgICAgICAgIGFyZ1R5cGUgPSB0eXBlKGFyZylcbiAgICAgICAgICAgIGlmIChhcmdUeXBlID09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICBhcmcuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYXJyLnB1c2goZWwpXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJC56ZXB0by5pc1ooZWwpKSByZXR1cm4gYXJyID0gYXJyLmNvbmNhdChlbC5nZXQoKSlcbiAgICAgICAgICAgICAgICBhcnIgPSBhcnIuY29uY2F0KHplcHRvLmZyYWdtZW50KGVsKSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIGFyclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gXCJvYmplY3RcIiB8fCBhcmcgPT0gbnVsbCA/XG4gICAgICAgICAgICAgIGFyZyA6IHplcHRvLmZyYWdtZW50KGFyZylcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwYXJlbnQsIGNvcHlCeUNsb25lID0gdGhpcy5sZW5ndGggPiAxXG4gICAgICBpZiAobm9kZXMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXNcblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihfLCB0YXJnZXQpe1xuICAgICAgICBwYXJlbnQgPSBpbnNpZGUgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50Tm9kZVxuXG4gICAgICAgIC8vIGNvbnZlcnQgYWxsIG1ldGhvZHMgdG8gYSBcImJlZm9yZVwiIG9wZXJhdGlvblxuICAgICAgICB0YXJnZXQgPSBvcGVyYXRvckluZGV4ID09IDAgPyB0YXJnZXQubmV4dFNpYmxpbmcgOlxuICAgICAgICAgICAgICAgICBvcGVyYXRvckluZGV4ID09IDEgPyB0YXJnZXQuZmlyc3RDaGlsZCA6XG4gICAgICAgICAgICAgICAgIG9wZXJhdG9ySW5kZXggPT0gMiA/IHRhcmdldCA6XG4gICAgICAgICAgICAgICAgIG51bGxcblxuICAgICAgICB2YXIgcGFyZW50SW5Eb2N1bWVudCA9ICQuY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBwYXJlbnQpXG5cbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICBpZiAoY29weUJ5Q2xvbmUpIG5vZGUgPSBub2RlLmNsb25lTm9kZSh0cnVlKVxuICAgICAgICAgIGVsc2UgaWYgKCFwYXJlbnQpIHJldHVybiAkKG5vZGUpLnJlbW92ZSgpXG5cbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldClcbiAgICAgICAgICBpZiAocGFyZW50SW5Eb2N1bWVudCkgdHJhdmVyc2VOb2RlKG5vZGUsIGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICAgIGlmIChlbC5ub2RlTmFtZSAhPSBudWxsICYmIGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdTQ1JJUFQnICYmXG4gICAgICAgICAgICAgICAoIWVsLnR5cGUgfHwgZWwudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCcpICYmICFlbC5zcmMpe1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZWwub3duZXJEb2N1bWVudCA/IGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3dcbiAgICAgICAgICAgICAgdGFyZ2V0WydldmFsJ10uY2FsbCh0YXJnZXQsIGVsLmlubmVySFRNTClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBhZnRlciAgICA9PiBpbnNlcnRBZnRlclxuICAgIC8vIHByZXBlbmQgID0+IHByZXBlbmRUb1xuICAgIC8vIGJlZm9yZSAgID0+IGluc2VydEJlZm9yZVxuICAgIC8vIGFwcGVuZCAgID0+IGFwcGVuZFRvXG4gICAgJC5mbltpbnNpZGUgPyBvcGVyYXRvcisnVG8nIDogJ2luc2VydCcrKG9wZXJhdG9ySW5kZXggPyAnQmVmb3JlJyA6ICdBZnRlcicpXSA9IGZ1bmN0aW9uKGh0bWwpe1xuICAgICAgJChodG1sKVtvcGVyYXRvcl0odGhpcylcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9KVxuXG4gIHplcHRvLloucHJvdG90eXBlID0gWi5wcm90b3R5cGUgPSAkLmZuXG5cbiAgLy8gRXhwb3J0IGludGVybmFsIEFQSSBmdW5jdGlvbnMgaW4gdGhlIGAkLnplcHRvYCBuYW1lc3BhY2VcbiAgemVwdG8udW5pcSA9IHVuaXFcbiAgemVwdG8uZGVzZXJpYWxpemVWYWx1ZSA9IGRlc2VyaWFsaXplVmFsdWVcbiAgJC56ZXB0byA9IHplcHRvXG5cbiAgcmV0dXJuICRcbn0pKClcblxuLy8gICAgIFplcHRvLmpzXG4vLyAgICAgKGMpIDIwMTAtMjAxNiBUaG9tYXMgRnVjaHNcbi8vICAgICBaZXB0by5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuOyhmdW5jdGlvbigpe1xuICAvLyBnZXRDb21wdXRlZFN0eWxlIHNob3VsZG4ndCBmcmVhayBvdXQgd2hlbiBjYWxsZWRcbiAgLy8gd2l0aG91dCBhIHZhbGlkIGVsZW1lbnQgYXMgYXJndW1lbnRcbiAgdHJ5IHtcbiAgICBnZXRDb21wdXRlZFN0eWxlKHVuZGVmaW5lZClcbiAgfSBjYXRjaChlKSB7XG4gICAgdmFyIG5hdGl2ZUdldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlXG4gICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBwc2V1ZG9FbGVtZW50KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVHZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIHBzZXVkb0VsZW1lbnQpXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pKClcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2xpYi96ZXB0by5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true */\n/*global module, require */\n\nmodule.exports = {\n\n  // this object does nothing until init is called\n  init: function() {\n\n    // Create shortcut for this to pin down the reference\n    // for creating members of this object.\n    var self = this;\n\n    var _ = __webpack_require__(0);\n\n    // Arrays for keeping track of listeners\n    var doneCallbacks = [];\n    var failCallbacks = [];\n    var resolvedArgs = [];\n    var rejectedArgs = [];\n\n\n    // Flag for checking for the state.  Both default to false\n    // in initial state\n    self.isResolved = false;\n    self.isRejected = false;\n\n    // Add callback for when this function is called\n    self.done = function(callback) {\n      if (self.isResolved) {\n        callback.apply(callback, resolvedArgs);\n      } else {\n        doneCallbacks.push(callback);\n      }\n    };\n\n    // Add callback for when this function is called\n    self.fail = function(callback) {\n      if (self.isRejected) {\n        callback.apply(callback, rejectedArgs);\n      } else {\n        failCallbacks.push(callback);\n      }\n    };\n\n    self.resolve = function() {\n      if (!self.isResolved && !self.isRejected) {\n        resolvedArgs = [].slice.call(arguments);\n        self.isResolved = true;\n        if (doneCallbacks.length) {\n          _.each(doneCallbacks, function(callback) {\n            callback.apply(callback, resolvedArgs);\n          });\n          doneCallbacks = [];\n        }\n      }\n    };\n    self.reject = function() {\n      if (!self.isResolved && !self.isRejected) {\n        rejectedArgs = [].slice.call(arguments);\n        self.isRejected = true;\n        if (failCallbacks.length) {\n          _.each(failCallbacks, function(callback) {\n            callback.apply(callback, rejectedArgs);\n          });\n          failCallbacks = [];\n        }\n      }\n    };\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvYmFzZS9EZWZlcnJhYmxlLmpzP2ZlNDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsQ0FBWTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgbm9tZW46IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdmFyczp0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHJlcXVpcmUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLy8gdGhpcyBvYmplY3QgZG9lcyBub3RoaW5nIHVudGlsIGluaXQgaXMgY2FsbGVkXG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gQ3JlYXRlIHNob3J0Y3V0IGZvciB0aGlzIHRvIHBpbiBkb3duIHRoZSByZWZlcmVuY2VcbiAgICAvLyBmb3IgY3JlYXRpbmcgbWVtYmVycyBvZiB0aGlzIG9iamVjdC5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXG4gICAgLy8gQXJyYXlzIGZvciBrZWVwaW5nIHRyYWNrIG9mIGxpc3RlbmVyc1xuICAgIHZhciBkb25lQ2FsbGJhY2tzID0gW107XG4gICAgdmFyIGZhaWxDYWxsYmFja3MgPSBbXTtcbiAgICB2YXIgcmVzb2x2ZWRBcmdzID0gW107XG4gICAgdmFyIHJlamVjdGVkQXJncyA9IFtdO1xuXG5cbiAgICAvLyBGbGFnIGZvciBjaGVja2luZyBmb3IgdGhlIHN0YXRlLiAgQm90aCBkZWZhdWx0IHRvIGZhbHNlXG4gICAgLy8gaW4gaW5pdGlhbCBzdGF0ZVxuICAgIHNlbGYuaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgIHNlbGYuaXNSZWplY3RlZCA9IGZhbHNlO1xuXG4gICAgLy8gQWRkIGNhbGxiYWNrIGZvciB3aGVuIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkXG4gICAgc2VsZi5kb25lID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIGlmIChzZWxmLmlzUmVzb2x2ZWQpIHtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIHJlc29sdmVkQXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb25lQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBZGQgY2FsbGJhY2sgZm9yIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWRcbiAgICBzZWxmLmZhaWwgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgaWYgKHNlbGYuaXNSZWplY3RlZCkge1xuICAgICAgICBjYWxsYmFjay5hcHBseShjYWxsYmFjaywgcmVqZWN0ZWRBcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhaWxDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNlbGYucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFzZWxmLmlzUmVzb2x2ZWQgJiYgIXNlbGYuaXNSZWplY3RlZCkge1xuICAgICAgICByZXNvbHZlZEFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHNlbGYuaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIGlmIChkb25lQ2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIF8uZWFjaChkb25lQ2FsbGJhY2tzLCBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIHJlc29sdmVkQXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZG9uZUNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBzZWxmLnJlamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFzZWxmLmlzUmVzb2x2ZWQgJiYgIXNlbGYuaXNSZWplY3RlZCkge1xuICAgICAgICByZWplY3RlZEFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIHNlbGYuaXNSZWplY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChmYWlsQ2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgIF8uZWFjaChmYWlsQ2FsbGJhY2tzLCBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoY2FsbGJhY2ssIHJlamVjdGVkQXJncyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZmFpbENhbGxiYWNrcyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Jhc2UvRGVmZXJyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")},function(module,exports,__webpack_require__){eval("/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true */\n/*global module, require */\n\n// BuildElement is intended to be a base class for each type of tag type.  This will be an\n// aggregation of commonly used methods and properties, like creating our base\n// DOM element (docFrag). This class will handle inserting that element into a specified\n// location or default.\n\nmodule.exports = {\n  init: function(props) {\n    var self = this;\n    var _ = __webpack_require__(0);\n    var $ = __webpack_require__(1);\n    var Deferrable = __webpack_require__(2);\n\n    var plugIn = props.plugIn;\n    var name = plugIn.tagName;\n    var src = props.src;\n    var tagType = plugIn.attr.tag;\n    var appendToDIV = props.appendToDIV;\n    var onload = props.onload;\n    var docFrag;\n\n    // Extend Deferrable so we get the methods\n    _.extend(self, Deferrable);\n\n    self.init();\n\n    // Create our Document fragment with the class id of the uuid\n    docFrag = $('<' + tagType + '/>');\n\n    if (src) {\n\n      // Set the source\n      docFrag.attr('src', src);\n    }\n\n    if (onload) {\n      docFrag[0].onload = onload;\n    }\n\n    if (name) {\n      // Assign name if it's passed in\n      docFrag.attr('name', name);\n    }\n\n    // If we're given an `appendToDIV` then we'll append\n    if (!_.isUndefined(appendToDIV)) {\n      appendToDIV.append(docFrag);\n    }\n\n    self.docFrag = docFrag;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL0J1aWxkRWxlbWVudC5qcz9iOTBlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLENBQVk7QUFDaEMsWUFBWSxtQkFBTyxDQUFDLENBQU87QUFDM0IscUJBQXFCLG1CQUFPLENBQUMsQ0FBb0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgZXZpbDogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgbm9tZW46IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdmFyczp0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHJlcXVpcmUgKi9cblxuLy8gQnVpbGRFbGVtZW50IGlzIGludGVuZGVkIHRvIGJlIGEgYmFzZSBjbGFzcyBmb3IgZWFjaCB0eXBlIG9mIHRhZyB0eXBlLiAgVGhpcyB3aWxsIGJlIGFuXG4vLyBhZ2dyZWdhdGlvbiBvZiBjb21tb25seSB1c2VkIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMsIGxpa2UgY3JlYXRpbmcgb3VyIGJhc2Vcbi8vIERPTSBlbGVtZW50IChkb2NGcmFnKS4gVGhpcyBjbGFzcyB3aWxsIGhhbmRsZSBpbnNlcnRpbmcgdGhhdCBlbGVtZW50IGludG8gYSBzcGVjaWZpZWRcbi8vIGxvY2F0aW9uIG9yIGRlZmF1bHQuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0OiBmdW5jdGlvbihwcm9wcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuICAgIHZhciAkID0gcmVxdWlyZShcInplcHRvXCIpO1xuICAgIHZhciBEZWZlcnJhYmxlID0gcmVxdWlyZShcIi4uL2Jhc2UvRGVmZXJyYWJsZVwiKTtcblxuICAgIHZhciBwbHVnSW4gPSBwcm9wcy5wbHVnSW47XG4gICAgdmFyIG5hbWUgPSBwbHVnSW4udGFnTmFtZTtcbiAgICB2YXIgc3JjID0gcHJvcHMuc3JjO1xuICAgIHZhciB0YWdUeXBlID0gcGx1Z0luLmF0dHIudGFnO1xuICAgIHZhciBhcHBlbmRUb0RJViA9IHByb3BzLmFwcGVuZFRvRElWO1xuICAgIHZhciBvbmxvYWQgPSBwcm9wcy5vbmxvYWQ7XG4gICAgdmFyIGRvY0ZyYWc7XG5cbiAgICAvLyBFeHRlbmQgRGVmZXJyYWJsZSBzbyB3ZSBnZXQgdGhlIG1ldGhvZHNcbiAgICBfLmV4dGVuZChzZWxmLCBEZWZlcnJhYmxlKTtcblxuICAgIHNlbGYuaW5pdCgpO1xuXG4gICAgLy8gQ3JlYXRlIG91ciBEb2N1bWVudCBmcmFnbWVudCB3aXRoIHRoZSBjbGFzcyBpZCBvZiB0aGUgdXVpZFxuICAgIGRvY0ZyYWcgPSAkKCc8JyArIHRhZ1R5cGUgKyAnLz4nKTtcblxuICAgIGlmIChzcmMpIHtcblxuICAgICAgLy8gU2V0IHRoZSBzb3VyY2VcbiAgICAgIGRvY0ZyYWcuYXR0cignc3JjJywgc3JjKTtcbiAgICB9XG5cbiAgICBpZiAob25sb2FkKSB7XG4gICAgICBkb2NGcmFnWzBdLm9ubG9hZCA9IG9ubG9hZDtcbiAgICB9XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgLy8gQXNzaWduIG5hbWUgaWYgaXQncyBwYXNzZWQgaW5cbiAgICAgIGRvY0ZyYWcuYXR0cignbmFtZScsIG5hbWUpO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGdpdmVuIGFuIGBhcHBlbmRUb0RJVmAgdGhlbiB3ZSdsbCBhcHBlbmRcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoYXBwZW5kVG9ESVYpKSB7XG4gICAgICBhcHBlbmRUb0RJVi5hcHBlbmQoZG9jRnJhZyk7XG4gICAgfVxuXG4gICAgc2VsZi5kb2NGcmFnID0gZG9jRnJhZztcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2RvbS9CdWlsZEVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, white: true, evil:true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, require */\n\nmodule.exports = function (data) {\n\t\tvar self = this;\n\t\tvar _ = __webpack_require__(0);\n\n\t\tself.data = data;\n\n\n\t\t// method for replacing string token values formatted ${x#} where x = r || c || m || e\n\t\t// and # = the index in the data array.\n\t\tself.replace = function (interpString, addQuotes) {\n\n\t\t\t// regex that splits a string into text elements and token elements\n\t\t\tvar intoParts = /(\\$\\{\\w\\d+\\})/;\n\n\t\t\t// regex that splits a string into text elements and token elements\n\t\t\tvar isToken = /^\\$\\{\\w\\d+\\}$/;\n\n\t\t\t// regex that splits a token into its respective hash mapped method and numerical argument\n\t\t\tvar funcAndArg = /(\\w)(\\d+)/;\n\n\t\t\t// Hash Map of token to methods on the data instance passed in with the constructor\n\t\t\tvar getData = {\n\t\t\t\tr: "getRaw",\n\t\t\t\tc: "getClean",\n\t\t\t\tm: "getMunged",\n\t\t\t\te: "getEnc"\n\t\t\t};\n\t\t\tvar stringParts;\n\t\t\tvar returnValue;\n\n\t\t\tif (!_.isUndefined(self.data) && _.isString(interpString)) {\n\n\t\t\t\t// array holding either text or token parts splits on the regex for the token\n\t\t\t\tstringParts = interpString.split(intoParts);\n\n\t\t\t\t// Go through each element and return either the string or the tokenized data element\n\t\t\t\treturnValue = _.map(stringParts, function (part) {\n\n\t\t\t\t\t// array holding the getData hash value to determine get data method and number holding element to access\n\t\t\t\t\tvar funcRef;\n\t\t\t\t\tif (isToken.test(part)) {\n\n\t\t\t\t\t\t// creates an array of our token\n\t\t\t\t\t\t// eg. part is ${m0} = ["m0", "m", "0"]\n\t\t\t\t\t\tfuncRef = funcAndArg.exec(part);\n\n\t\t\t\t\t\t// funcRef is the mapped single char ("m", "c", etc..) to the fully qualified function name ("getMunged", "getClean", etc...)\n\t\t\t\t\t\t// this calls data[ "functionName" ] and passes the index value\n\t\t\t\t\t\tpart = self.data[getData[funcRef[1]]](funcRef[2]);\n\t\t\t\t\t\tif (funcRef[1] === "m" || addQuotes) {\n\t\t\t\t\t\t\tpart = JSON.stringify(part);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn part;\n\t\t\t\t});\n\n\t\t\t\treturnValue = returnValue.join(\'\');\n\t\t\t} else {\n\t\t\t\treturnValue = interpString;\n\t\t\t}\n\t\t\treturn returnValue;\n\t\t};\n\t};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9Ub2tlblJlcGxhY2VyLmpzP2ExYWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQVk7O0FBRTlCOzs7QUFHQSwwREFBMEQsR0FBRztBQUM3RDtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLE9BQU87O0FBRWhDO0FBQ0EsdUJBQXVCLE9BQU87O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsR0FBRztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgZXZpbDp0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUsIHBsdXNwbHVzOnRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5cblx0XHRzZWxmLmRhdGEgPSBkYXRhO1xuXG5cblx0XHQvLyBtZXRob2QgZm9yIHJlcGxhY2luZyBzdHJpbmcgdG9rZW4gdmFsdWVzIGZvcm1hdHRlZCAke3gjfSB3aGVyZSB4ID0gciB8fCBjIHx8IG0gfHwgZVxuXHRcdC8vIGFuZCAjID0gdGhlIGluZGV4IGluIHRoZSBkYXRhIGFycmF5LlxuXHRcdHNlbGYucmVwbGFjZSA9IGZ1bmN0aW9uIChpbnRlcnBTdHJpbmcsIGFkZFF1b3Rlcykge1xuXG5cdFx0XHQvLyByZWdleCB0aGF0IHNwbGl0cyBhIHN0cmluZyBpbnRvIHRleHQgZWxlbWVudHMgYW5kIHRva2VuIGVsZW1lbnRzXG5cdFx0XHR2YXIgaW50b1BhcnRzID0gLyhcXCRcXHtcXHdcXGQrXFx9KS87XG5cblx0XHRcdC8vIHJlZ2V4IHRoYXQgc3BsaXRzIGEgc3RyaW5nIGludG8gdGV4dCBlbGVtZW50cyBhbmQgdG9rZW4gZWxlbWVudHNcblx0XHRcdHZhciBpc1Rva2VuID0gL15cXCRcXHtcXHdcXGQrXFx9JC87XG5cblx0XHRcdC8vIHJlZ2V4IHRoYXQgc3BsaXRzIGEgdG9rZW4gaW50byBpdHMgcmVzcGVjdGl2ZSBoYXNoIG1hcHBlZCBtZXRob2QgYW5kIG51bWVyaWNhbCBhcmd1bWVudFxuXHRcdFx0dmFyIGZ1bmNBbmRBcmcgPSAvKFxcdykoXFxkKykvO1xuXG5cdFx0XHQvLyBIYXNoIE1hcCBvZiB0b2tlbiB0byBtZXRob2RzIG9uIHRoZSBkYXRhIGluc3RhbmNlIHBhc3NlZCBpbiB3aXRoIHRoZSBjb25zdHJ1Y3RvclxuXHRcdFx0dmFyIGdldERhdGEgPSB7XG5cdFx0XHRcdHI6IFwiZ2V0UmF3XCIsXG5cdFx0XHRcdGM6IFwiZ2V0Q2xlYW5cIixcblx0XHRcdFx0bTogXCJnZXRNdW5nZWRcIixcblx0XHRcdFx0ZTogXCJnZXRFbmNcIlxuXHRcdFx0fTtcblx0XHRcdHZhciBzdHJpbmdQYXJ0cztcblx0XHRcdHZhciByZXR1cm5WYWx1ZTtcblxuXHRcdFx0aWYgKCFfLmlzVW5kZWZpbmVkKHNlbGYuZGF0YSkgJiYgXy5pc1N0cmluZyhpbnRlcnBTdHJpbmcpKSB7XG5cblx0XHRcdFx0Ly8gYXJyYXkgaG9sZGluZyBlaXRoZXIgdGV4dCBvciB0b2tlbiBwYXJ0cyBzcGxpdHMgb24gdGhlIHJlZ2V4IGZvciB0aGUgdG9rZW5cblx0XHRcdFx0c3RyaW5nUGFydHMgPSBpbnRlcnBTdHJpbmcuc3BsaXQoaW50b1BhcnRzKTtcblxuXHRcdFx0XHQvLyBHbyB0aHJvdWdoIGVhY2ggZWxlbWVudCBhbmQgcmV0dXJuIGVpdGhlciB0aGUgc3RyaW5nIG9yIHRoZSB0b2tlbml6ZWQgZGF0YSBlbGVtZW50XG5cdFx0XHRcdHJldHVyblZhbHVlID0gXy5tYXAoc3RyaW5nUGFydHMsIGZ1bmN0aW9uIChwYXJ0KSB7XG5cblx0XHRcdFx0XHQvLyBhcnJheSBob2xkaW5nIHRoZSBnZXREYXRhIGhhc2ggdmFsdWUgdG8gZGV0ZXJtaW5lIGdldCBkYXRhIG1ldGhvZCBhbmQgbnVtYmVyIGhvbGRpbmcgZWxlbWVudCB0byBhY2Nlc3Ncblx0XHRcdFx0XHR2YXIgZnVuY1JlZjtcblx0XHRcdFx0XHRpZiAoaXNUb2tlbi50ZXN0KHBhcnQpKSB7XG5cblx0XHRcdFx0XHRcdC8vIGNyZWF0ZXMgYW4gYXJyYXkgb2Ygb3VyIHRva2VuXG5cdFx0XHRcdFx0XHQvLyBlZy4gcGFydCBpcyAke20wfSA9IFtcIm0wXCIsIFwibVwiLCBcIjBcIl1cblx0XHRcdFx0XHRcdGZ1bmNSZWYgPSBmdW5jQW5kQXJnLmV4ZWMocGFydCk7XG5cblx0XHRcdFx0XHRcdC8vIGZ1bmNSZWYgaXMgdGhlIG1hcHBlZCBzaW5nbGUgY2hhciAoXCJtXCIsIFwiY1wiLCBldGMuLikgdG8gdGhlIGZ1bGx5IHF1YWxpZmllZCBmdW5jdGlvbiBuYW1lIChcImdldE11bmdlZFwiLCBcImdldENsZWFuXCIsIGV0Yy4uLilcblx0XHRcdFx0XHRcdC8vIHRoaXMgY2FsbHMgZGF0YVsgXCJmdW5jdGlvbk5hbWVcIiBdIGFuZCBwYXNzZXMgdGhlIGluZGV4IHZhbHVlXG5cdFx0XHRcdFx0XHRwYXJ0ID0gc2VsZi5kYXRhW2dldERhdGFbZnVuY1JlZlsxXV1dKGZ1bmNSZWZbMl0pO1xuXHRcdFx0XHRcdFx0aWYgKGZ1bmNSZWZbMV0gPT09IFwibVwiIHx8IGFkZFF1b3Rlcykge1xuXHRcdFx0XHRcdFx0XHRwYXJ0ID0gSlNPTi5zdHJpbmdpZnkocGFydCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHBhcnQ7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVyblZhbHVlID0gcmV0dXJuVmFsdWUuam9pbignJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IGludGVycFN0cmluZztcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHR9O1xuXHR9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZGF0YS9Ub2tlblJlcGxhY2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){eval("/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true */\n/*global require, module */\n\nmodule.exports = function () {\n\n\tvar _ = __webpack_require__(0);\n\n\t_.mixin({\n\t\tisSet: function (e) {\n\n\t\t\tvar retr = false;\n\t\t\tvar _isString = _.isString;\n\t\t\tvar _isArray = _.isArray;\n\n\t\t\t// it will either be a string or array to be considered 'set'\n\t\t\tif (_isString(e)) {\n\n\t\t\t\t// first is super simple, if it's a string and the length\n\t\t\t\t// is greater than 0, we know it's set with something.\n\t\t\t\tretr = e.length > 0;\n\n\t\t\t} else if (_.isArray(e)) {\n\n\t\t\t\t// second is a little more complicated.  if we know it's an array, we need to check each\n\t\t\t\t// element in the array.  We'll do that by using the underscore filter method if there is\n\t\t\t\t// at least one element in the final array then we know it's set with something.\n\t\t\t\tretr = _.filter(e, function (x) {\n\n\t\t\t\t\t// assume false\n\t\t\t\t\tvar xRetr = false;\n\n\t\t\t\t\t// is our first element an array? this would be an array within the outer array of 'e'\n\t\t\t\t\tif (_isArray(x)) {\n\n\t\t\t\t\t\t// We know it's an array lets check out the first element. it must have at least\n\t\t\t\t\t\t// the first element to be 'set'.  Here we're going to check if it is a string and\n\t\t\t\t\t\t// if it is then, just like the outer element, it must have at least a length of 1\n\t\t\t\t\t\t// to be considered 'set'.  Otherwise we'll see if it's an object (not array object)\n\t\t\t\t\t\t// that's not empty.\n\t\t\t\t\t\tif (_isString(x[0])) {\n\n\t\t\t\t\t\t\txRetr = x[0].length > 0;\n\n\t\t\t\t\t\t} else if (_.isObject(x[0]) && !_isArray(x[0])) {\n\n\t\t\t\t\t\t\txRetr = !_.isEmpty(x[0]);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if it's not an array then it's most likely a string, but it could be\n\t\t\t\t\t\t// something different so we won't assume just an else here. Same test as \n\t\t\t\t\t\t// alays for a string, does it have a length of at least 1.\n\t\t\t\t\t} else if (_isString(x)) {\n\t\t\t\t\t\txRetr = x.length > 0;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn xRetr; \n\n\t\t\t\t}).length > 0;\n\n\t\t\t}\n\n\t\t\treturn retr;\n\n\t\t}\n\t});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdW5kZXJzY29yZV9taXhpbnMvaXNTZXQuanM/MDhhMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyxDQUFZOztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxrQjs7QUFFQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0EsRUFBRTtBQUNGIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBldmlsOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXG5cdF8ubWl4aW4oe1xuXHRcdGlzU2V0OiBmdW5jdGlvbiAoZSkge1xuXG5cdFx0XHR2YXIgcmV0ciA9IGZhbHNlO1xuXHRcdFx0dmFyIF9pc1N0cmluZyA9IF8uaXNTdHJpbmc7XG5cdFx0XHR2YXIgX2lzQXJyYXkgPSBfLmlzQXJyYXk7XG5cblx0XHRcdC8vIGl0IHdpbGwgZWl0aGVyIGJlIGEgc3RyaW5nIG9yIGFycmF5IHRvIGJlIGNvbnNpZGVyZWQgJ3NldCdcblx0XHRcdGlmIChfaXNTdHJpbmcoZSkpIHtcblxuXHRcdFx0XHQvLyBmaXJzdCBpcyBzdXBlciBzaW1wbGUsIGlmIGl0J3MgYSBzdHJpbmcgYW5kIHRoZSBsZW5ndGhcblx0XHRcdFx0Ly8gaXMgZ3JlYXRlciB0aGFuIDAsIHdlIGtub3cgaXQncyBzZXQgd2l0aCBzb21ldGhpbmcuXG5cdFx0XHRcdHJldHIgPSBlLmxlbmd0aCA+IDA7XG5cblx0XHRcdH0gZWxzZSBpZiAoXy5pc0FycmF5KGUpKSB7XG5cblx0XHRcdFx0Ly8gc2Vjb25kIGlzIGEgbGl0dGxlIG1vcmUgY29tcGxpY2F0ZWQuICBpZiB3ZSBrbm93IGl0J3MgYW4gYXJyYXksIHdlIG5lZWQgdG8gY2hlY2sgZWFjaFxuXHRcdFx0XHQvLyBlbGVtZW50IGluIHRoZSBhcnJheS4gIFdlJ2xsIGRvIHRoYXQgYnkgdXNpbmcgdGhlIHVuZGVyc2NvcmUgZmlsdGVyIG1ldGhvZCBpZiB0aGVyZSBpc1xuXHRcdFx0XHQvLyBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgZmluYWwgYXJyYXkgdGhlbiB3ZSBrbm93IGl0J3Mgc2V0IHdpdGggc29tZXRoaW5nLlxuXHRcdFx0XHRyZXRyID0gXy5maWx0ZXIoZSwgZnVuY3Rpb24gKHgpIHtcblxuXHRcdFx0XHRcdC8vIGFzc3VtZSBmYWxzZVxuXHRcdFx0XHRcdHZhciB4UmV0ciA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gaXMgb3VyIGZpcnN0IGVsZW1lbnQgYW4gYXJyYXk/IHRoaXMgd291bGQgYmUgYW4gYXJyYXkgd2l0aGluIHRoZSBvdXRlciBhcnJheSBvZiAnZSdcblx0XHRcdFx0XHRpZiAoX2lzQXJyYXkoeCkpIHtcblxuXHRcdFx0XHRcdFx0Ly8gV2Uga25vdyBpdCdzIGFuIGFycmF5IGxldHMgY2hlY2sgb3V0IHRoZSBmaXJzdCBlbGVtZW50LiBpdCBtdXN0IGhhdmUgYXQgbGVhc3Rcblx0XHRcdFx0XHRcdC8vIHRoZSBmaXJzdCBlbGVtZW50IHRvIGJlICdzZXQnLiAgSGVyZSB3ZSdyZSBnb2luZyB0byBjaGVjayBpZiBpdCBpcyBhIHN0cmluZyBhbmRcblx0XHRcdFx0XHRcdC8vIGlmIGl0IGlzIHRoZW4sIGp1c3QgbGlrZSB0aGUgb3V0ZXIgZWxlbWVudCwgaXQgbXVzdCBoYXZlIGF0IGxlYXN0IGEgbGVuZ3RoIG9mIDFcblx0XHRcdFx0XHRcdC8vIHRvIGJlIGNvbnNpZGVyZWQgJ3NldCcuICBPdGhlcndpc2Ugd2UnbGwgc2VlIGlmIGl0J3MgYW4gb2JqZWN0IChub3QgYXJyYXkgb2JqZWN0KVxuXHRcdFx0XHRcdFx0Ly8gdGhhdCdzIG5vdCBlbXB0eS5cblx0XHRcdFx0XHRcdGlmIChfaXNTdHJpbmcoeFswXSkpIHtcblxuXHRcdFx0XHRcdFx0XHR4UmV0ciA9IHhbMF0ubGVuZ3RoID4gMDtcblxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChfLmlzT2JqZWN0KHhbMF0pICYmICFfaXNBcnJheSh4WzBdKSkge1xuXG5cdFx0XHRcdFx0XHRcdHhSZXRyID0gIV8uaXNFbXB0eSh4WzBdKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBpZiBpdCdzIG5vdCBhbiBhcnJheSB0aGVuIGl0J3MgbW9zdCBsaWtlbHkgYSBzdHJpbmcsIGJ1dCBpdCBjb3VsZCBiZVxuXHRcdFx0XHRcdFx0Ly8gc29tZXRoaW5nIGRpZmZlcmVudCBzbyB3ZSB3b24ndCBhc3N1bWUganVzdCBhbiBlbHNlIGhlcmUuIFNhbWUgdGVzdCBhcyBcblx0XHRcdFx0XHRcdC8vIGFsYXlzIGZvciBhIHN0cmluZywgZG9lcyBpdCBoYXZlIGEgbGVuZ3RoIG9mIGF0IGxlYXN0IDEuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChfaXNTdHJpbmcoeCkpIHtcblx0XHRcdFx0XHRcdHhSZXRyID0geC5sZW5ndGggPiAwO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB4UmV0cjsgXG5cblx0XHRcdFx0fSkubGVuZ3RoID4gMDtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmV0cjtcblxuXHRcdH1cblx0fSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdW5kZXJzY29yZV9taXhpbnMvaXNTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n")},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, evil:true, vars:true, plusplus:true */\n/*global module, require */\n\nmodule.exports = function(funcObj, data) {\n\t\n\tvar ProcessArgs = __webpack_require__(11);\n\tvar StringFunction = __webpack_require__(38);\n\t\n\tvar pa = new ProcessArgs(data);\t\n\tvar sf = new StringFunction(funcObj.func, pa.process(funcObj.args));\n\t\n\treturn sf.run();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9GdW5jdGlvblJ1bm5lci5qcz9mZmE0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsRUFBZTtBQUMxQyxzQkFBc0IsbUJBQU8sQ0FBQyxFQUFrQjs7QUFFaEQsZ0M7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCBldmlsOnRydWUsIHZhcnM6dHJ1ZSwgcGx1c3BsdXM6dHJ1ZSAqL1xuLypnbG9iYWwgbW9kdWxlLCByZXF1aXJlICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZnVuY09iaiwgZGF0YSkge1xuXHRcblx0dmFyIFByb2Nlc3NBcmdzID0gcmVxdWlyZShcIi4vUHJvY2Vzc0FyZ3NcIik7XG5cdHZhciBTdHJpbmdGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL1N0cmluZ0Z1bmN0aW9uXCIpO1xuXHRcblx0dmFyIHBhID0gbmV3IFByb2Nlc3NBcmdzKGRhdGEpO1x0XG5cdHZhciBzZiA9IG5ldyBTdHJpbmdGdW5jdGlvbihmdW5jT2JqLmZ1bmMsIHBhLnByb2Nlc3MoZnVuY09iai5hcmdzKSk7XG5cdFxuXHRyZXR1cm4gc2YucnVuKCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZGF0YS9GdW5jdGlvblJ1bm5lci5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n")},function(module,exports,__webpack_require__){eval("/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true */\n/*global require, module */\n\nmodule.exports = function() {\n\n  var _ = __webpack_require__(0);\n  var $ = __webpack_require__(1);\n\n  _.mixin({\n    // `cloneArray()`: Function for cloning array\n    //  1. `array`: Array to be cloned and completely dereferenced\n    cloneArray: function(array) {\n      return $.extend(true, {}, {\n        a: array\n      }).a;\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdW5kZXJzY29yZV9taXhpbnMvY2xvbmVBcnJheS5qcz9iNTU3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLENBQVk7QUFDOUIsVUFBVSxtQkFBTyxDQUFDLENBQU87O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBldmlsOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG4gIHZhciAkID0gcmVxdWlyZShcInplcHRvXCIpO1xuXG4gIF8ubWl4aW4oe1xuICAgIC8vIGBjbG9uZUFycmF5KClgOiBGdW5jdGlvbiBmb3IgY2xvbmluZyBhcnJheVxuICAgIC8vICAxLiBgYXJyYXlgOiBBcnJheSB0byBiZSBjbG9uZWQgYW5kIGNvbXBsZXRlbHkgZGVyZWZlcmVuY2VkXG4gICAgY2xvbmVBcnJheTogZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgIHJldHVybiAkLmV4dGVuZCh0cnVlLCB7fSwge1xuICAgICAgICBhOiBhcnJheVxuICAgICAgfSkuYTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3VuZGVyc2NvcmVfbWl4aW5zL2Nsb25lQXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){eval('/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true */\n/*global require, module */\n\nmodule.exports = function() {\n\n  var _ = __webpack_require__(0);\n\n  _.mixin({\n\n    // Takes stringified regex and converts to a real regex\n    convertRegExp: function(str) {\n      var regexStr;\n      var regexParts;\n      var modifiers = "";\n      if (str.indexOf("/") === 0) {\n        var lastSlash = str.lastIndexOf(\'/\');\n        regexStr = str.substr(1,lastSlash - 1);\n        modifiers = str.substr(lastSlash + 1);\n      }\n      return new RegExp(regexStr, modifiers);\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdW5kZXJzY29yZV9taXhpbnMvY29udmVydFJlZ0V4cC5qcz84ZDkyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLENBQVk7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgZXZpbDogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgbm9tZW46IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdmFyczp0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXG4gIF8ubWl4aW4oe1xuXG4gICAgLy8gVGFrZXMgc3RyaW5naWZpZWQgcmVnZXggYW5kIGNvbnZlcnRzIHRvIGEgcmVhbCByZWdleFxuICAgIGNvbnZlcnRSZWdFeHA6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIHJlZ2V4U3RyO1xuICAgICAgdmFyIHJlZ2V4UGFydHM7XG4gICAgICB2YXIgbW9kaWZpZXJzID0gXCJcIjtcbiAgICAgIGlmIChzdHIuaW5kZXhPZihcIi9cIikgPT09IDApIHtcbiAgICAgICAgdmFyIGxhc3RTbGFzaCA9IHN0ci5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICByZWdleFN0ciA9IHN0ci5zdWJzdHIoMSxsYXN0U2xhc2ggLSAxKTtcbiAgICAgICAgbW9kaWZpZXJzID0gc3RyLnN1YnN0cihsYXN0U2xhc2ggKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlZ2V4U3RyLCBtb2RpZmllcnMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdW5kZXJzY29yZV9taXhpbnMvY29udmVydFJlZ0V4cC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n')},function(module,exports,__webpack_require__){eval("/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true */\n/*global require, module */\n\nmodule.exports = function() {\n\n  var _ = __webpack_require__(0);\n\n  _.mixin({\n    isInterpObject: function(e) {\n      return (_.isObject(e) && _.isString(e.interp));\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdW5kZXJzY29yZV9taXhpbnMvaXNJbnRlcnBPYmplY3QuanM/Mzg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBOztBQUVBLFVBQVUsbUJBQU8sQ0FBQyxDQUFZOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgZXZpbDogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgbm9tZW46IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdmFyczp0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXG4gIF8ubWl4aW4oe1xuICAgIGlzSW50ZXJwT2JqZWN0OiBmdW5jdGlvbihlKSB7XG4gICAgICByZXR1cm4gKF8uaXNPYmplY3QoZSkgJiYgXy5pc1N0cmluZyhlLmludGVycCkpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdW5kZXJzY29yZV9taXhpbnMvaXNJbnRlcnBPYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){eval("/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true */\n/*global require, module */\n\n// why was this mixin created when you have many options to prepend an array in javascript?\n// I'm glad you asked... Well, through some performance testing I've come to realize that\n// the efficiency of using 'unshift' or 'concat' is not as good as creating a new array or\n// even [newValue].push.apply(this, oldArray);\n\nmodule.exports = function() {\n\n  var _ = __webpack_require__(0);\n\n  _.mixin({\n    prependArray: function(array, prepend) {\n      var i = 0;\n      var len = array.length;\n      var newArray = [prepend];\n\n      newArray[0] = prepend;\n      for (i; i < len; i++) {\n        newArray.push(array[i]);\n      }\n      return newArray;\n    }\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdW5kZXJzY29yZV9taXhpbnMvcHJlcGVuZEFycmF5LmpzPzI5YmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLG1CQUFPLENBQUMsQ0FBWTs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIGV2aWw6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIG5vbWVuOiB0cnVlLCByZWdleHA6IHRydWUsIHZhcnM6dHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cbi8vIHdoeSB3YXMgdGhpcyBtaXhpbiBjcmVhdGVkIHdoZW4geW91IGhhdmUgbWFueSBvcHRpb25zIHRvIHByZXBlbmQgYW4gYXJyYXkgaW4gamF2YXNjcmlwdD9cbi8vIEknbSBnbGFkIHlvdSBhc2tlZC4uLiBXZWxsLCB0aHJvdWdoIHNvbWUgcGVyZm9ybWFuY2UgdGVzdGluZyBJJ3ZlIGNvbWUgdG8gcmVhbGl6ZSB0aGF0XG4vLyB0aGUgZWZmaWNpZW5jeSBvZiB1c2luZyAndW5zaGlmdCcgb3IgJ2NvbmNhdCcgaXMgbm90IGFzIGdvb2QgYXMgY3JlYXRpbmcgYSBuZXcgYXJyYXkgb3Jcbi8vIGV2ZW4gW25ld1ZhbHVlXS5wdXNoLmFwcGx5KHRoaXMsIG9sZEFycmF5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblxuICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXG4gIF8ubWl4aW4oe1xuICAgIHByZXBlbmRBcnJheTogZnVuY3Rpb24oYXJyYXksIHByZXBlbmQpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICB2YXIgbmV3QXJyYXkgPSBbcHJlcGVuZF07XG5cbiAgICAgIG5ld0FycmF5WzBdID0gcHJlcGVuZDtcbiAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG5ld0FycmF5LnB1c2goYXJyYXlbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0FycmF5O1xuICAgIH1cbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdW5kZXJzY29yZV9taXhpbnMvcHJlcGVuZEFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, evil:true, vars:true, plusplus:true */\n/*global module, require */\n\nmodule.exports = function(data) {\n\n  var _ = __webpack_require__(0);\n  var TokenReplacer = __webpack_require__(4);\n  __webpack_require__(9)();\n  \n  var tokenReplacer = new TokenReplacer(data);\n\n  this.process = function(args) {\n\n    // process the args.  We'll loop through each one and process individually\n    _.each(args, function(arg, i) {\n\n      // First check if it's a string.  If it is, it'll be an escaped string that will need to be\n      // JSON parsed.  When it's parsed the result will either be a primitive unescpaed string or\n      // or another object with an interp property containing a string in it with a token (or more)\n      // to replace.\n      if (_.isString(arg) && arg.length > 0) {\n\n        args[i] = arg = JSON.parse(arg);\n      }\n\n      // Either we had an object to begin with with an interp, or we just JSON.parse'd a string\n      // into an object.  If it's not an object this condition will be ignored.  If we have an\n      // object, we expect it to be an object with an interp inside of it, in which case we'll\n      // need to replace any tokens within it.\n      if (_.isInterpObject(arg)) {\n\n        args[i] = arg = JSON.parse(tokenReplacer.replace(arg.interp));\n      }\n    });\n\n    return args;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9Qcm9jZXNzQXJncy5qcz9iMmJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLENBQVk7QUFDOUIsc0JBQXNCLG1CQUFPLENBQUMsQ0FBaUI7QUFDL0MsRUFBRSxtQkFBTyxDQUFDLENBQTRDOztBQUV0RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIG5vbWVuOiB0cnVlLCByZWdleHA6IHRydWUsIGV2aWw6dHJ1ZSwgdmFyczp0cnVlLCBwbHVzcGx1czp0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHJlcXVpcmUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhKSB7XG5cbiAgdmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbiAgdmFyIFRva2VuUmVwbGFjZXIgPSByZXF1aXJlKFwiLi9Ub2tlblJlcGxhY2VyXCIpO1xuICByZXF1aXJlKFwiLi4vLi4vbGliL3VuZGVyc2NvcmVfbWl4aW5zL2lzSW50ZXJwT2JqZWN0XCIpKCk7XG4gIFxuICB2YXIgdG9rZW5SZXBsYWNlciA9IG5ldyBUb2tlblJlcGxhY2VyKGRhdGEpO1xuXG4gIHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKGFyZ3MpIHtcblxuICAgIC8vIHByb2Nlc3MgdGhlIGFyZ3MuICBXZSdsbCBsb29wIHRocm91Z2ggZWFjaCBvbmUgYW5kIHByb2Nlc3MgaW5kaXZpZHVhbGx5XG4gICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uKGFyZywgaSkge1xuXG4gICAgICAvLyBGaXJzdCBjaGVjayBpZiBpdCdzIGEgc3RyaW5nLiAgSWYgaXQgaXMsIGl0J2xsIGJlIGFuIGVzY2FwZWQgc3RyaW5nIHRoYXQgd2lsbCBuZWVkIHRvIGJlXG4gICAgICAvLyBKU09OIHBhcnNlZC4gIFdoZW4gaXQncyBwYXJzZWQgdGhlIHJlc3VsdCB3aWxsIGVpdGhlciBiZSBhIHByaW1pdGl2ZSB1bmVzY3BhZWQgc3RyaW5nIG9yXG4gICAgICAvLyBvciBhbm90aGVyIG9iamVjdCB3aXRoIGFuIGludGVycCBwcm9wZXJ0eSBjb250YWluaW5nIGEgc3RyaW5nIGluIGl0IHdpdGggYSB0b2tlbiAob3IgbW9yZSlcbiAgICAgIC8vIHRvIHJlcGxhY2UuXG4gICAgICBpZiAoXy5pc1N0cmluZyhhcmcpICYmIGFyZy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgYXJnc1tpXSA9IGFyZyA9IEpTT04ucGFyc2UoYXJnKTtcbiAgICAgIH1cblxuICAgICAgLy8gRWl0aGVyIHdlIGhhZCBhbiBvYmplY3QgdG8gYmVnaW4gd2l0aCB3aXRoIGFuIGludGVycCwgb3Igd2UganVzdCBKU09OLnBhcnNlJ2QgYSBzdHJpbmdcbiAgICAgIC8vIGludG8gYW4gb2JqZWN0LiAgSWYgaXQncyBub3QgYW4gb2JqZWN0IHRoaXMgY29uZGl0aW9uIHdpbGwgYmUgaWdub3JlZC4gIElmIHdlIGhhdmUgYW5cbiAgICAgIC8vIG9iamVjdCwgd2UgZXhwZWN0IGl0IHRvIGJlIGFuIG9iamVjdCB3aXRoIGFuIGludGVycCBpbnNpZGUgb2YgaXQsIGluIHdoaWNoIGNhc2Ugd2UnbGxcbiAgICAgIC8vIG5lZWQgdG8gcmVwbGFjZSBhbnkgdG9rZW5zIHdpdGhpbiBpdC5cbiAgICAgIGlmIChfLmlzSW50ZXJwT2JqZWN0KGFyZykpIHtcblxuICAgICAgICBhcmdzW2ldID0gYXJnID0gSlNPTi5wYXJzZSh0b2tlblJlcGxhY2VyLnJlcGxhY2UoYXJnLmludGVycCkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFyZ3M7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZGF0YS9Qcm9jZXNzQXJncy5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n")},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, require */\n\nmodule.exports = function(postBuild, data) {\n\n  var FunctionRunner = __webpack_require__(6);\n\n\t// number of attempts executed so far\n\t// this is our counter\n  var attempts = 0;\n\n\t// delay for retry\n  var timeOutLength = 5;\n\n\t// limit of number of retries\n  var attemptsLimit = 10;\n\n  var runIt = function() {\n\n\t\t// Increment our counter\n    attempts += 1;\n\n\t\t// Wrap this in a try catch and retry a number of times.\n\t\t//\n\t\t// Why do we do this?  Why is it so janky?  Great questions.\n\t\t// Here's the problem, there is no way to know whether or\n\t\t// not the script that has been loaded on the page has\n\t\t// executed.  The most common use case for a postBuild is to\n\t\t// call a function that is put on the page by a script that\n\t\t// is loaded eternally. Unfortunately, this is the only\n\t\t// solution I know of that can work and yes I'm not\n\t\t// proud of it...\n    try {\n\n      FunctionRunner(postBuild, data);\n    } catch (err) {\n\n      if (attempts <= attemptsLimit) {\n\n\t\t\t\t// give it a delay to run again, maybe this time the\n\t\t\t\t// function exists on the page.\n        setTimeout(runIt, timeOutLength);\n      } else {\n\n        throw err;\n      }\n    }\n  };\n\n\t// Start the process\n  setTimeout(runIt, 0);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbHMvcnVuUG9zdEJ1aWxkLmpzP2M0MDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsbUJBQU8sQ0FBQyxDQUF3Qjs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjEyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgbm9tZW46IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdmFyczp0cnVlLCBwbHVzcGx1czp0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHJlcXVpcmUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwb3N0QnVpbGQsIGRhdGEpIHtcblxuICB2YXIgRnVuY3Rpb25SdW5uZXIgPSByZXF1aXJlKFwiLi4vZGF0YS9GdW5jdGlvblJ1bm5lclwiKTtcblxuXHQvLyBudW1iZXIgb2YgYXR0ZW1wdHMgZXhlY3V0ZWQgc28gZmFyXG5cdC8vIHRoaXMgaXMgb3VyIGNvdW50ZXJcbiAgdmFyIGF0dGVtcHRzID0gMDtcblxuXHQvLyBkZWxheSBmb3IgcmV0cnlcbiAgdmFyIHRpbWVPdXRMZW5ndGggPSA1O1xuXG5cdC8vIGxpbWl0IG9mIG51bWJlciBvZiByZXRyaWVzXG4gIHZhciBhdHRlbXB0c0xpbWl0ID0gMTA7XG5cbiAgdmFyIHJ1bkl0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBJbmNyZW1lbnQgb3VyIGNvdW50ZXJcbiAgICBhdHRlbXB0cyArPSAxO1xuXG5cdFx0Ly8gV3JhcCB0aGlzIGluIGEgdHJ5IGNhdGNoIGFuZCByZXRyeSBhIG51bWJlciBvZiB0aW1lcy5cblx0XHQvL1xuXHRcdC8vIFdoeSBkbyB3ZSBkbyB0aGlzPyAgV2h5IGlzIGl0IHNvIGphbmt5PyAgR3JlYXQgcXVlc3Rpb25zLlxuXHRcdC8vIEhlcmUncyB0aGUgcHJvYmxlbSwgdGhlcmUgaXMgbm8gd2F5IHRvIGtub3cgd2hldGhlciBvclxuXHRcdC8vIG5vdCB0aGUgc2NyaXB0IHRoYXQgaGFzIGJlZW4gbG9hZGVkIG9uIHRoZSBwYWdlIGhhc1xuXHRcdC8vIGV4ZWN1dGVkLiAgVGhlIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciBhIHBvc3RCdWlsZCBpcyB0b1xuXHRcdC8vIGNhbGwgYSBmdW5jdGlvbiB0aGF0IGlzIHB1dCBvbiB0aGUgcGFnZSBieSBhIHNjcmlwdCB0aGF0XG5cdFx0Ly8gaXMgbG9hZGVkIGV0ZXJuYWxseS4gVW5mb3J0dW5hdGVseSwgdGhpcyBpcyB0aGUgb25seVxuXHRcdC8vIHNvbHV0aW9uIEkga25vdyBvZiB0aGF0IGNhbiB3b3JrIGFuZCB5ZXMgSSdtIG5vdFxuXHRcdC8vIHByb3VkIG9mIGl0Li4uXG4gICAgdHJ5IHtcblxuICAgICAgRnVuY3Rpb25SdW5uZXIocG9zdEJ1aWxkLCBkYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcblxuICAgICAgaWYgKGF0dGVtcHRzIDw9IGF0dGVtcHRzTGltaXQpIHtcblxuXHRcdFx0XHQvLyBnaXZlIGl0IGEgZGVsYXkgdG8gcnVuIGFnYWluLCBtYXliZSB0aGlzIHRpbWUgdGhlXG5cdFx0XHRcdC8vIGZ1bmN0aW9uIGV4aXN0cyBvbiB0aGUgcGFnZS5cbiAgICAgICAgc2V0VGltZW91dChydW5JdCwgdGltZU91dExlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblx0Ly8gU3RhcnQgdGhlIHByb2Nlc3NcbiAgc2V0VGltZW91dChydW5JdCwgMCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdXRpbHMvcnVuUG9zdEJ1aWxkLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///12\n")},function(module,exports,__webpack_require__){eval('/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global require, module */\n\nmodule.exports = function(tagManager, actions) {\n\n    var VariableWatcher = __webpack_require__(48);\n    var variableWatcher;\n    var stateChangeWrappers = __webpack_require__(47);\n    var reset = tagManager.reset;\n    var $ = __webpack_require__(1);\n    var _ = __webpack_require__(0);\n    var watchingEvent;\n    var domEventHandler = function(event) {\n        event.currentTarget.removeEventListener(watchingEvent, domEventHandler);\n        reset();\n    };\n\n    _.each(actions, function(action) {\n\n        switch (action.type) {\n\n            case "var":\n                VariableWatcher(action.windowVar, reset);\n                break;\n\n            case "dom":\n                // listens for dom event\n                watchingEvent = action.e\n                $(action.css)[0].addEventListener(watchingEvent, domEventHandler);\n                break;\n\n            case "spa":\n\n                // listens for statechange event\n                stateChangeWrappers(reset);\n\n                break;\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29udHJvbGxlci9Db250YWluZXJFdmVudHNDb250cm9sbGVyLmpzP2EwM2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTs7QUFFQSwwQkFBMEIsbUJBQU8sQ0FBQyxFQUE2QjtBQUMvRDtBQUNBLDhCQUE4QixtQkFBTyxDQUFDLEVBQWlDO0FBQ3ZFO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLENBQU87QUFDM0IsWUFBWSxtQkFBTyxDQUFDLENBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBldmlsOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUsIHBsdXNwbHVzOnRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRhZ01hbmFnZXIsIGFjdGlvbnMpIHtcblxuICAgIHZhciBWYXJpYWJsZVdhdGNoZXIgPSByZXF1aXJlKFwiLi4vdXRpbHMvVmFyaWFibGVXYXRjaGVyLmpzXCIpO1xuICAgIHZhciB2YXJpYWJsZVdhdGNoZXI7XG4gICAgdmFyIHN0YXRlQ2hhbmdlV3JhcHBlcnMgPSByZXF1aXJlKFwiLi4vdXRpbHMvU3RhdGVDaGFuZ2VXcmFwcGVycy5qc1wiKTtcbiAgICB2YXIgcmVzZXQgPSB0YWdNYW5hZ2VyLnJlc2V0O1xuICAgIHZhciAkID0gcmVxdWlyZShcInplcHRvXCIpO1xuICAgIHZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG4gICAgdmFyIHdhdGNoaW5nRXZlbnQ7XG4gICAgdmFyIGRvbUV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih3YXRjaGluZ0V2ZW50LCBkb21FdmVudEhhbmRsZXIpO1xuICAgICAgICByZXNldCgpO1xuICAgIH07XG5cbiAgICBfLmVhY2goYWN0aW9ucywgZnVuY3Rpb24oYWN0aW9uKSB7XG5cbiAgICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuXG4gICAgICAgICAgICBjYXNlIFwidmFyXCI6XG4gICAgICAgICAgICAgICAgVmFyaWFibGVXYXRjaGVyKGFjdGlvbi53aW5kb3dWYXIsIHJlc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImRvbVwiOlxuICAgICAgICAgICAgICAgIC8vIGxpc3RlbnMgZm9yIGRvbSBldmVudFxuICAgICAgICAgICAgICAgIHdhdGNoaW5nRXZlbnQgPSBhY3Rpb24uZVxuICAgICAgICAgICAgICAgICQoYWN0aW9uLmNzcylbMF0uYWRkRXZlbnRMaXN0ZW5lcih3YXRjaGluZ0V2ZW50LCBkb21FdmVudEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwic3BhXCI6XG5cbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5zIGZvciBzdGF0ZWNoYW5nZSBldmVudFxuICAgICAgICAgICAgICAgIHN0YXRlQ2hhbmdlV3JhcHBlcnMocmVzZXQpO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb250cm9sbGVyL0NvbnRhaW5lckV2ZW50c0NvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///13\n')},function(module,exports,__webpack_require__){eval("/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global require, module */\n\nmodule.exports = function (rpc, tagManager) {\n\tvar self = this;\n\tvar _ = __webpack_require__(0);\n\tvar queue = [];\n\tvar purgeDelay = 250;\n\tvar controllerIsRunning = false;\n\tvar getNotificationFromPlugIn = __webpack_require__(49);\n\n\t// sends off whatever is in the queue currently and then resets it back\n\t// to empty\n\tvar purgeNotifications = function () {\n\n\t\t\tif (queue.length > 0) {\n\n\t\t\t\t// send our notification, copying the array to send and then resetting the queue\n\t\t\t\trpc.sendNotification(queue);\n\t\t\t\tqueue = [];\n\t\t\t}\n\n\t\t\t// Turn off the controller because we might be done\n\t\t\tcontrollerIsRunning = false;\n\n\t\t};\n\n\t// Start our interval, notifications will pile in and this is setting the timer\n\t// to send them back up to the server.\n\tvar start = function () {\n\n\t\t\tsetTimeout(purgeNotifications, purgeDelay);\n\t\t\tcontrollerIsRunning = true;\n\t\t};\n\n\t// add our plugIn object to the queue for sending back a notification to the server\n\t// when it actually sends is dependent on the interval timing.\n\tself.addToQueue = function (plugIn) {\n\t\tvar notification;\n\n\t\t// if we have no container, we've got nothing to tie to and the send notification\n\t\t// will fail... so we'll just lose this notification :-( I decided to do this because\n\t\t// the CIE's are using a custom tag as the final tag and resetting the container from\n\t\t// within postBuild.  Now if that happens, once the postBuild fires the tag will be\n\t\t// added here to the queue, but the container will have been deleted during the run\n\t\t// of the postBuild.  When the notification controller tries to send the notification\n\t\t// it will look for a container.id to tie to, but if it's not there it'll throw\n\t\t// an error :/.\n\t\tif (!_.isUndefined(tagManager.container)) {\n\n\t\t\t// use our method for parsing the notification level from the plugIn and return\n\t\t\t// the correct information to queue\n\t\t\tnotification = getNotificationFromPlugIn(plugIn);\n\n\t\t\t// if it's not an empty object (which returns if broadcast=0, or something we don't\n\t\t\t// have a case for)\n\t\t\tif (_.size(notification) && plugIn.status === \"done\") {\n\n\t\t\t\t// put the notification in the queue\n\t\t\t\tqueue.push(notification);\n\n\t\t\t\t// Start the timer if necessary\n\t\t\t\tif (!controllerIsRunning) {\n\t\t\t\t\tstart();\n\t\t\t\t}\n\n\t\t\t\t// If tagManager has a debugUpdates object we know we are running a debug version of the client.\n\t\t\t\t// we will immediately push the updates to the queue for some other entity to process them. In\n\t\t\t\t// this case we built it for TagBuddy to consume.\n\t\t\t\tif(_.isObject(tagManager.debugUpdates) && _.isFunction(tagManager.debugUpdates.push)) {\n\t\t\t\t\ttagManager.debugUpdates.push(getNotificationFromPlugIn(plugIn, {onDone:2}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29udHJvbGxlci9Ob3RpZmljYXRpb25Db250cm9sbGVyLmpzPzI5OTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLENBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1CQUFPLENBQUMsRUFBb0M7O0FBRTdFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxTQUFTO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBldmlsOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUsIHBsdXNwbHVzOnRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChycGMsIHRhZ01hbmFnZXIpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXHR2YXIgcXVldWUgPSBbXTtcblx0dmFyIHB1cmdlRGVsYXkgPSAyNTA7XG5cdHZhciBjb250cm9sbGVySXNSdW5uaW5nID0gZmFsc2U7XG5cdHZhciBnZXROb3RpZmljYXRpb25Gcm9tUGx1Z0luID0gcmVxdWlyZShcIi4uL3V0aWxzL2dldE5vdGlmaWNhdGlvbkZyb21QbHVnSW5cIik7XG5cblx0Ly8gc2VuZHMgb2ZmIHdoYXRldmVyIGlzIGluIHRoZSBxdWV1ZSBjdXJyZW50bHkgYW5kIHRoZW4gcmVzZXRzIGl0IGJhY2tcblx0Ly8gdG8gZW1wdHlcblx0dmFyIHB1cmdlTm90aWZpY2F0aW9ucyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0aWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcblxuXHRcdFx0XHQvLyBzZW5kIG91ciBub3RpZmljYXRpb24sIGNvcHlpbmcgdGhlIGFycmF5IHRvIHNlbmQgYW5kIHRoZW4gcmVzZXR0aW5nIHRoZSBxdWV1ZVxuXHRcdFx0XHRycGMuc2VuZE5vdGlmaWNhdGlvbihxdWV1ZSk7XG5cdFx0XHRcdHF1ZXVlID0gW107XG5cdFx0XHR9XG5cblx0XHRcdC8vIFR1cm4gb2ZmIHRoZSBjb250cm9sbGVyIGJlY2F1c2Ugd2UgbWlnaHQgYmUgZG9uZVxuXHRcdFx0Y29udHJvbGxlcklzUnVubmluZyA9IGZhbHNlO1xuXG5cdFx0fTtcblxuXHQvLyBTdGFydCBvdXIgaW50ZXJ2YWwsIG5vdGlmaWNhdGlvbnMgd2lsbCBwaWxlIGluIGFuZCB0aGlzIGlzIHNldHRpbmcgdGhlIHRpbWVyXG5cdC8vIHRvIHNlbmQgdGhlbSBiYWNrIHVwIHRvIHRoZSBzZXJ2ZXIuXG5cdHZhciBzdGFydCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0c2V0VGltZW91dChwdXJnZU5vdGlmaWNhdGlvbnMsIHB1cmdlRGVsYXkpO1xuXHRcdFx0Y29udHJvbGxlcklzUnVubmluZyA9IHRydWU7XG5cdFx0fTtcblxuXHQvLyBhZGQgb3VyIHBsdWdJbiBvYmplY3QgdG8gdGhlIHF1ZXVlIGZvciBzZW5kaW5nIGJhY2sgYSBub3RpZmljYXRpb24gdG8gdGhlIHNlcnZlclxuXHQvLyB3aGVuIGl0IGFjdHVhbGx5IHNlbmRzIGlzIGRlcGVuZGVudCBvbiB0aGUgaW50ZXJ2YWwgdGltaW5nLlxuXHRzZWxmLmFkZFRvUXVldWUgPSBmdW5jdGlvbiAocGx1Z0luKSB7XG5cdFx0dmFyIG5vdGlmaWNhdGlvbjtcblxuXHRcdC8vIGlmIHdlIGhhdmUgbm8gY29udGFpbmVyLCB3ZSd2ZSBnb3Qgbm90aGluZyB0byB0aWUgdG8gYW5kIHRoZSBzZW5kIG5vdGlmaWNhdGlvblxuXHRcdC8vIHdpbGwgZmFpbC4uLiBzbyB3ZSdsbCBqdXN0IGxvc2UgdGhpcyBub3RpZmljYXRpb24gOi0oIEkgZGVjaWRlZCB0byBkbyB0aGlzIGJlY2F1c2Vcblx0XHQvLyB0aGUgQ0lFJ3MgYXJlIHVzaW5nIGEgY3VzdG9tIHRhZyBhcyB0aGUgZmluYWwgdGFnIGFuZCByZXNldHRpbmcgdGhlIGNvbnRhaW5lciBmcm9tXG5cdFx0Ly8gd2l0aGluIHBvc3RCdWlsZC4gIE5vdyBpZiB0aGF0IGhhcHBlbnMsIG9uY2UgdGhlIHBvc3RCdWlsZCBmaXJlcyB0aGUgdGFnIHdpbGwgYmVcblx0XHQvLyBhZGRlZCBoZXJlIHRvIHRoZSBxdWV1ZSwgYnV0IHRoZSBjb250YWluZXIgd2lsbCBoYXZlIGJlZW4gZGVsZXRlZCBkdXJpbmcgdGhlIHJ1blxuXHRcdC8vIG9mIHRoZSBwb3N0QnVpbGQuICBXaGVuIHRoZSBub3RpZmljYXRpb24gY29udHJvbGxlciB0cmllcyB0byBzZW5kIHRoZSBub3RpZmljYXRpb25cblx0XHQvLyBpdCB3aWxsIGxvb2sgZm9yIGEgY29udGFpbmVyLmlkIHRvIHRpZSB0bywgYnV0IGlmIGl0J3Mgbm90IHRoZXJlIGl0J2xsIHRocm93XG5cdFx0Ly8gYW4gZXJyb3IgOi8uXG5cdFx0aWYgKCFfLmlzVW5kZWZpbmVkKHRhZ01hbmFnZXIuY29udGFpbmVyKSkge1xuXG5cdFx0XHQvLyB1c2Ugb3VyIG1ldGhvZCBmb3IgcGFyc2luZyB0aGUgbm90aWZpY2F0aW9uIGxldmVsIGZyb20gdGhlIHBsdWdJbiBhbmQgcmV0dXJuXG5cdFx0XHQvLyB0aGUgY29ycmVjdCBpbmZvcm1hdGlvbiB0byBxdWV1ZVxuXHRcdFx0bm90aWZpY2F0aW9uID0gZ2V0Tm90aWZpY2F0aW9uRnJvbVBsdWdJbihwbHVnSW4pO1xuXG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhbiBlbXB0eSBvYmplY3QgKHdoaWNoIHJldHVybnMgaWYgYnJvYWRjYXN0PTAsIG9yIHNvbWV0aGluZyB3ZSBkb24ndFxuXHRcdFx0Ly8gaGF2ZSBhIGNhc2UgZm9yKVxuXHRcdFx0aWYgKF8uc2l6ZShub3RpZmljYXRpb24pICYmIHBsdWdJbi5zdGF0dXMgPT09IFwiZG9uZVwiKSB7XG5cblx0XHRcdFx0Ly8gcHV0IHRoZSBub3RpZmljYXRpb24gaW4gdGhlIHF1ZXVlXG5cdFx0XHRcdHF1ZXVlLnB1c2gobm90aWZpY2F0aW9uKTtcblxuXHRcdFx0XHQvLyBTdGFydCB0aGUgdGltZXIgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdGlmICghY29udHJvbGxlcklzUnVubmluZykge1xuXHRcdFx0XHRcdHN0YXJ0KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0YWdNYW5hZ2VyIGhhcyBhIGRlYnVnVXBkYXRlcyBvYmplY3Qgd2Uga25vdyB3ZSBhcmUgcnVubmluZyBhIGRlYnVnIHZlcnNpb24gb2YgdGhlIGNsaWVudC5cblx0XHRcdFx0Ly8gd2Ugd2lsbCBpbW1lZGlhdGVseSBwdXNoIHRoZSB1cGRhdGVzIHRvIHRoZSBxdWV1ZSBmb3Igc29tZSBvdGhlciBlbnRpdHkgdG8gcHJvY2VzcyB0aGVtLiBJblxuXHRcdFx0XHQvLyB0aGlzIGNhc2Ugd2UgYnVpbHQgaXQgZm9yIFRhZ0J1ZGR5IHRvIGNvbnN1bWUuXG5cdFx0XHRcdGlmKF8uaXNPYmplY3QodGFnTWFuYWdlci5kZWJ1Z1VwZGF0ZXMpICYmIF8uaXNGdW5jdGlvbih0YWdNYW5hZ2VyLmRlYnVnVXBkYXRlcy5wdXNoKSkge1xuXHRcdFx0XHRcdHRhZ01hbmFnZXIuZGVidWdVcGRhdGVzLnB1c2goZ2V0Tm90aWZpY2F0aW9uRnJvbVBsdWdJbihwbHVnSW4sIHtvbkRvbmU6Mn0pKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jb250cm9sbGVyL05vdGlmaWNhdGlvbkNvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n")},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, unparam: true, vars:true */\n/*global require, module, exports, conversant*/\n\n// This class is intended to be a controller and manage some of the commonality\n// between different types of tags that we place on the page.  It handles the\n// `location` property runs `Conditions` for the tags and creates the `Data` instance.\nmodule.exports = function (plugIn, appendToDIV, locale, srcRegistry, pendingTagCollection, unattachedEventsController) {\n\tvar self = this;\n\n\t// Libs\n\tvar _ = __webpack_require__(0);\n\tvar $ = __webpack_require__(1);\n\n\t//base\n\tvar Deferrable = __webpack_require__(2);\n\n\t// Elements\n\tvar BuildElement = __webpack_require__(3);\n\tvar DivElement = __webpack_require__(42);\n\tvar IframeElement = __webpack_require__(44);\n\tvar IsolatedElement = __webpack_require__(45);\n\tvar HasDocWriteElement = __webpack_require__(43);\n\tvar ScriptElement = __webpack_require__(46);\n\n\t// Utils\n\tvar FunctionRunner = __webpack_require__(6);\n\tvar runPostBuild = __webpack_require__(12);\n\n\t// data\n\tvar Conditions = __webpack_require__(32);\n\tvar Data = __webpack_require__(33);\n\tvar URI = __webpack_require__(39);\n\n\tvar doneText = \"done\";\n\tvar plugInAttrSrc = plugIn.attr.src;\n\tvar plugInAttrTag = plugIn.attr.tag;\n\tvar instructedToFastFire = plugIn.fastfire;\n\tvar buildSrcOnce = plugIn.attr.buildSrcOnce;\n\tvar location = plugIn.location;\n\tvar willFastFire;\n\tvar data;\n\tvar conditions;\n\tvar uri;\n\tvar tagElement;\n\tvar makeTag;\n\tvar giveMeMyLocation;\n\tvar fireTagMaybe;\n\tvar eventHandler;\n\tvar hasDataDef = false;\n\tvar hasData = false;\n\tvar makeData;\n\tvar makeURI;\n\tvar fireTag;\n\tvar queueTag;\n\n\t_.extend(self, Deferrable);\n\n\tself.init();\n\n\tplugIn.status = \"pending\";\n\n\t// returns the DIV to insert into based on location and the tag type, there are\n\t// different rules for each type of tag etc...\n\tgiveMeMyLocation = function () {\n\n\t\t// Declare our return object\n\t\tvar retr;\n\n\t\t// location is either an explicit div or our default location\n\t\t// if it's an img tag, we're returning undefined if it doesn't\n\t\t// have a specific location because we don't want to insert\n\t\t// a tracking image into the dom since we'll ping the server\n\t\t// just by building the doc fragment.\n\t\tif (_.isString(location)) {\n\t\t\tretr = $(location);\n\t\t} else if (plugInAttrTag !== \"img\" || plugIn.xdr || plugIn.hasDocWrite) {\n\t\t\tretr = appendToDIV;\n\t\t}\n\t\treturn retr;\n\t};\n\n\t// This is where we will create our tag variable of whatever type it is.  All of these\n\t// Classes inherit from the base class of `BuildElement`, but they all have slightly\n\t// different needs for building of their specific type of class.\n\tmakeTag = function () {\n\t\tvar element;\n\t\tvar buildProps = {\n\t\t\tplugIn: plugIn,\n\t\t\tappendToDIV: giveMeMyLocation(),\n\t\t\tdata: data\n\t\t};\n\n\t\tif (uri) {\n\t\t\tbuildProps.src = uri.getURI();\n\t\t}\n\t\t// if xdr flag is set to true, then that is a special case and we'll pass it along to\n\t\t// the IsolatedElement\n\t\tif (plugIn.xdr) {\n\t\t\telement = new IsolatedElement(buildProps, locale);\n\n\t\t\t// If it's not xdr then we'll need to switch through the tag type and figure out which\n\t\t\t// element to build.\n\t\t} else if (plugIn.hasDocWrite) {\n\t\t\telement = new HasDocWriteElement(buildProps);\n\t\t} else {\n\n\t\t\t// First before we build our tag DOM element we need to check for a preBuild to run\n\t\t\t// before the tag is created.\n\t\t\tif (plugIn.preBuild) {\n\t\t\t\tFunctionRunner(plugIn.preBuild, data);\n\t\t\t}\n\n\t\t\t// First check if either we have a buildSrcOnce directive and the src isn't build yet\n\t\t\t// OR if there is no directive to build the source once. If it is a buildSrcOnce type\n\t\t\t// of deal and we have already built it, then we aren't going to build it again and\n\t\t\t// we'll return undefined.\n\t\t\tif ((buildSrcOnce && !srcRegistry.exists(buildProps.src)) || !buildSrcOnce) {\n\n\n\t\t\t\t// Figure out which to build.\n\t\t\t\tswitch (plugInAttrTag) {\n\n\t\t\t\tcase \"iframe\":\n\n\t\t\t\t\t// iframe tags come in two distinct flavors:\n\t\t\t\t\t// 1. an iframe with a src attribute\n\t\t\t\t\t// 2. an iframe with an innerHTML (usually custom / copy and paste)\n\t\t\t\t\telement = new IframeElement(buildProps);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"div\":\n\n\t\t\t\t\t// Divs require a location, the plugIn and data.\n\t\t\t\t\telement = new DivElement(buildProps);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"script\":\n\n\t\t\t\t\t// Script element handles postBuild as well\n\t\t\t\t\telement = new ScriptElement(buildProps);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\n\t\t\t\t\telement = _.extend({}, BuildElement);\n\t\t\t\t\telement.init(buildProps);\n\t\t\t\t\telement.resolve(plugIn);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (buildSrcOnce && element) {\n\t\t\tsrcRegistry.push({\n\t\t\t\tsrc: buildProps.src,\n\t\t\t\tdeferred: element\n\t\t\t});\n\t\t}\n\n\t\tif (_.isObject(plugInAttrSrc)) {\n\t\t\tplugInAttrSrc.final = buildProps.src;\n\t\t}\n\t\treturn element;\n\t};\n\n\tmakeData = function () {\n\n\t\t// if Data already exists on the plugIn, then we will\n\t\t// create a new Data object and then use the setData\n\t\t// method to assign the data.  We are essentially reusing\n\t\t// resolved data in this case.\n\t\tif (hasData) {\n\n\t\t\tdata = new Data();\n\t\t\tdata.setData(plugIn.data);\n\n\t\t\t// if we have a dataDef we need to create a new Data object\n\t\t\t// and the dataDef will then give it instructions on how to\n\t\t\t// get the data we need\n\t\t} else if (hasDataDef) {\n\n\t\t\tdata = new Data();\n\n\t\t\tdata.setDataDef(plugIn.dataDef, conversant.tagManager.overrides);\n\n\t\t\t// Assign the resolved data back to the plugIn incase this\n\t\t\t// plugIn is run again, no need to re-resolve the data in\n\t\t\t// it.  Also used for tag sampling.\n\t\t\tplugIn.data = data.getAll();\n\t\t}\n\n\t};\n\n\tmakeURI = function () {\n\n\t\t// Figure out our source stuff.  `URI` may or may not be created, not all tags are\n\t\t// required to have a source they might just have an `innerHTML` in the case of\n\t\t// iframe tags that are copy pasted (custom tags).\n\t\turi = new URI(data);\n\t\turi.setURI(plugInAttrSrc);\n\t};\n\n\tfireTag = function () {\n\t\tvar deferred;\n\t\tvar postBuild = plugIn.postBuild;\n\t\ttagElement = makeTag();\n\t\tplugIn.status = doneText;\n\n\t\t// We may not have a tagElement if it's a buildSrcOnce\n\t\tif (tagElement) {\n\n\t\t\ttagElement.done(self.resolve);\n\t\t\ttagElement.fail(self.fail);\n\t\t} else {\n\n\t\t\t// if we have no tagElement that means we didn't build one because it was a second+\n\t\t\t// tag with a buildSrcOnce\n\t\t\tif (buildSrcOnce) {\n\n\t\t\t\t// tie into the deferred from the previous tag with this src so we can maintain\n\t\t\t\t// postBuild firing order\n\t\t\t\tdeferred = srcRegistry.getDeferred(plugInAttrSrc.final);\n\t\t\t\tdeferred.done(function () {\n\t\t\t\t\t\n\t\t\t\t\tif(postBuild) {\n\t\t\t\t\t\trunPostBuild(postBuild, data);\n\t\t\t\t\t}\n\t\t\t\t\tself.resolve(plugIn);\n\t\t\t\t});\n\t\t\t\tdeferred.fail(function () {\n\t\t\t\t\tself.reject(plugIn);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\tfireTagMaybe = function () {\n\n\t\t// Decide if we need to make data\n\t\tif (hasDataDef || hasData) {\n\t\t\tmakeData();\n\t\t}\n\n\t\t// if we have a src build it\n\t\tif (!_.isUndefined(plugInAttrSrc)) {\n\t\t\tmakeURI();\n\t\t}\n\n\t\t// If our firing is conditional we'll need to evaluate the conditions of the plugIn\n\t\t// before we fire the tag.  In some cases this won't be defined and we just fire\n\t\t// the tag unconditionally.\n\t\tif (plugIn.conditions) {\n\n\t\t\tconditions = new Conditions(data);\n\n\t\t\t// conditions will return either true or false\n\t\t\tif (conditions.run(plugIn.conditions, plugIn.conditionMap)) {\n\t\t\t\tfireTag();\n\t\t\t} else {\n\n\t\t\t\t// We did not pass conditions\n\t\t\t\tplugIn.status = \"fail\";\n\t\t\t\tself.reject(plugIn);\n\t\t\t}\n\t\t} else {\n\n\t\t\t// Unconditional tag, run it\n\t\t\tfireTag();\n\t\t}\n\t};\n\n\n\t// Create our responder to the event\n\teventHandler = function () {\n\t\t_.each(plugIn.events, function (event) {\n\n\t\t\t// Loop each matching DOM element\n\t\t\t_.each($(event.css), function (matchedElement) {\n\n\t\t\t\t// Remove listeners to the event\n\t\t\t\tmatchedElement.removeEventListener(event.e, eventHandler);\n\t\t\t});\n\t\t});\n\t\tpendingTagCollection.remove(plugIn.tagName);\n\t\tfireTagMaybe();\n\t};\n\n\tqueueTag = function () {\n\t\tvar item = {\n\n\t\t\t// this will be the key\n\t\t\tname: plugIn.tagName,\n\n\t\t\t// reuse the same eventHandler that we use when we listen\n\t\t\t// for the even since we want to remove listeners too,\n\t\t\t// which this method does...\n\t\t\tmethod: eventHandler,\n\t\t\tremoveEventListener: function () {\n\t\t\t\t_.each(plugIn.events, function (event) {\n\t\t\t\t\t// Loop each matching DOM element\n\t\t\t\t\t_.each($(event.css), function (matchedElement) {\n\n\t\t\t\t\t\t// Remove listeners to the event\n\t\t\t\t\t\tmatchedElement.removeEventListener(event.e, eventHandler);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tif (plugIn.tagClass) {\n\t\t\titem.tagClass = plugIn.tagClass;\n\t\t}\n\n\t\t// Check for event based firing. If the plugIn object has a list of events to\n\t\t// listen for we'll need to hook up to those events and wait to fire the tag.\n\t\t// If there are no events, then we just fire the tag.\n\t\t_.each(plugIn.events, function (event) {\n\n\t\t\tvar matchedElemements;\n\t\t\tvar unselectableHasError = false;\n\n\t\t\ttry {\n\t\t\t\tmatchedElemements = $(event.css);\n\t\t\t} catch (selectorError) {\n\t\t\t\tunselectableHasError = true;\n\t\t\t}\n\n\t\t\tif (!unselectableHasError) {\n\t\t\t\t// There is a possibility that the selecter may come up with no \n\t\t\t\t// elements to attach the events to.  We need to diverge our\n\t\t\t\t// logic based on it is able to attach to something or not.\n\t\t\t\tif (matchedElemements.length === 0) {\n\n\t\t\t\t\t// We have no elements on the page that match the css selctor.\n\t\t\t\t\t// One of two things is happening here... the element is either \n\t\t\t\t\t// not going to be there, or it's not there just yet.  In the\n\t\t\t\t\t// event that it's just not there yet, we'll add this to the \n\t\t\t\t\t// unattachedEventsCollection and that controller will wait \n\t\t\t\t\t// for any DOM changes to check and see if the selector exists\n\t\t\t\t\t// yet.  If it's never there, then it will remain in the \n\t\t\t\t\t// pendingTagsCollection as well.\n\t\t\t\t\tunattachedEventsController.add({\n\t\t\t\t\t\tevent: event,\n\t\t\t\t\t\teventHandler: eventHandler\n\t\t\t\t\t});\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// we have at least one element ot attach to.\n\t\t\t\t\t_.each(matchedElemements, function (matchedElement) {\n\n\t\t\t\t\t\t// Attach listener to the each event and tell it to fire\n\t\t\t\t\t\t// our event handler function which builds the tag\n\t\t\t\t\t\t// when that event happens.\n\t\t\t\t\t\tmatchedElement.addEventListener(event.e, eventHandler);\n\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Set status to pending, so we see that in the container\n\t\tplugIn.status = \"pending\";\n\n\t\t// add it to our queue so we know this tag is sitting there\n\t\t// waiting to be fired\n\t\tpendingTagCollection.add(item);\n\t};\n\n\t// Set flag for ease in determining if we can fast fire\n\thasDataDef = _.isArray(plugIn.dataDef);\n\thasData = _.isArray(plugIn.data);\n\n\t// Check for fastfire ability.  By default if it is an img and the dataDef\n\t// doesn't contain elements that depend on the DOM being there, then we\n\t// can fast fire as we have no need to insert into the DOM.\n\twillFastFire = !hasDataDef;\n\n\t// if we have no dataDef essentially, so far we will fastfire\n\tif (willFastFire) {\n\n\t\t// if it's an img tag and we are not explicitly told to not faastfire\n\t\t// we will.  If we're any other kind of tag, we have to be explicitly\n\t\t// told to fastfire or else we won't.\n\t\twillFastFire = (plugInAttrTag === \"img\") ? instructedToFastFire !== false : instructedToFastFire === true;\n\n\t\t// and make sure we have no events if we have\n\t\t// events we can't fast fire anyway;\n\t\twillFastFire = (willFastFire && _.isUndefined(plugIn.events) && plugIn.auto !== false);\n\n\t\t// Make sure it's not fast firing eithers\n\t\twillFastFire = (willFastFire && !plugIn.xdr);\n\t}\n\n\t// keep track of this on the plugIn\n\tplugIn.fastFired = willFastFire;\n\n\t// Check for fast fire\n\tif (willFastFire) {\n\n\t\t// if we have a src build it\n\t\tif (!_.isUndefined(plugInAttrSrc)) {\n\t\t\tmakeURI();\n\t\t}\n\t\tfireTag();\n\n\t} else {\n\n\t\t// if the tag is auto, and/or has a list of events we'll need to queue\n\t\t// it into the pendingTagCollection and not fire it immediately.\n\t\t// otherwise we can fire it (if conditions pass)\n\t\t$(document).ready(function () {\n\t\t\tif (plugIn.auto === false || _.isArray(plugIn.events)) {\n\t\t\t\tqueueTag();\n\t\t\t} else {\n\t\t\t\tfireTagMaybe();\n\t\t\t}\n\t\t});\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29udHJvbGxlci9UYWcuanM/YzkyOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLG1CQUFPLENBQUMsQ0FBWTtBQUM3QixTQUFTLG1CQUFPLENBQUMsQ0FBTzs7QUFFeEI7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxDQUFvQjs7QUFFOUM7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxDQUFxQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFtQjtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFzQjtBQUNuRCx1QkFBdUIsbUJBQU8sQ0FBQyxFQUF3QjtBQUN2RCwwQkFBMEIsbUJBQU8sQ0FBQyxFQUEyQjtBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFzQjs7QUFFbkQ7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxDQUF3QjtBQUN0RCxvQkFBb0IsbUJBQU8sQ0FBQyxFQUF1Qjs7QUFFbkQ7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFvQjtBQUM5QyxZQUFZLG1CQUFPLENBQUMsRUFBYztBQUNsQyxXQUFXLG1CQUFPLENBQUMsRUFBYTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIG5vbWVuOiB0cnVlLCByZWdleHA6IHRydWUsIHVucGFyYW06IHRydWUsIHZhcnM6dHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlLCBleHBvcnRzLCBjb252ZXJzYW50Ki9cblxuLy8gVGhpcyBjbGFzcyBpcyBpbnRlbmRlZCB0byBiZSBhIGNvbnRyb2xsZXIgYW5kIG1hbmFnZSBzb21lIG9mIHRoZSBjb21tb25hbGl0eVxuLy8gYmV0d2VlbiBkaWZmZXJlbnQgdHlwZXMgb2YgdGFncyB0aGF0IHdlIHBsYWNlIG9uIHRoZSBwYWdlLiAgSXQgaGFuZGxlcyB0aGVcbi8vIGBsb2NhdGlvbmAgcHJvcGVydHkgcnVucyBgQ29uZGl0aW9uc2AgZm9yIHRoZSB0YWdzIGFuZCBjcmVhdGVzIHRoZSBgRGF0YWAgaW5zdGFuY2UuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwbHVnSW4sIGFwcGVuZFRvRElWLCBsb2NhbGUsIHNyY1JlZ2lzdHJ5LCBwZW5kaW5nVGFnQ29sbGVjdGlvbiwgdW5hdHRhY2hlZEV2ZW50c0NvbnRyb2xsZXIpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdC8vIExpYnNcblx0dmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcblx0dmFyICQgPSByZXF1aXJlKFwiemVwdG9cIik7XG5cblx0Ly9iYXNlXG5cdHZhciBEZWZlcnJhYmxlID0gcmVxdWlyZShcIi4uL2Jhc2UvRGVmZXJyYWJsZVwiKTtcblxuXHQvLyBFbGVtZW50c1xuXHR2YXIgQnVpbGRFbGVtZW50ID0gcmVxdWlyZShcIi4uL2RvbS9CdWlsZEVsZW1lbnRcIik7XG5cdHZhciBEaXZFbGVtZW50ID0gcmVxdWlyZShcIi4uL2RvbS9EaXZFbGVtZW50XCIpO1xuXHR2YXIgSWZyYW1lRWxlbWVudCA9IHJlcXVpcmUoXCIuLi9kb20vSWZyYW1lRWxlbWVudFwiKTtcblx0dmFyIElzb2xhdGVkRWxlbWVudCA9IHJlcXVpcmUoXCIuLi9kb20vSXNvbGF0ZWRFbGVtZW50XCIpO1xuXHR2YXIgSGFzRG9jV3JpdGVFbGVtZW50ID0gcmVxdWlyZShcIi4uL2RvbS9IYXNEb2NXcml0ZUVsZW1lbnRcIik7XG5cdHZhciBTY3JpcHRFbGVtZW50ID0gcmVxdWlyZShcIi4uL2RvbS9TY3JpcHRFbGVtZW50XCIpO1xuXG5cdC8vIFV0aWxzXG5cdHZhciBGdW5jdGlvblJ1bm5lciA9IHJlcXVpcmUoXCIuLi9kYXRhL0Z1bmN0aW9uUnVubmVyXCIpO1xuXHR2YXIgcnVuUG9zdEJ1aWxkID0gcmVxdWlyZSgnLi4vdXRpbHMvcnVuUG9zdEJ1aWxkJyk7XG5cblx0Ly8gZGF0YVxuXHR2YXIgQ29uZGl0aW9ucyA9IHJlcXVpcmUoXCIuLi9kYXRhL0NvbmRpdGlvbnNcIik7XG5cdHZhciBEYXRhID0gcmVxdWlyZShcIi4uL2RhdGEvRGF0YVwiKTtcblx0dmFyIFVSSSA9IHJlcXVpcmUoXCIuLi9kYXRhL1VSSVwiKTtcblxuXHR2YXIgZG9uZVRleHQgPSBcImRvbmVcIjtcblx0dmFyIHBsdWdJbkF0dHJTcmMgPSBwbHVnSW4uYXR0ci5zcmM7XG5cdHZhciBwbHVnSW5BdHRyVGFnID0gcGx1Z0luLmF0dHIudGFnO1xuXHR2YXIgaW5zdHJ1Y3RlZFRvRmFzdEZpcmUgPSBwbHVnSW4uZmFzdGZpcmU7XG5cdHZhciBidWlsZFNyY09uY2UgPSBwbHVnSW4uYXR0ci5idWlsZFNyY09uY2U7XG5cdHZhciBsb2NhdGlvbiA9IHBsdWdJbi5sb2NhdGlvbjtcblx0dmFyIHdpbGxGYXN0RmlyZTtcblx0dmFyIGRhdGE7XG5cdHZhciBjb25kaXRpb25zO1xuXHR2YXIgdXJpO1xuXHR2YXIgdGFnRWxlbWVudDtcblx0dmFyIG1ha2VUYWc7XG5cdHZhciBnaXZlTWVNeUxvY2F0aW9uO1xuXHR2YXIgZmlyZVRhZ01heWJlO1xuXHR2YXIgZXZlbnRIYW5kbGVyO1xuXHR2YXIgaGFzRGF0YURlZiA9IGZhbHNlO1xuXHR2YXIgaGFzRGF0YSA9IGZhbHNlO1xuXHR2YXIgbWFrZURhdGE7XG5cdHZhciBtYWtlVVJJO1xuXHR2YXIgZmlyZVRhZztcblx0dmFyIHF1ZXVlVGFnO1xuXG5cdF8uZXh0ZW5kKHNlbGYsIERlZmVycmFibGUpO1xuXG5cdHNlbGYuaW5pdCgpO1xuXG5cdHBsdWdJbi5zdGF0dXMgPSBcInBlbmRpbmdcIjtcblxuXHQvLyByZXR1cm5zIHRoZSBESVYgdG8gaW5zZXJ0IGludG8gYmFzZWQgb24gbG9jYXRpb24gYW5kIHRoZSB0YWcgdHlwZSwgdGhlcmUgYXJlXG5cdC8vIGRpZmZlcmVudCBydWxlcyBmb3IgZWFjaCB0eXBlIG9mIHRhZyBldGMuLi5cblx0Z2l2ZU1lTXlMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIERlY2xhcmUgb3VyIHJldHVybiBvYmplY3Rcblx0XHR2YXIgcmV0cjtcblxuXHRcdC8vIGxvY2F0aW9uIGlzIGVpdGhlciBhbiBleHBsaWNpdCBkaXYgb3Igb3VyIGRlZmF1bHQgbG9jYXRpb25cblx0XHQvLyBpZiBpdCdzIGFuIGltZyB0YWcsIHdlJ3JlIHJldHVybmluZyB1bmRlZmluZWQgaWYgaXQgZG9lc24ndFxuXHRcdC8vIGhhdmUgYSBzcGVjaWZpYyBsb2NhdGlvbiBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gaW5zZXJ0XG5cdFx0Ly8gYSB0cmFja2luZyBpbWFnZSBpbnRvIHRoZSBkb20gc2luY2Ugd2UnbGwgcGluZyB0aGUgc2VydmVyXG5cdFx0Ly8ganVzdCBieSBidWlsZGluZyB0aGUgZG9jIGZyYWdtZW50LlxuXHRcdGlmIChfLmlzU3RyaW5nKGxvY2F0aW9uKSkge1xuXHRcdFx0cmV0ciA9ICQobG9jYXRpb24pO1xuXHRcdH0gZWxzZSBpZiAocGx1Z0luQXR0clRhZyAhPT0gXCJpbWdcIiB8fCBwbHVnSW4ueGRyIHx8IHBsdWdJbi5oYXNEb2NXcml0ZSkge1xuXHRcdFx0cmV0ciA9IGFwcGVuZFRvRElWO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0cjtcblx0fTtcblxuXHQvLyBUaGlzIGlzIHdoZXJlIHdlIHdpbGwgY3JlYXRlIG91ciB0YWcgdmFyaWFibGUgb2Ygd2hhdGV2ZXIgdHlwZSBpdCBpcy4gIEFsbCBvZiB0aGVzZVxuXHQvLyBDbGFzc2VzIGluaGVyaXQgZnJvbSB0aGUgYmFzZSBjbGFzcyBvZiBgQnVpbGRFbGVtZW50YCwgYnV0IHRoZXkgYWxsIGhhdmUgc2xpZ2h0bHlcblx0Ly8gZGlmZmVyZW50IG5lZWRzIGZvciBidWlsZGluZyBvZiB0aGVpciBzcGVjaWZpYyB0eXBlIG9mIGNsYXNzLlxuXHRtYWtlVGFnID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlbGVtZW50O1xuXHRcdHZhciBidWlsZFByb3BzID0ge1xuXHRcdFx0cGx1Z0luOiBwbHVnSW4sXG5cdFx0XHRhcHBlbmRUb0RJVjogZ2l2ZU1lTXlMb2NhdGlvbigpLFxuXHRcdFx0ZGF0YTogZGF0YVxuXHRcdH07XG5cblx0XHRpZiAodXJpKSB7XG5cdFx0XHRidWlsZFByb3BzLnNyYyA9IHVyaS5nZXRVUkkoKTtcblx0XHR9XG5cdFx0Ly8gaWYgeGRyIGZsYWcgaXMgc2V0IHRvIHRydWUsIHRoZW4gdGhhdCBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgd2UnbGwgcGFzcyBpdCBhbG9uZyB0b1xuXHRcdC8vIHRoZSBJc29sYXRlZEVsZW1lbnRcblx0XHRpZiAocGx1Z0luLnhkcikge1xuXHRcdFx0ZWxlbWVudCA9IG5ldyBJc29sYXRlZEVsZW1lbnQoYnVpbGRQcm9wcywgbG9jYWxlKTtcblxuXHRcdFx0Ly8gSWYgaXQncyBub3QgeGRyIHRoZW4gd2UnbGwgbmVlZCB0byBzd2l0Y2ggdGhyb3VnaCB0aGUgdGFnIHR5cGUgYW5kIGZpZ3VyZSBvdXQgd2hpY2hcblx0XHRcdC8vIGVsZW1lbnQgdG8gYnVpbGQuXG5cdFx0fSBlbHNlIGlmIChwbHVnSW4uaGFzRG9jV3JpdGUpIHtcblx0XHRcdGVsZW1lbnQgPSBuZXcgSGFzRG9jV3JpdGVFbGVtZW50KGJ1aWxkUHJvcHMpO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZpcnN0IGJlZm9yZSB3ZSBidWlsZCBvdXIgdGFnIERPTSBlbGVtZW50IHdlIG5lZWQgdG8gY2hlY2sgZm9yIGEgcHJlQnVpbGQgdG8gcnVuXG5cdFx0XHQvLyBiZWZvcmUgdGhlIHRhZyBpcyBjcmVhdGVkLlxuXHRcdFx0aWYgKHBsdWdJbi5wcmVCdWlsZCkge1xuXHRcdFx0XHRGdW5jdGlvblJ1bm5lcihwbHVnSW4ucHJlQnVpbGQsIGRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGaXJzdCBjaGVjayBpZiBlaXRoZXIgd2UgaGF2ZSBhIGJ1aWxkU3JjT25jZSBkaXJlY3RpdmUgYW5kIHRoZSBzcmMgaXNuJ3QgYnVpbGQgeWV0XG5cdFx0XHQvLyBPUiBpZiB0aGVyZSBpcyBubyBkaXJlY3RpdmUgdG8gYnVpbGQgdGhlIHNvdXJjZSBvbmNlLiBJZiBpdCBpcyBhIGJ1aWxkU3JjT25jZSB0eXBlXG5cdFx0XHQvLyBvZiBkZWFsIGFuZCB3ZSBoYXZlIGFscmVhZHkgYnVpbHQgaXQsIHRoZW4gd2UgYXJlbid0IGdvaW5nIHRvIGJ1aWxkIGl0IGFnYWluIGFuZFxuXHRcdFx0Ly8gd2UnbGwgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRcdGlmICgoYnVpbGRTcmNPbmNlICYmICFzcmNSZWdpc3RyeS5leGlzdHMoYnVpbGRQcm9wcy5zcmMpKSB8fCAhYnVpbGRTcmNPbmNlKSB7XG5cblxuXHRcdFx0XHQvLyBGaWd1cmUgb3V0IHdoaWNoIHRvIGJ1aWxkLlxuXHRcdFx0XHRzd2l0Y2ggKHBsdWdJbkF0dHJUYWcpIHtcblxuXHRcdFx0XHRjYXNlIFwiaWZyYW1lXCI6XG5cblx0XHRcdFx0XHQvLyBpZnJhbWUgdGFncyBjb21lIGluIHR3byBkaXN0aW5jdCBmbGF2b3JzOlxuXHRcdFx0XHRcdC8vIDEuIGFuIGlmcmFtZSB3aXRoIGEgc3JjIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdC8vIDIuIGFuIGlmcmFtZSB3aXRoIGFuIGlubmVySFRNTCAodXN1YWxseSBjdXN0b20gLyBjb3B5IGFuZCBwYXN0ZSlcblx0XHRcdFx0XHRlbGVtZW50ID0gbmV3IElmcmFtZUVsZW1lbnQoYnVpbGRQcm9wcyk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJkaXZcIjpcblxuXHRcdFx0XHRcdC8vIERpdnMgcmVxdWlyZSBhIGxvY2F0aW9uLCB0aGUgcGx1Z0luIGFuZCBkYXRhLlxuXHRcdFx0XHRcdGVsZW1lbnQgPSBuZXcgRGl2RWxlbWVudChidWlsZFByb3BzKTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwic2NyaXB0XCI6XG5cblx0XHRcdFx0XHQvLyBTY3JpcHQgZWxlbWVudCBoYW5kbGVzIHBvc3RCdWlsZCBhcyB3ZWxsXG5cdFx0XHRcdFx0ZWxlbWVudCA9IG5ldyBTY3JpcHRFbGVtZW50KGJ1aWxkUHJvcHMpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXG5cdFx0XHRcdFx0ZWxlbWVudCA9IF8uZXh0ZW5kKHt9LCBCdWlsZEVsZW1lbnQpO1xuXHRcdFx0XHRcdGVsZW1lbnQuaW5pdChidWlsZFByb3BzKTtcblx0XHRcdFx0XHRlbGVtZW50LnJlc29sdmUocGx1Z0luKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoYnVpbGRTcmNPbmNlICYmIGVsZW1lbnQpIHtcblx0XHRcdHNyY1JlZ2lzdHJ5LnB1c2goe1xuXHRcdFx0XHRzcmM6IGJ1aWxkUHJvcHMuc3JjLFxuXHRcdFx0XHRkZWZlcnJlZDogZWxlbWVudFxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKF8uaXNPYmplY3QocGx1Z0luQXR0clNyYykpIHtcblx0XHRcdHBsdWdJbkF0dHJTcmMuZmluYWwgPSBidWlsZFByb3BzLnNyYztcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdH07XG5cblx0bWFrZURhdGEgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHQvLyBpZiBEYXRhIGFscmVhZHkgZXhpc3RzIG9uIHRoZSBwbHVnSW4sIHRoZW4gd2Ugd2lsbFxuXHRcdC8vIGNyZWF0ZSBhIG5ldyBEYXRhIG9iamVjdCBhbmQgdGhlbiB1c2UgdGhlIHNldERhdGFcblx0XHQvLyBtZXRob2QgdG8gYXNzaWduIHRoZSBkYXRhLiAgV2UgYXJlIGVzc2VudGlhbGx5IHJldXNpbmdcblx0XHQvLyByZXNvbHZlZCBkYXRhIGluIHRoaXMgY2FzZS5cblx0XHRpZiAoaGFzRGF0YSkge1xuXG5cdFx0XHRkYXRhID0gbmV3IERhdGEoKTtcblx0XHRcdGRhdGEuc2V0RGF0YShwbHVnSW4uZGF0YSk7XG5cblx0XHRcdC8vIGlmIHdlIGhhdmUgYSBkYXRhRGVmIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IERhdGEgb2JqZWN0XG5cdFx0XHQvLyBhbmQgdGhlIGRhdGFEZWYgd2lsbCB0aGVuIGdpdmUgaXQgaW5zdHJ1Y3Rpb25zIG9uIGhvdyB0b1xuXHRcdFx0Ly8gZ2V0IHRoZSBkYXRhIHdlIG5lZWRcblx0XHR9IGVsc2UgaWYgKGhhc0RhdGFEZWYpIHtcblxuXHRcdFx0ZGF0YSA9IG5ldyBEYXRhKCk7XG5cblx0XHRcdGRhdGEuc2V0RGF0YURlZihwbHVnSW4uZGF0YURlZiwgY29udmVyc2FudC50YWdNYW5hZ2VyLm92ZXJyaWRlcyk7XG5cblx0XHRcdC8vIEFzc2lnbiB0aGUgcmVzb2x2ZWQgZGF0YSBiYWNrIHRvIHRoZSBwbHVnSW4gaW5jYXNlIHRoaXNcblx0XHRcdC8vIHBsdWdJbiBpcyBydW4gYWdhaW4sIG5vIG5lZWQgdG8gcmUtcmVzb2x2ZSB0aGUgZGF0YSBpblxuXHRcdFx0Ly8gaXQuICBBbHNvIHVzZWQgZm9yIHRhZyBzYW1wbGluZy5cblx0XHRcdHBsdWdJbi5kYXRhID0gZGF0YS5nZXRBbGwoKTtcblx0XHR9XG5cblx0fTtcblxuXHRtYWtlVVJJID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0Ly8gRmlndXJlIG91dCBvdXIgc291cmNlIHN0dWZmLiAgYFVSSWAgbWF5IG9yIG1heSBub3QgYmUgY3JlYXRlZCwgbm90IGFsbCB0YWdzIGFyZVxuXHRcdC8vIHJlcXVpcmVkIHRvIGhhdmUgYSBzb3VyY2UgdGhleSBtaWdodCBqdXN0IGhhdmUgYW4gYGlubmVySFRNTGAgaW4gdGhlIGNhc2Ugb2Zcblx0XHQvLyBpZnJhbWUgdGFncyB0aGF0IGFyZSBjb3B5IHBhc3RlZCAoY3VzdG9tIHRhZ3MpLlxuXHRcdHVyaSA9IG5ldyBVUkkoZGF0YSk7XG5cdFx0dXJpLnNldFVSSShwbHVnSW5BdHRyU3JjKTtcblx0fTtcblxuXHRmaXJlVGFnID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBkZWZlcnJlZDtcblx0XHR2YXIgcG9zdEJ1aWxkID0gcGx1Z0luLnBvc3RCdWlsZDtcblx0XHR0YWdFbGVtZW50ID0gbWFrZVRhZygpO1xuXHRcdHBsdWdJbi5zdGF0dXMgPSBkb25lVGV4dDtcblxuXHRcdC8vIFdlIG1heSBub3QgaGF2ZSBhIHRhZ0VsZW1lbnQgaWYgaXQncyBhIGJ1aWxkU3JjT25jZVxuXHRcdGlmICh0YWdFbGVtZW50KSB7XG5cblx0XHRcdHRhZ0VsZW1lbnQuZG9uZShzZWxmLnJlc29sdmUpO1xuXHRcdFx0dGFnRWxlbWVudC5mYWlsKHNlbGYuZmFpbCk7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gaWYgd2UgaGF2ZSBubyB0YWdFbGVtZW50IHRoYXQgbWVhbnMgd2UgZGlkbid0IGJ1aWxkIG9uZSBiZWNhdXNlIGl0IHdhcyBhIHNlY29uZCtcblx0XHRcdC8vIHRhZyB3aXRoIGEgYnVpbGRTcmNPbmNlXG5cdFx0XHRpZiAoYnVpbGRTcmNPbmNlKSB7XG5cblx0XHRcdFx0Ly8gdGllIGludG8gdGhlIGRlZmVycmVkIGZyb20gdGhlIHByZXZpb3VzIHRhZyB3aXRoIHRoaXMgc3JjIHNvIHdlIGNhbiBtYWludGFpblxuXHRcdFx0XHQvLyBwb3N0QnVpbGQgZmlyaW5nIG9yZGVyXG5cdFx0XHRcdGRlZmVycmVkID0gc3JjUmVnaXN0cnkuZ2V0RGVmZXJyZWQocGx1Z0luQXR0clNyYy5maW5hbCk7XG5cdFx0XHRcdGRlZmVycmVkLmRvbmUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGlmKHBvc3RCdWlsZCkge1xuXHRcdFx0XHRcdFx0cnVuUG9zdEJ1aWxkKHBvc3RCdWlsZCwgZGF0YSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYucmVzb2x2ZShwbHVnSW4pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0ZGVmZXJyZWQuZmFpbChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0c2VsZi5yZWplY3QocGx1Z0luKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGZpcmVUYWdNYXliZSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vIERlY2lkZSBpZiB3ZSBuZWVkIHRvIG1ha2UgZGF0YVxuXHRcdGlmIChoYXNEYXRhRGVmIHx8IGhhc0RhdGEpIHtcblx0XHRcdG1ha2VEYXRhKCk7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgd2UgaGF2ZSBhIHNyYyBidWlsZCBpdFxuXHRcdGlmICghXy5pc1VuZGVmaW5lZChwbHVnSW5BdHRyU3JjKSkge1xuXHRcdFx0bWFrZVVSSSgpO1xuXHRcdH1cblxuXHRcdC8vIElmIG91ciBmaXJpbmcgaXMgY29uZGl0aW9uYWwgd2UnbGwgbmVlZCB0byBldmFsdWF0ZSB0aGUgY29uZGl0aW9ucyBvZiB0aGUgcGx1Z0luXG5cdFx0Ly8gYmVmb3JlIHdlIGZpcmUgdGhlIHRhZy4gIEluIHNvbWUgY2FzZXMgdGhpcyB3b24ndCBiZSBkZWZpbmVkIGFuZCB3ZSBqdXN0IGZpcmVcblx0XHQvLyB0aGUgdGFnIHVuY29uZGl0aW9uYWxseS5cblx0XHRpZiAocGx1Z0luLmNvbmRpdGlvbnMpIHtcblxuXHRcdFx0Y29uZGl0aW9ucyA9IG5ldyBDb25kaXRpb25zKGRhdGEpO1xuXG5cdFx0XHQvLyBjb25kaXRpb25zIHdpbGwgcmV0dXJuIGVpdGhlciB0cnVlIG9yIGZhbHNlXG5cdFx0XHRpZiAoY29uZGl0aW9ucy5ydW4ocGx1Z0luLmNvbmRpdGlvbnMsIHBsdWdJbi5jb25kaXRpb25NYXApKSB7XG5cdFx0XHRcdGZpcmVUYWcoKTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gV2UgZGlkIG5vdCBwYXNzIGNvbmRpdGlvbnNcblx0XHRcdFx0cGx1Z0luLnN0YXR1cyA9IFwiZmFpbFwiO1xuXHRcdFx0XHRzZWxmLnJlamVjdChwbHVnSW4pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFVuY29uZGl0aW9uYWwgdGFnLCBydW4gaXRcblx0XHRcdGZpcmVUYWcoKTtcblx0XHR9XG5cdH07XG5cblxuXHQvLyBDcmVhdGUgb3VyIHJlc3BvbmRlciB0byB0aGUgZXZlbnRcblx0ZXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdF8uZWFjaChwbHVnSW4uZXZlbnRzLCBmdW5jdGlvbiAoZXZlbnQpIHtcblxuXHRcdFx0Ly8gTG9vcCBlYWNoIG1hdGNoaW5nIERPTSBlbGVtZW50XG5cdFx0XHRfLmVhY2goJChldmVudC5jc3MpLCBmdW5jdGlvbiAobWF0Y2hlZEVsZW1lbnQpIHtcblxuXHRcdFx0XHQvLyBSZW1vdmUgbGlzdGVuZXJzIHRvIHRoZSBldmVudFxuXHRcdFx0XHRtYXRjaGVkRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LmUsIGV2ZW50SGFuZGxlcik7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRwZW5kaW5nVGFnQ29sbGVjdGlvbi5yZW1vdmUocGx1Z0luLnRhZ05hbWUpO1xuXHRcdGZpcmVUYWdNYXliZSgpO1xuXHR9O1xuXG5cdHF1ZXVlVGFnID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpdGVtID0ge1xuXG5cdFx0XHQvLyB0aGlzIHdpbGwgYmUgdGhlIGtleVxuXHRcdFx0bmFtZTogcGx1Z0luLnRhZ05hbWUsXG5cblx0XHRcdC8vIHJldXNlIHRoZSBzYW1lIGV2ZW50SGFuZGxlciB0aGF0IHdlIHVzZSB3aGVuIHdlIGxpc3RlblxuXHRcdFx0Ly8gZm9yIHRoZSBldmVuIHNpbmNlIHdlIHdhbnQgdG8gcmVtb3ZlIGxpc3RlbmVycyB0b28sXG5cdFx0XHQvLyB3aGljaCB0aGlzIG1ldGhvZCBkb2VzLi4uXG5cdFx0XHRtZXRob2Q6IGV2ZW50SGFuZGxlcixcblx0XHRcdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Xy5lYWNoKHBsdWdJbi5ldmVudHMsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHRcdC8vIExvb3AgZWFjaCBtYXRjaGluZyBET00gZWxlbWVudFxuXHRcdFx0XHRcdF8uZWFjaCgkKGV2ZW50LmNzcyksIGZ1bmN0aW9uIChtYXRjaGVkRWxlbWVudCkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgbGlzdGVuZXJzIHRvIHRoZSBldmVudFxuXHRcdFx0XHRcdFx0bWF0Y2hlZEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudC5lLCBldmVudEhhbmRsZXIpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aWYgKHBsdWdJbi50YWdDbGFzcykge1xuXHRcdFx0aXRlbS50YWdDbGFzcyA9IHBsdWdJbi50YWdDbGFzcztcblx0XHR9XG5cblx0XHQvLyBDaGVjayBmb3IgZXZlbnQgYmFzZWQgZmlyaW5nLiBJZiB0aGUgcGx1Z0luIG9iamVjdCBoYXMgYSBsaXN0IG9mIGV2ZW50cyB0b1xuXHRcdC8vIGxpc3RlbiBmb3Igd2UnbGwgbmVlZCB0byBob29rIHVwIHRvIHRob3NlIGV2ZW50cyBhbmQgd2FpdCB0byBmaXJlIHRoZSB0YWcuXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG5vIGV2ZW50cywgdGhlbiB3ZSBqdXN0IGZpcmUgdGhlIHRhZy5cblx0XHRfLmVhY2gocGx1Z0luLmV2ZW50cywgZnVuY3Rpb24gKGV2ZW50KSB7XG5cblx0XHRcdHZhciBtYXRjaGVkRWxlbWVtZW50cztcblx0XHRcdHZhciB1bnNlbGVjdGFibGVIYXNFcnJvciA9IGZhbHNlO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRtYXRjaGVkRWxlbWVtZW50cyA9ICQoZXZlbnQuY3NzKTtcblx0XHRcdH0gY2F0Y2ggKHNlbGVjdG9yRXJyb3IpIHtcblx0XHRcdFx0dW5zZWxlY3RhYmxlSGFzRXJyb3IgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIXVuc2VsZWN0YWJsZUhhc0Vycm9yKSB7XG5cdFx0XHRcdC8vIFRoZXJlIGlzIGEgcG9zc2liaWxpdHkgdGhhdCB0aGUgc2VsZWN0ZXIgbWF5IGNvbWUgdXAgd2l0aCBubyBcblx0XHRcdFx0Ly8gZWxlbWVudHMgdG8gYXR0YWNoIHRoZSBldmVudHMgdG8uICBXZSBuZWVkIHRvIGRpdmVyZ2Ugb3VyXG5cdFx0XHRcdC8vIGxvZ2ljIGJhc2VkIG9uIGl0IGlzIGFibGUgdG8gYXR0YWNoIHRvIHNvbWV0aGluZyBvciBub3QuXG5cdFx0XHRcdGlmIChtYXRjaGVkRWxlbWVtZW50cy5sZW5ndGggPT09IDApIHtcblxuXHRcdFx0XHRcdC8vIFdlIGhhdmUgbm8gZWxlbWVudHMgb24gdGhlIHBhZ2UgdGhhdCBtYXRjaCB0aGUgY3NzIHNlbGN0b3IuXG5cdFx0XHRcdFx0Ly8gT25lIG9mIHR3byB0aGluZ3MgaXMgaGFwcGVuaW5nIGhlcmUuLi4gdGhlIGVsZW1lbnQgaXMgZWl0aGVyIFxuXHRcdFx0XHRcdC8vIG5vdCBnb2luZyB0byBiZSB0aGVyZSwgb3IgaXQncyBub3QgdGhlcmUganVzdCB5ZXQuICBJbiB0aGVcblx0XHRcdFx0XHQvLyBldmVudCB0aGF0IGl0J3MganVzdCBub3QgdGhlcmUgeWV0LCB3ZSdsbCBhZGQgdGhpcyB0byB0aGUgXG5cdFx0XHRcdFx0Ly8gdW5hdHRhY2hlZEV2ZW50c0NvbGxlY3Rpb24gYW5kIHRoYXQgY29udHJvbGxlciB3aWxsIHdhaXQgXG5cdFx0XHRcdFx0Ly8gZm9yIGFueSBET00gY2hhbmdlcyB0byBjaGVjayBhbmQgc2VlIGlmIHRoZSBzZWxlY3RvciBleGlzdHNcblx0XHRcdFx0XHQvLyB5ZXQuICBJZiBpdCdzIG5ldmVyIHRoZXJlLCB0aGVuIGl0IHdpbGwgcmVtYWluIGluIHRoZSBcblx0XHRcdFx0XHQvLyBwZW5kaW5nVGFnc0NvbGxlY3Rpb24gYXMgd2VsbC5cblx0XHRcdFx0XHR1bmF0dGFjaGVkRXZlbnRzQ29udHJvbGxlci5hZGQoe1xuXHRcdFx0XHRcdFx0ZXZlbnQ6IGV2ZW50LFxuXHRcdFx0XHRcdFx0ZXZlbnRIYW5kbGVyOiBldmVudEhhbmRsZXJcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhdCBsZWFzdCBvbmUgZWxlbWVudCBvdCBhdHRhY2ggdG8uXG5cdFx0XHRcdFx0Xy5lYWNoKG1hdGNoZWRFbGVtZW1lbnRzLCBmdW5jdGlvbiAobWF0Y2hlZEVsZW1lbnQpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQXR0YWNoIGxpc3RlbmVyIHRvIHRoZSBlYWNoIGV2ZW50IGFuZCB0ZWxsIGl0IHRvIGZpcmVcblx0XHRcdFx0XHRcdC8vIG91ciBldmVudCBoYW5kbGVyIGZ1bmN0aW9uIHdoaWNoIGJ1aWxkcyB0aGUgdGFnXG5cdFx0XHRcdFx0XHQvLyB3aGVuIHRoYXQgZXZlbnQgaGFwcGVucy5cblx0XHRcdFx0XHRcdG1hdGNoZWRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQuZSwgZXZlbnRIYW5kbGVyKTtcblxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBTZXQgc3RhdHVzIHRvIHBlbmRpbmcsIHNvIHdlIHNlZSB0aGF0IGluIHRoZSBjb250YWluZXJcblx0XHRwbHVnSW4uc3RhdHVzID0gXCJwZW5kaW5nXCI7XG5cblx0XHQvLyBhZGQgaXQgdG8gb3VyIHF1ZXVlIHNvIHdlIGtub3cgdGhpcyB0YWcgaXMgc2l0dGluZyB0aGVyZVxuXHRcdC8vIHdhaXRpbmcgdG8gYmUgZmlyZWRcblx0XHRwZW5kaW5nVGFnQ29sbGVjdGlvbi5hZGQoaXRlbSk7XG5cdH07XG5cblx0Ly8gU2V0IGZsYWcgZm9yIGVhc2UgaW4gZGV0ZXJtaW5pbmcgaWYgd2UgY2FuIGZhc3QgZmlyZVxuXHRoYXNEYXRhRGVmID0gXy5pc0FycmF5KHBsdWdJbi5kYXRhRGVmKTtcblx0aGFzRGF0YSA9IF8uaXNBcnJheShwbHVnSW4uZGF0YSk7XG5cblx0Ly8gQ2hlY2sgZm9yIGZhc3RmaXJlIGFiaWxpdHkuICBCeSBkZWZhdWx0IGlmIGl0IGlzIGFuIGltZyBhbmQgdGhlIGRhdGFEZWZcblx0Ly8gZG9lc24ndCBjb250YWluIGVsZW1lbnRzIHRoYXQgZGVwZW5kIG9uIHRoZSBET00gYmVpbmcgdGhlcmUsIHRoZW4gd2Vcblx0Ly8gY2FuIGZhc3QgZmlyZSBhcyB3ZSBoYXZlIG5vIG5lZWQgdG8gaW5zZXJ0IGludG8gdGhlIERPTS5cblx0d2lsbEZhc3RGaXJlID0gIWhhc0RhdGFEZWY7XG5cblx0Ly8gaWYgd2UgaGF2ZSBubyBkYXRhRGVmIGVzc2VudGlhbGx5LCBzbyBmYXIgd2Ugd2lsbCBmYXN0ZmlyZVxuXHRpZiAod2lsbEZhc3RGaXJlKSB7XG5cblx0XHQvLyBpZiBpdCdzIGFuIGltZyB0YWcgYW5kIHdlIGFyZSBub3QgZXhwbGljaXRseSB0b2xkIHRvIG5vdCBmYWFzdGZpcmVcblx0XHQvLyB3ZSB3aWxsLiAgSWYgd2UncmUgYW55IG90aGVyIGtpbmQgb2YgdGFnLCB3ZSBoYXZlIHRvIGJlIGV4cGxpY2l0bHlcblx0XHQvLyB0b2xkIHRvIGZhc3RmaXJlIG9yIGVsc2Ugd2Ugd29uJ3QuXG5cdFx0d2lsbEZhc3RGaXJlID0gKHBsdWdJbkF0dHJUYWcgPT09IFwiaW1nXCIpID8gaW5zdHJ1Y3RlZFRvRmFzdEZpcmUgIT09IGZhbHNlIDogaW5zdHJ1Y3RlZFRvRmFzdEZpcmUgPT09IHRydWU7XG5cblx0XHQvLyBhbmQgbWFrZSBzdXJlIHdlIGhhdmUgbm8gZXZlbnRzIGlmIHdlIGhhdmVcblx0XHQvLyBldmVudHMgd2UgY2FuJ3QgZmFzdCBmaXJlIGFueXdheTtcblx0XHR3aWxsRmFzdEZpcmUgPSAod2lsbEZhc3RGaXJlICYmIF8uaXNVbmRlZmluZWQocGx1Z0luLmV2ZW50cykgJiYgcGx1Z0luLmF1dG8gIT09IGZhbHNlKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBmYXN0IGZpcmluZyBlaXRoZXJzXG5cdFx0d2lsbEZhc3RGaXJlID0gKHdpbGxGYXN0RmlyZSAmJiAhcGx1Z0luLnhkcik7XG5cdH1cblxuXHQvLyBrZWVwIHRyYWNrIG9mIHRoaXMgb24gdGhlIHBsdWdJblxuXHRwbHVnSW4uZmFzdEZpcmVkID0gd2lsbEZhc3RGaXJlO1xuXG5cdC8vIENoZWNrIGZvciBmYXN0IGZpcmVcblx0aWYgKHdpbGxGYXN0RmlyZSkge1xuXG5cdFx0Ly8gaWYgd2UgaGF2ZSBhIHNyYyBidWlsZCBpdFxuXHRcdGlmICghXy5pc1VuZGVmaW5lZChwbHVnSW5BdHRyU3JjKSkge1xuXHRcdFx0bWFrZVVSSSgpO1xuXHRcdH1cblx0XHRmaXJlVGFnKCk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIGlmIHRoZSB0YWcgaXMgYXV0bywgYW5kL29yIGhhcyBhIGxpc3Qgb2YgZXZlbnRzIHdlJ2xsIG5lZWQgdG8gcXVldWVcblx0XHQvLyBpdCBpbnRvIHRoZSBwZW5kaW5nVGFnQ29sbGVjdGlvbiBhbmQgbm90IGZpcmUgaXQgaW1tZWRpYXRlbHkuXG5cdFx0Ly8gb3RoZXJ3aXNlIHdlIGNhbiBmaXJlIGl0IChpZiBjb25kaXRpb25zIHBhc3MpXG5cdFx0JChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKHBsdWdJbi5hdXRvID09PSBmYWxzZSB8fCBfLmlzQXJyYXkocGx1Z0luLmV2ZW50cykpIHtcblx0XHRcdFx0cXVldWVUYWcoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZpcmVUYWdNYXliZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvY29udHJvbGxlci9UYWcuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n")},function(module,exports,__webpack_require__){eval("module.exports = function () {\n\n\tvar LinkedList = __webpack_require__(34);\n\tvar self = this;\n\tvar linkedList = new LinkedList();\n\tvar _ = __webpack_require__(0);\n\tvar $ = __webpack_require__(1);\n\tvar currentlyChecking = false;\n\tvar moreCameIn = false;\n\tvar observeTarget = document.body;\n\tvar observeConfig = {\n\t\tattributes: true,\n\t\tchildList: true,\n\t\tcharacterData: true\n\t};\n\tvar checkInterval = 500;\n\tvar listCheck = function () {\n\t\t\tvar curNode = linkedList.head;\n\t\t\tvar prevNode = null;\n\t\t\tvar matchedElements;\n\t\t\tvar eventObj;\n\t\t\tvar eachMatchedElement = function (matchedElement) {\n\t\t\t\t\tmatchedElement.addEventListener(eventObj.e, curNode.data.eventHandler, false);\n\t\t\t\t};\n\t\t\tif (curNode !== null) {\n\t\t\t\t\n\t\t\t\tdo {\n\n\t\t\t\t\t// Grab the current node's data and event information to check if we now have that element\n\t\t\t\t\t// in the DOM.\n\t\t\t\t\teventObj = curNode.data.event;\n\t\t\t\t\tmatchedElements = $(eventObj.css);\n\n\t\t\t\t\t// Figure out if we have the css selector we couldn't find before (in another piece of code)\n\t\t\t\t\tif (matchedElements.length > 0) {\n\n\t\t\t\t\t\t// AFFIRMATIVE!!!\n\t\t\t\t\t\t// attach Event\n\t\t\t\t\t\t_.each(matchedElements, eachMatchedElement);\n\n\t\t\t\t\t\t// Now remove from our linked list\n\n\t\t\t\t\t\tif(curNode === linkedList.head) {\n\t\t\t\t\t\t\t// remove the head and make the next one the curNode.next;\n\t\t\t\t\t\t\tlinkedList.head = curNode.next;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// skip over prev node\n\t\t\t\t\t\t\tif(prevNode) {\n\t\t\t\t\t\t\t\tprevNode.next = curNode.next;\n\t\t\t\t\t\t\t} else if(linkedList.head) {\n\t\t\t\t\t\t\t\tlinkedList.head = curNode.next;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlinkedList.head.curNode.next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurNode = curNode.next;\n\t\t\t\t\t} else { \n\n\t\t\t\t\t\tprevNode = curNode;\n\t\t\t\t\t\tcurNode = curNode.next;\n\t\t\t\t\t}\n\n\t\t\t\t\t// reset for next loop\n\t\t\t\t\tmatchedElements = null;\n\t\t\t\t\teventObj = null;\n\t\t\t\t}\n\t\t\t\twhile (curNode !== null);\n\n\n\t\t\t\tif(!self.isEmpty()) {\n\t\t\t\t\tif (moreCameIn) {\n\t\t\t\t\t\tcurrentlyChecking = true;\n\t\t\t\t\t\tmoreCameIn = false;\n\t\t\t\t\t\tsetTimeout(listCheck, checkInterval);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentlyChecking = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmoreCameIn = false;\n\t\t\t\t\tcurrentlyChecking = false;\n\t\t\t\t\tmObserver.disconnect();\n\t\t\t\t}\n\n\t\t\t}\n\t\t};\n\n\tvar mObserver = new MutationObserver(function () {\n\t\t// do yo thang\n\t\tif (!currentlyChecking) {\n\t\t\tcurrentlyChecking = true;\n\t\t\tsetTimeout(listCheck, checkInterval);\n\t\t} else {\n\t\t\tmoreCameIn = true;\n\t\t}\n\t});\n\n\t// just a checker function to make sure we have the right kind of object.\n\t// this could be a potential point of failure if the object is malformed\n\t// a problem a strictly typed language does not have...\n\t// should have 'event' and 'eventHandler'\n\t// @return boolean \n\tvar isValidEventProps = function (eventProps) {\n\t\t\treturn (_.isObject(eventProps) && _.isObject(eventProps.event) && _.isFunction(eventProps.eventHandler));\n\t\t};\n\n\tself.add = function (eventProps) {\n\t\tif (isValidEventProps(eventProps)) {\n\t\t\tlinkedList.add(eventProps);\n\t\t} else {\n\t\t\tthrow new Error(\"Inavlid event props, keys: \" + eventProps.keys());\n\t\t}\n\t};\n\n\tself.initiate = function () {\n\t\tif (linkedList.head !== null) {\n\t\t\tsetTimeout(listCheck, checkInterval);\n\t\t\tmObserver.observe(observeTarget, observeConfig);\n\t\t}\n\t};\n\n\tself.clear = function () {\n\t\tlinkedList.empty();\n\t\tmObserver.disconnect();\n\t};\n\n\tself.isEmpty = function() {\n\t\treturn linkedList.head === null;\n\t};\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY29udHJvbGxlci9VbmF0dGFjaGVkRXZlbnRzQ29udHJvbGxlci5qcz81NjVjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBLGtCQUFrQixtQkFBTyxDQUFDLEVBQW9CO0FBQzlDO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsQ0FBWTtBQUM3QixTQUFTLG1CQUFPLENBQUMsQ0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE87O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgTGlua2VkTGlzdCA9IHJlcXVpcmUoXCIuLi9kYXRhL0xpbmtlZExpc3RcIik7XG5cdHZhciBzZWxmID0gdGhpcztcblx0dmFyIGxpbmtlZExpc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xuXHR2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXHR2YXIgJCA9IHJlcXVpcmUoXCJ6ZXB0b1wiKTtcblx0dmFyIGN1cnJlbnRseUNoZWNraW5nID0gZmFsc2U7XG5cdHZhciBtb3JlQ2FtZUluID0gZmFsc2U7XG5cdHZhciBvYnNlcnZlVGFyZ2V0ID0gZG9jdW1lbnQuYm9keTtcblx0dmFyIG9ic2VydmVDb25maWcgPSB7XG5cdFx0YXR0cmlidXRlczogdHJ1ZSxcblx0XHRjaGlsZExpc3Q6IHRydWUsXG5cdFx0Y2hhcmFjdGVyRGF0YTogdHJ1ZVxuXHR9O1xuXHR2YXIgY2hlY2tJbnRlcnZhbCA9IDUwMDtcblx0dmFyIGxpc3RDaGVjayA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjdXJOb2RlID0gbGlua2VkTGlzdC5oZWFkO1xuXHRcdFx0dmFyIHByZXZOb2RlID0gbnVsbDtcblx0XHRcdHZhciBtYXRjaGVkRWxlbWVudHM7XG5cdFx0XHR2YXIgZXZlbnRPYmo7XG5cdFx0XHR2YXIgZWFjaE1hdGNoZWRFbGVtZW50ID0gZnVuY3Rpb24gKG1hdGNoZWRFbGVtZW50KSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE9iai5lLCBjdXJOb2RlLmRhdGEuZXZlbnRIYW5kbGVyLCBmYWxzZSk7XG5cdFx0XHRcdH07XG5cdFx0XHRpZiAoY3VyTm9kZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcblx0XHRcdFx0ZG8ge1xuXG5cdFx0XHRcdFx0Ly8gR3JhYiB0aGUgY3VycmVudCBub2RlJ3MgZGF0YSBhbmQgZXZlbnQgaW5mb3JtYXRpb24gdG8gY2hlY2sgaWYgd2Ugbm93IGhhdmUgdGhhdCBlbGVtZW50XG5cdFx0XHRcdFx0Ly8gaW4gdGhlIERPTS5cblx0XHRcdFx0XHRldmVudE9iaiA9IGN1ck5vZGUuZGF0YS5ldmVudDtcblx0XHRcdFx0XHRtYXRjaGVkRWxlbWVudHMgPSAkKGV2ZW50T2JqLmNzcyk7XG5cblx0XHRcdFx0XHQvLyBGaWd1cmUgb3V0IGlmIHdlIGhhdmUgdGhlIGNzcyBzZWxlY3RvciB3ZSBjb3VsZG4ndCBmaW5kIGJlZm9yZSAoaW4gYW5vdGhlciBwaWVjZSBvZiBjb2RlKVxuXHRcdFx0XHRcdGlmIChtYXRjaGVkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuXG5cdFx0XHRcdFx0XHQvLyBBRkZJUk1BVElWRSEhIVxuXHRcdFx0XHRcdFx0Ly8gYXR0YWNoIEV2ZW50XG5cdFx0XHRcdFx0XHRfLmVhY2gobWF0Y2hlZEVsZW1lbnRzLCBlYWNoTWF0Y2hlZEVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0XHQvLyBOb3cgcmVtb3ZlIGZyb20gb3VyIGxpbmtlZCBsaXN0XG5cblx0XHRcdFx0XHRcdGlmKGN1ck5vZGUgPT09IGxpbmtlZExpc3QuaGVhZCkge1xuXHRcdFx0XHRcdFx0XHQvLyByZW1vdmUgdGhlIGhlYWQgYW5kIG1ha2UgdGhlIG5leHQgb25lIHRoZSBjdXJOb2RlLm5leHQ7XG5cdFx0XHRcdFx0XHRcdGxpbmtlZExpc3QuaGVhZCA9IGN1ck5vZGUubmV4dDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gc2tpcCBvdmVyIHByZXYgbm9kZVxuXHRcdFx0XHRcdFx0XHRpZihwcmV2Tm9kZSkge1xuXHRcdFx0XHRcdFx0XHRcdHByZXZOb2RlLm5leHQgPSBjdXJOb2RlLm5leHQ7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZihsaW5rZWRMaXN0LmhlYWQpIHtcblx0XHRcdFx0XHRcdFx0XHRsaW5rZWRMaXN0LmhlYWQgPSBjdXJOb2RlLm5leHQ7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0bGlua2VkTGlzdC5oZWFkLmN1ck5vZGUubmV4dDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y3VyTm9kZSA9IGN1ck5vZGUubmV4dDtcblx0XHRcdFx0XHR9IGVsc2UgeyBcblxuXHRcdFx0XHRcdFx0cHJldk5vZGUgPSBjdXJOb2RlO1xuXHRcdFx0XHRcdFx0Y3VyTm9kZSA9IGN1ck5vZGUubmV4dDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyByZXNldCBmb3IgbmV4dCBsb29wXG5cdFx0XHRcdFx0bWF0Y2hlZEVsZW1lbnRzID0gbnVsbDtcblx0XHRcdFx0XHRldmVudE9iaiA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKGN1ck5vZGUgIT09IG51bGwpO1xuXG5cblx0XHRcdFx0aWYoIXNlbGYuaXNFbXB0eSgpKSB7XG5cdFx0XHRcdFx0aWYgKG1vcmVDYW1lSW4pIHtcblx0XHRcdFx0XHRcdGN1cnJlbnRseUNoZWNraW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdG1vcmVDYW1lSW4gPSBmYWxzZTtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQobGlzdENoZWNrLCBjaGVja0ludGVydmFsKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3VycmVudGx5Q2hlY2tpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bW9yZUNhbWVJbiA9IGZhbHNlO1xuXHRcdFx0XHRcdGN1cnJlbnRseUNoZWNraW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0bU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0fTtcblxuXHR2YXIgbU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuXHRcdC8vIGRvIHlvIHRoYW5nXG5cdFx0aWYgKCFjdXJyZW50bHlDaGVja2luZykge1xuXHRcdFx0Y3VycmVudGx5Q2hlY2tpbmcgPSB0cnVlO1xuXHRcdFx0c2V0VGltZW91dChsaXN0Q2hlY2ssIGNoZWNrSW50ZXJ2YWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtb3JlQ2FtZUluID0gdHJ1ZTtcblx0XHR9XG5cdH0pO1xuXG5cdC8vIGp1c3QgYSBjaGVja2VyIGZ1bmN0aW9uIHRvIG1ha2Ugc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBraW5kIG9mIG9iamVjdC5cblx0Ly8gdGhpcyBjb3VsZCBiZSBhIHBvdGVudGlhbCBwb2ludCBvZiBmYWlsdXJlIGlmIHRoZSBvYmplY3QgaXMgbWFsZm9ybWVkXG5cdC8vIGEgcHJvYmxlbSBhIHN0cmljdGx5IHR5cGVkIGxhbmd1YWdlIGRvZXMgbm90IGhhdmUuLi5cblx0Ly8gc2hvdWxkIGhhdmUgJ2V2ZW50JyBhbmQgJ2V2ZW50SGFuZGxlcidcblx0Ly8gQHJldHVybiBib29sZWFuIFxuXHR2YXIgaXNWYWxpZEV2ZW50UHJvcHMgPSBmdW5jdGlvbiAoZXZlbnRQcm9wcykge1xuXHRcdFx0cmV0dXJuIChfLmlzT2JqZWN0KGV2ZW50UHJvcHMpICYmIF8uaXNPYmplY3QoZXZlbnRQcm9wcy5ldmVudCkgJiYgXy5pc0Z1bmN0aW9uKGV2ZW50UHJvcHMuZXZlbnRIYW5kbGVyKSk7XG5cdFx0fTtcblxuXHRzZWxmLmFkZCA9IGZ1bmN0aW9uIChldmVudFByb3BzKSB7XG5cdFx0aWYgKGlzVmFsaWRFdmVudFByb3BzKGV2ZW50UHJvcHMpKSB7XG5cdFx0XHRsaW5rZWRMaXN0LmFkZChldmVudFByb3BzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW5hdmxpZCBldmVudCBwcm9wcywga2V5czogXCIgKyBldmVudFByb3BzLmtleXMoKSk7XG5cdFx0fVxuXHR9O1xuXG5cdHNlbGYuaW5pdGlhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKGxpbmtlZExpc3QuaGVhZCAhPT0gbnVsbCkge1xuXHRcdFx0c2V0VGltZW91dChsaXN0Q2hlY2ssIGNoZWNrSW50ZXJ2YWwpO1xuXHRcdFx0bU9ic2VydmVyLm9ic2VydmUob2JzZXJ2ZVRhcmdldCwgb2JzZXJ2ZUNvbmZpZyk7XG5cdFx0fVxuXHR9O1xuXG5cdHNlbGYuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0bGlua2VkTGlzdC5lbXB0eSgpO1xuXHRcdG1PYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cdH07XG5cblx0c2VsZi5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGxpbmtlZExpc3QuaGVhZCA9PT0gbnVsbDtcblx0fTtcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2NvbnRyb2xsZXIvVW5hdHRhY2hlZEV2ZW50c0NvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n")},function(module,exports,__webpack_require__){eval('/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, vars: true */\n/*global require, module */\n\nmodule.exports = function (buildIntoObject) {\n\n\t\tvar self = this;\n\t\tvar _ = __webpack_require__(0);\n\t\tvar collection = {};\n\t\t// for tagClass\n\t\tvar classHash = {};\n\t\tvar pendingTags = {\n\t\t\tfire: function (tagName) {\n\t\t\t\tif (_.size(collection) && _.isObject(collection[tagName])) {\n\t\t\t\t\tcollection[tagName].method();\n\t\t\t\t}\n\t\t\t},\n\t\t\tfireClass: function (className) {\n\t\t\t\t_.each(classHash[className], function (tagName) {\n\t\t\t\t\tpendingTags.fire(tagName);\n\t\t\t\t});\n\t\t\t\tdelete classHash[className];\n\t\t\t},\n\t\t\tgetNames: function () {\n\t\t\t\treturn _.keys(collection);\n\t\t\t},\n\t\t\tgetClasses: function () {\n\t\t\t\treturn _.keys(classHash);\n\t\t\t}\n\t\t};\n\n\t\tbuildIntoObject.pendingTags = pendingTags;\n\n\t\tself.add = function (item) {\n\t\t\tvar tagClass;\n\t\t\tif (_.isString(item.name) && _.isFunction(item.method)) {\n\t\t\t\tcollection[item.name] = item;\n\t\t\t\tif (item.tagClass) {\n\t\t\t\t\ttagClass = item.tagClass;\n\t\t\t\t\tif (_.isString(tagClass)) {\n\t\t\t\t\t\ttagClass = [tagClass];\n\t\t\t\t\t}\n\t\t\t\t\t_.each(tagClass, function (tClassName) {\n\t\t\t\t\t\tif (!_.isArray(classHash[tClassName])) {\n\t\t\t\t\t\t\tclassHash[tClassName] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclassHash[tClassName].push(item.name);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error("Malformed pendingTag");\n\t\t\t}\n\t\t};\n\n\t\tself.remove = function (tagName) {\n\t\t\tif (_.isObject(collection[tagName])) {\n\t\t\t\tif(_.isFunction(collection[tagName].removeEventListener)) {\n\t\t\t\t\tcollection[tagName].removeEventListener();\n\t\t\t\t}\n\t\t\t\tdelete collection[tagName];\n\t\t\t}\n\t\t}\n\n\t\tself.clear = function () {\n\t\t\t_.each(collection, function (item) {\n\t\t\t\tif(_.isFunction(item.removeEventListener)) {\n\t\t\t\t\titem.removeEventListener();\n\t\t\t\t}\n\t\t\t});\n\t\t\tcollection = {};\n\t\t};\n\t\tself.getSize = function () {\n\t\t\treturn _.size(collection);\n\t\t};\n\t};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9QZW5kaW5nVGFnQ29sbGVjdGlvbi5qcz85NDkzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFVLG1CQUFPLENBQUMsQ0FBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBldmlsOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgdmFyczogdHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJ1aWxkSW50b09iamVjdCkge1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5cdFx0dmFyIGNvbGxlY3Rpb24gPSB7fTtcblx0XHQvLyBmb3IgdGFnQ2xhc3Ncblx0XHR2YXIgY2xhc3NIYXNoID0ge307XG5cdFx0dmFyIHBlbmRpbmdUYWdzID0ge1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24gKHRhZ05hbWUpIHtcblx0XHRcdFx0aWYgKF8uc2l6ZShjb2xsZWN0aW9uKSAmJiBfLmlzT2JqZWN0KGNvbGxlY3Rpb25bdGFnTmFtZV0pKSB7XG5cdFx0XHRcdFx0Y29sbGVjdGlvblt0YWdOYW1lXS5tZXRob2QoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZpcmVDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuXHRcdFx0XHRfLmVhY2goY2xhc3NIYXNoW2NsYXNzTmFtZV0sIGZ1bmN0aW9uICh0YWdOYW1lKSB7XG5cdFx0XHRcdFx0cGVuZGluZ1RhZ3MuZmlyZSh0YWdOYW1lKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGRlbGV0ZSBjbGFzc0hhc2hbY2xhc3NOYW1lXTtcblx0XHRcdH0sXG5cdFx0XHRnZXROYW1lczogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gXy5rZXlzKGNvbGxlY3Rpb24pO1xuXHRcdFx0fSxcblx0XHRcdGdldENsYXNzZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIF8ua2V5cyhjbGFzc0hhc2gpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRidWlsZEludG9PYmplY3QucGVuZGluZ1RhZ3MgPSBwZW5kaW5nVGFncztcblxuXHRcdHNlbGYuYWRkID0gZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciB0YWdDbGFzcztcblx0XHRcdGlmIChfLmlzU3RyaW5nKGl0ZW0ubmFtZSkgJiYgXy5pc0Z1bmN0aW9uKGl0ZW0ubWV0aG9kKSkge1xuXHRcdFx0XHRjb2xsZWN0aW9uW2l0ZW0ubmFtZV0gPSBpdGVtO1xuXHRcdFx0XHRpZiAoaXRlbS50YWdDbGFzcykge1xuXHRcdFx0XHRcdHRhZ0NsYXNzID0gaXRlbS50YWdDbGFzcztcblx0XHRcdFx0XHRpZiAoXy5pc1N0cmluZyh0YWdDbGFzcykpIHtcblx0XHRcdFx0XHRcdHRhZ0NsYXNzID0gW3RhZ0NsYXNzXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Xy5lYWNoKHRhZ0NsYXNzLCBmdW5jdGlvbiAodENsYXNzTmFtZSkge1xuXHRcdFx0XHRcdFx0aWYgKCFfLmlzQXJyYXkoY2xhc3NIYXNoW3RDbGFzc05hbWVdKSkge1xuXHRcdFx0XHRcdFx0XHRjbGFzc0hhc2hbdENsYXNzTmFtZV0gPSBbXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNsYXNzSGFzaFt0Q2xhc3NOYW1lXS5wdXNoKGl0ZW0ubmFtZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBwZW5kaW5nVGFnXCIpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRzZWxmLnJlbW92ZSA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG5cdFx0XHRpZiAoXy5pc09iamVjdChjb2xsZWN0aW9uW3RhZ05hbWVdKSkge1xuXHRcdFx0XHRpZihfLmlzRnVuY3Rpb24oY29sbGVjdGlvblt0YWdOYW1lXS5yZW1vdmVFdmVudExpc3RlbmVyKSkge1xuXHRcdFx0XHRcdGNvbGxlY3Rpb25bdGFnTmFtZV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSBjb2xsZWN0aW9uW3RhZ05hbWVdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlbGYuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRfLmVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdFx0aWYoXy5pc0Z1bmN0aW9uKGl0ZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcikpIHtcblx0XHRcdFx0XHRpdGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRjb2xsZWN0aW9uID0ge307XG5cdFx0fTtcblx0XHRzZWxmLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gXy5zaXplKGNvbGxlY3Rpb24pO1xuXHRcdH07XG5cdH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9kYXRhL1BlbmRpbmdUYWdDb2xsZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17\n')},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, evil:true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, require */\n\nmodule.exports = function() {\n  var self = this;\n  var _ = __webpack_require__(0);\n  var registry = {};\n\n\t// the src object is expected to be an object with two keys.  One key is src which is the string src\n\t// which will be used as the key to later retrieve the deferred.  The deferred is the other key that\n\t// will return and object.\n\t\n  self.push = function(srcObj) {\n    if (!self.exists(srcObj.src)) {\n      registry[srcObj.src] = srcObj.deferred;\n    }\n  };\n  self.exists = function(srcStr) {\n    return _.contains(_.keys(registry), srcStr);\n  };\n  self.getDeferred = function(srcStr) {\n\n    return registry[srcStr];\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9TcmNSZWdpc3RyeS5qcz9hODY4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxDQUFZO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgZXZpbDp0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUsIHBsdXNwbHVzOnRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG4gIHZhciByZWdpc3RyeSA9IHt9O1xuXG5cdC8vIHRoZSBzcmMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdCB3aXRoIHR3byBrZXlzLiAgT25lIGtleSBpcyBzcmMgd2hpY2ggaXMgdGhlIHN0cmluZyBzcmNcblx0Ly8gd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHRoZSBrZXkgdG8gbGF0ZXIgcmV0cmlldmUgdGhlIGRlZmVycmVkLiAgVGhlIGRlZmVycmVkIGlzIHRoZSBvdGhlciBrZXkgdGhhdFxuXHQvLyB3aWxsIHJldHVybiBhbmQgb2JqZWN0LlxuXHRcbiAgc2VsZi5wdXNoID0gZnVuY3Rpb24oc3JjT2JqKSB7XG4gICAgaWYgKCFzZWxmLmV4aXN0cyhzcmNPYmouc3JjKSkge1xuICAgICAgcmVnaXN0cnlbc3JjT2JqLnNyY10gPSBzcmNPYmouZGVmZXJyZWQ7XG4gICAgfVxuICB9O1xuICBzZWxmLmV4aXN0cyA9IGZ1bmN0aW9uKHNyY1N0cikge1xuICAgIHJldHVybiBfLmNvbnRhaW5zKF8ua2V5cyhyZWdpc3RyeSksIHNyY1N0cik7XG4gIH07XG4gIHNlbGYuZ2V0RGVmZXJyZWQgPSBmdW5jdGlvbihzcmNTdHIpIHtcblxuICAgIHJldHVybiByZWdpc3RyeVtzcmNTdHJdO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2RhdGEvU3JjUmVnaXN0cnkuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n")},function(module,exports,__webpack_require__){eval('/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, vars:true */\n/*global module, require */\n\nmodule.exports = function(locale, siteId) {\n  var self = this;\n\n  var _ = __webpack_require__(0);\n  var Deferrable = __webpack_require__(2);\n  var RPCGetContainer = __webpack_require__(40);\n  var RPCSendNotification = __webpack_require__(41);\n\n  var sparseRequest = {\n    params: {\n      version: window.conversant.tagManager.VERSION\n    },\n    jsonrpc: "2.0",\n    id: 0\n  };\n\n  // make this a subclass of Deferrable\n  _.extend(self, Deferrable);\n  self.init();\n\n  // Create public methods\n  self.getContainer = function(udo, overrides) {\n    var rpcGetContainer;\n    sparseRequest.id += 1;\n    rpcGetContainer = new RPCGetContainer(sparseRequest, locale, siteId, udo, overrides);\n    return rpcGetContainer;\n  };\n\n  self.sendNotification = function(plugIns) {\n    var rpcSendNotification;\n    sparseRequest.id += 1;\n    rpcSendNotification = new RPCSendNotification(sparseRequest, locale, plugIns);\n    return rpcSendNotification;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9ycGMvUlBDLmpzPzA0MjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsbUJBQU8sQ0FBQyxDQUFZO0FBQzlCLG1CQUFtQixtQkFBTyxDQUFDLENBQXVCO0FBQ2xELHdCQUF3QixtQkFBTyxDQUFDLEVBQXFCO0FBQ3JELDRCQUE0QixtQkFBTyxDQUFDLEVBQXlCOztBQUU3RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIGV2aWw6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIG5vbWVuOiB0cnVlLCB2YXJzOnRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxvY2FsZSwgc2l0ZUlkKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuICB2YXIgRGVmZXJyYWJsZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL0RlZmVycmFibGVcIik7XG4gIHZhciBSUENHZXRDb250YWluZXIgPSByZXF1aXJlKFwiUlBDUG9zdEdldENvbnRhaW5lclwiKTtcbiAgdmFyIFJQQ1NlbmROb3RpZmljYXRpb24gPSByZXF1aXJlKFwiUlBDUG9zdFNlbmROb3RpZmljYXRpb25cIik7XG5cbiAgdmFyIHNwYXJzZVJlcXVlc3QgPSB7XG4gICAgcGFyYW1zOiB7XG4gICAgICB2ZXJzaW9uOiB3aW5kb3cuY29udmVyc2FudC50YWdNYW5hZ2VyLlZFUlNJT05cbiAgICB9LFxuICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgaWQ6IDBcbiAgfTtcblxuICAvLyBtYWtlIHRoaXMgYSBzdWJjbGFzcyBvZiBEZWZlcnJhYmxlXG4gIF8uZXh0ZW5kKHNlbGYsIERlZmVycmFibGUpO1xuICBzZWxmLmluaXQoKTtcblxuICAvLyBDcmVhdGUgcHVibGljIG1ldGhvZHNcbiAgc2VsZi5nZXRDb250YWluZXIgPSBmdW5jdGlvbih1ZG8sIG92ZXJyaWRlcykge1xuICAgIHZhciBycGNHZXRDb250YWluZXI7XG4gICAgc3BhcnNlUmVxdWVzdC5pZCArPSAxO1xuICAgIHJwY0dldENvbnRhaW5lciA9IG5ldyBSUENHZXRDb250YWluZXIoc3BhcnNlUmVxdWVzdCwgbG9jYWxlLCBzaXRlSWQsIHVkbywgb3ZlcnJpZGVzKTtcbiAgICByZXR1cm4gcnBjR2V0Q29udGFpbmVyO1xuICB9O1xuXG4gIHNlbGYuc2VuZE5vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uKHBsdWdJbnMpIHtcbiAgICB2YXIgcnBjU2VuZE5vdGlmaWNhdGlvbjtcbiAgICBzcGFyc2VSZXF1ZXN0LmlkICs9IDE7XG4gICAgcnBjU2VuZE5vdGlmaWNhdGlvbiA9IG5ldyBSUENTZW5kTm90aWZpY2F0aW9uKHNwYXJzZVJlcXVlc3QsIGxvY2FsZSwgcGx1Z0lucyk7XG4gICAgcmV0dXJuIHJwY1NlbmROb3RpZmljYXRpb247XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZGF0YS9ycGMvUlBDLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n')},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global require, module, MutationObserver */\n\nmodule.exports = function() {\n  var self = this;\n\n  // Observe the body for changes\n  var observer = new MutationObserver(function() {\n    if (document.body) {\n      observer.disconnect();\n      self.resolve();\n    }\n  });\n\n  // this will create all the deferrable methods on this\n  // object for use\n  __webpack_require__(2).init.call(self);\n\n  // If we don't have the body already, we'll wait for it\n  if (!document.body) {\n    observer.observe(document.documentElement, {\n      childList: true\n    });\n  } else {\n    // otherwise we're ready\n    self.resolve();\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL0JvZHlBdmFpbGFibGUuanM/Mzc2MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLENBQW9COztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUsIHBsdXNwbHVzOnRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSwgTXV0YXRpb25PYnNlcnZlciAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gT2JzZXJ2ZSB0aGUgYm9keSBmb3IgY2hhbmdlc1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpIHtcbiAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgc2VsZi5yZXNvbHZlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyB0aGlzIHdpbGwgY3JlYXRlIGFsbCB0aGUgZGVmZXJyYWJsZSBtZXRob2RzIG9uIHRoaXNcbiAgLy8gb2JqZWN0IGZvciB1c2VcbiAgcmVxdWlyZShcIi4uL2Jhc2UvRGVmZXJyYWJsZVwiKS5pbml0LmNhbGwoc2VsZik7XG5cbiAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSB0aGUgYm9keSBhbHJlYWR5LCB3ZSdsbCB3YWl0IGZvciBpdFxuICBpZiAoIWRvY3VtZW50LmJvZHkpIHtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlIHdlJ3JlIHJlYWR5XG4gICAgc2VsZi5yZXNvbHZlKCk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9kb20vQm9keUF2YWlsYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n")},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true */\n/*global module, require */\n\n// This just simply creates a main div document fragment with the proper classname\n// and display settings.\nmodule.exports = function() {\n\tvar $ = __webpack_require__(1);\n  return $("<div />", {\n    "class": "conversantTagManager",\n    "style": "display: none;"\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL01haW5ESVYuanM/YWI3ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxDQUFPO0FBQ3hCO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsR0FBRztBQUNIIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgbm9tZW46IHRydWUsIHJlZ2V4cDogdHJ1ZSAqL1xuLypnbG9iYWwgbW9kdWxlLCByZXF1aXJlICovXG5cbi8vIFRoaXMganVzdCBzaW1wbHkgY3JlYXRlcyBhIG1haW4gZGl2IGRvY3VtZW50IGZyYWdtZW50IHdpdGggdGhlIHByb3BlciBjbGFzc25hbWVcbi8vIGFuZCBkaXNwbGF5IHNldHRpbmdzLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcblx0dmFyICQgPSByZXF1aXJlKFwiemVwdG9cIik7XG4gIHJldHVybiAkKFwiPGRpdiAvPlwiLCB7XG4gICAgXCJjbGFzc1wiOiBcImNvbnZlcnNhbnRUYWdNYW5hZ2VyXCIsXG4gICAgXCJzdHlsZVwiOiBcImRpc3BsYXk6IG5vbmU7XCJcbiAgfSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZG9tL01haW5ESVYuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n')},function(module,exports){eval("/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true */\n/*global module*/\n\nmodule.exports = function(reportIntoObject) {\n\n  // Create 'errors'\n  reportIntoObject.errors = reportIntoObject.errors || [];\n\n  // Create public reportError Method\n  this.reportError = function(errObj) {\n    reportIntoObject.errors.push(errObj);\n  };\n  this.clear = function() {\n    reportIntoObject.errors = [];\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZXJyb3IvRXJyb3JSZXBvcnRlci5qcz9iZTAyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgZXZpbDogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgbm9tZW46IHRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocmVwb3J0SW50b09iamVjdCkge1xuXG4gIC8vIENyZWF0ZSAnZXJyb3JzJ1xuICByZXBvcnRJbnRvT2JqZWN0LmVycm9ycyA9IHJlcG9ydEludG9PYmplY3QuZXJyb3JzIHx8IFtdO1xuXG4gIC8vIENyZWF0ZSBwdWJsaWMgcmVwb3J0RXJyb3IgTWV0aG9kXG4gIHRoaXMucmVwb3J0RXJyb3IgPSBmdW5jdGlvbihlcnJPYmopIHtcbiAgICByZXBvcnRJbnRvT2JqZWN0LmVycm9ycy5wdXNoKGVyck9iaik7XG4gIH07XG4gIHRoaXMuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXBvcnRJbnRvT2JqZWN0LmVycm9ycyA9IFtdO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Vycm9yL0Vycm9yUmVwb3J0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22\n")},function(module,exports){eval('module.exports = {\n\tcdn: "//cdn-dev.mplxtms.com/",\n\tcontainer: "//t-dev.mplxtms.com/tags",\n\tnotification: "//t-dev.mplxtms.com/tags"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvbG9jYWxlL2Rldi5qcz85Njg4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcblx0Y2RuOiBcIi8vY2RuLWRldi5tcGx4dG1zLmNvbS9cIixcblx0Y29udGFpbmVyOiBcIi8vdC1kZXYubXBseHRtcy5jb20vdGFnc1wiLFxuXHRub3RpZmljYXRpb246IFwiLy90LWRldi5tcGx4dG1zLmNvbS90YWdzXCJcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9sb2NhbGUvZGV2LmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n')},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, require, conversant */\n\nmodule.exports = function () {\n\n\tvar _ = __webpack_require__(0);\n\n\tif (!window.Pulse) {\n\n\t\twindow.Pulse = {\n\n\t\t\trunWidget: function () {\n\n\t\t\t\tconversant.tagManager.reset();\n\n\t\t\t\t// This is always called as an assignment to Window.Pulse.Master\n\t\t\t\t// So we need to make sure notify still exists...\n\t\t\t\treturn this.Master;\n\t\t\t},\n\t\t\tMaster: {\n\n\t\t\t\tnotify: function (action, param) {\n\n\t\t\t\t\tif (action === "run" && _.isString(param)) {\n\n\t\t\t\t\t\tconversant.tagManager.pendingTags.fire(param);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t};\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvcHVsc2VhZGFwdGVyL1B1bHNlQWRhcHRlci5qcz9jYzIzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLENBQVk7O0FBRTdCOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUsIHBsdXNwbHVzOnRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgY29udmVyc2FudCAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXG5cdGlmICghd2luZG93LlB1bHNlKSB7XG5cblx0XHR3aW5kb3cuUHVsc2UgPSB7XG5cblx0XHRcdHJ1bldpZGdldDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGNvbnZlcnNhbnQudGFnTWFuYWdlci5yZXNldCgpO1xuXG5cdFx0XHRcdC8vIFRoaXMgaXMgYWx3YXlzIGNhbGxlZCBhcyBhbiBhc3NpZ25tZW50IHRvIFdpbmRvdy5QdWxzZS5NYXN0ZXJcblx0XHRcdFx0Ly8gU28gd2UgbmVlZCB0byBtYWtlIHN1cmUgbm90aWZ5IHN0aWxsIGV4aXN0cy4uLlxuXHRcdFx0XHRyZXR1cm4gdGhpcy5NYXN0ZXI7XG5cdFx0XHR9LFxuXHRcdFx0TWFzdGVyOiB7XG5cblx0XHRcdFx0bm90aWZ5OiBmdW5jdGlvbiAoYWN0aW9uLCBwYXJhbSkge1xuXG5cdFx0XHRcdFx0aWYgKGFjdGlvbiA9PT0gXCJydW5cIiAmJiBfLmlzU3RyaW5nKHBhcmFtKSkge1xuXG5cdFx0XHRcdFx0XHRjb252ZXJzYW50LnRhZ01hbmFnZXIucGVuZGluZ1RhZ3MuZmlyZShwYXJhbSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvcHVsc2VhZGFwdGVyL1B1bHNlQWRhcHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///24\n')},function(module,exports,__webpack_require__){eval('/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true */\n/*global require, module */\n\nmodule.exports = function () {\n\n\tvar _ = __webpack_require__(0);\n\n\t_.mixin({\n\t\tisTrue: function (e) {\n\t\t\treturn (e === "1" || e === true || e === "true");\n\t\t}\n\t});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdW5kZXJzY29yZV9taXhpbnMvaXNUcnVlLmpzPzY4ODMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTs7QUFFQSxTQUFTLG1CQUFPLENBQUMsQ0FBWTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YiLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBldmlsOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXG5cdF8ubWl4aW4oe1xuXHRcdGlzVHJ1ZTogZnVuY3Rpb24gKGUpIHtcblx0XHRcdHJldHVybiAoZSA9PT0gXCIxXCIgfHwgZSA9PT0gdHJ1ZSB8fCBlID09PSBcInRydWVcIik7XG5cdFx0fVxuXHR9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi91bmRlcnNjb3JlX21peGlucy9pc1RydWUuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n')},function(module,exports,__webpack_require__){eval('/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true */\n/*global require, module */\n\nmodule.exports = function () {\n\n\tvar _ = __webpack_require__(0);\n\n\t_.mixin({\n\t\ttoQueryString: function (nvpMultiArray, settings) {\n\t\t\tsettings = settings || {};\n\t\t\treturn _.chain(nvpMultiArray).filter(_.isSet).map(function (item) {\n\t\t\t\treturn item.join(settings.equivilator || "=");\n\t\t\t}).value().join(settings.delimiter || "&");\n\t\t}\n\t});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdW5kZXJzY29yZV9taXhpbnMvdG9RdWVyeVN0cmluZy5qcz9lNjJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLENBQVk7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0YiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBldmlsOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXG5cdF8ubWl4aW4oe1xuXHRcdHRvUXVlcnlTdHJpbmc6IGZ1bmN0aW9uIChudnBNdWx0aUFycmF5LCBzZXR0aW5ncykge1xuXHRcdFx0c2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcblx0XHRcdHJldHVybiBfLmNoYWluKG52cE11bHRpQXJyYXkpLmZpbHRlcihfLmlzU2V0KS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdFx0cmV0dXJuIGl0ZW0uam9pbihzZXR0aW5ncy5lcXVpdmlsYXRvciB8fCBcIj1cIik7XG5cdFx0XHR9KS52YWx1ZSgpLmpvaW4oc2V0dGluZ3MuZGVsaW1pdGVyIHx8IFwiJlwiKTtcblx0XHR9XG5cdH0pO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3VuZGVyc2NvcmVfbWl4aW5zL3RvUXVlcnlTdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n')},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, unparam: true, vars:true, plusplus:true */\n/*global require, module */\n\nmodule.exports = function () {\n\n\t\tvar _ = __webpack_require__(0);\n\t\t// Select the src of our own script and split on the hash\n\t\tvar src = __webpack_require__(50)();\n\n\t\tsrc = (src.indexOf("#") !== -1) ? src.split("#") : "";\n\n\t\t// if there was a hash then we return it\n\t\treturn _.isString(src[1]) ? src[1] : "";\n\t};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbHMvZ2V0U2l0ZUlkLmpzPzVhOGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLG1CQUFPLENBQUMsQ0FBWTtBQUM5QjtBQUNBLFlBQVksbUJBQU8sQ0FBQyxFQUFhOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB1bnBhcmFtOiB0cnVlLCB2YXJzOnRydWUsIHBsdXNwbHVzOnRydWUgKi9cbi8qZ2xvYmFsIHJlcXVpcmUsIG1vZHVsZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdHZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5cdFx0Ly8gU2VsZWN0IHRoZSBzcmMgb2Ygb3VyIG93biBzY3JpcHQgYW5kIHNwbGl0IG9uIHRoZSBoYXNoXG5cdFx0dmFyIHNyYyA9IHJlcXVpcmUoXCIuL2dldE91clNyY1wiKSgpO1xuXG5cdFx0c3JjID0gKHNyYy5pbmRleE9mKFwiI1wiKSAhPT0gLTEpID8gc3JjLnNwbGl0KFwiI1wiKSA6IFwiXCI7XG5cblx0XHQvLyBpZiB0aGVyZSB3YXMgYSBoYXNoIHRoZW4gd2UgcmV0dXJuIGl0XG5cdFx0cmV0dXJuIF8uaXNTdHJpbmcoc3JjWzFdKSA/IHNyY1sxXSA6IFwiXCI7XG5cdH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi91dGlscy9nZXRTaXRlSWQuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n')},function(module,exports){eval('/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, require */\n\nmodule.exports = function (locale) {\n\treturn {\n\t\tattr: {\n\t\t\tsrc: {\n\t\t\t\torigin: locale.cdn.slice(0, locale.cdn.length - 1),\n\t\t\t\tpathname: "client/TagBuddy2.min.js"\n\t\t\t},\n\t\t\ttag: "script"\n\t\t},\n\t\tbroadcast: {\n\t\t\tonDone: 0,\n\t\t\tonFail: 0\n\t\t},\n\t\tlocation: true,\n\t\ttagId: 0,\n\t\ttagName: "TagBuddy"\n\t};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbHMvdGFnQnVkZHlQbHVnSW4uanM/YWU3NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIGV2aWw6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIG5vbWVuOiB0cnVlLCByZWdleHA6IHRydWUsIHZhcnM6dHJ1ZSwgcGx1c3BsdXM6dHJ1ZSAqL1xuLypnbG9iYWwgbW9kdWxlLCByZXF1aXJlICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxvY2FsZSkge1xuXHRyZXR1cm4ge1xuXHRcdGF0dHI6IHtcblx0XHRcdHNyYzoge1xuXHRcdFx0XHRvcmlnaW46IGxvY2FsZS5jZG4uc2xpY2UoMCwgbG9jYWxlLmNkbi5sZW5ndGggLSAxKSxcblx0XHRcdFx0cGF0aG5hbWU6IFwiY2xpZW50L1RhZ0J1ZGR5Mi5taW4uanNcIlxuXHRcdFx0fSxcblx0XHRcdHRhZzogXCJzY3JpcHRcIlxuXHRcdH0sXG5cdFx0YnJvYWRjYXN0OiB7XG5cdFx0XHRvbkRvbmU6IDAsXG5cdFx0XHRvbkZhaWw6IDBcblx0XHR9LFxuXHRcdGxvY2F0aW9uOiB0cnVlLFxuXHRcdHRhZ0lkOiAwLFxuXHRcdHRhZ05hbWU6IFwiVGFnQnVkZHlcIlxuXHR9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3V0aWxzL3RhZ0J1ZGR5UGx1Z0luLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///28\n')},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global require, MutationObserver */\n\n// Version number that can be accessed via window.conversant.tagManager.VERSION\nvar VERSION = \"4.3.1-4\";\n\n// alias the window for minify\nvar w = window;\n// alias document for minify\nvar d = document;\nvar cnvr;\n\n// value injected by grunt will be an object with properties like tagServerURI etc...\n// this is aliased, so if the build config doesn't work I don't want it to be undefined.\nvar locale = __webpack_require__(23);\n\n// We know for sure that MutationObserver is implemented from ie11 and up. We are as of 5/01/2017 allowing\n// the green version of this client to run in ie11 and up since Microsoft has cleaned up their act a bit.\n// I'm going to feature detect, since we rely on this functionality for tag firing and queing.  If the\n// MutationObserver doesn't exist, we're going to load the old version of the client so that we get hopefully\n// some tag firing, knowing full well we aren't writing new features into that client anymore.  At the time\n// of this code writing it's less than 1.5% of our entire market.\nif (w.MutationObserver === undefined) {\n\n    // I'm going to wrap this into a self exeucting function (IIFE) to keep variables withing a closure.\n    (function() {\n\n        var site;\n        var src;\n        var MasterTMSEle;\n        var parent;\n        var loadOld;\n        var scripts = d.getElementsByTagName('script');\n        var grabSiteRegex = new RegExp(\"#[0-9]+\");\n        var i = 0;\n\n        // got to do everything the hard way because we are in IE\n        // and zepto is non-IE compatible \n        for (i; i < scripts.length; i++) {\n\n            // If we find out script tag\n            if (scripts[i].src.indexOf('MasterTMS') > -1) {\n                MasterTMSEle = scripts[i];\n                site = MasterTMSEle.src.match(grabSiteRegex)[0];\n\n                // we've now built our equivalent version of the 'legacy' client\n                src = locale.cdn + '/s/MasterTMS-legacy.min.js' + site;\n                break;\n            }\n        }\n\n        // create a place for the legacy script\n        loadOld = d.createElement('script');\n        loadOld.type = MasterTMSEle.type;\n        loadOld.src = src;\n\n        // Remove our script tag and put the 'legacy' version on\n        parent = MasterTMSEle.parentElement;\n        parent.removeChild(MasterTMSEle);\n        parent.appendChild(loadOld);\n\n    }());\n\n} else {\n\n    try {\n\n        // lib\n        var _ = __webpack_require__(0);\n        var $ = __webpack_require__(1);\n\n        // controller\n        var Tag = __webpack_require__(15);\n        var NotificationController = __webpack_require__(14);\n        var UnattachedEventsController = __webpack_require__(16);\n        var ContainerEventsController = __webpack_require__(13);\n\n        // data\n        var PendingTagCollection = __webpack_require__(17);\n        var SrcRegistry = __webpack_require__(18);\n        var RPC = __webpack_require__(19);\n\n        // utils\n        var getSiteId = __webpack_require__(27);\n\n        // Our specific product within the conversant company and object.\n        var tagManager = {};\n\n        // Error Reporter Class\n        var errorReporter;\n\n        // Pending Tag Collection creates something on the conversant.tagManager.pendingTags\n        var pendingTagCollection;\n\n        // Unattched events are event-based tags that are created but have no\n        // css selector to attach to.  In theory, the css selector could come \n        // in later so we'll create this controller to manage that.\n        var unattachedEventsController = new UnattachedEventsController();\n\n        // our instace of RPC class\n        var rpc;\n\n        // Our controller class for our Notification of the container\n        var notificationController;\n\n        // Create a global registry of srcs built, for buildSrcOnce parameter on tags\n        var srcRegistry;\n\n        // container actionsc controller var stub\n        var containerEventsController;\n\n        // our functions for our API functions\n        var initFunction;\n        var clearFunction;\n        var resetFunction;\n\n        // siteId grabbed from the URL of this scrip tag\n        var siteId;\n\n        // we're looking for a global object named 'conversant' if it doesn't\n        // exist we will create it and put our tagManager object under it.\n        w.conversant = w.conversant || {};\n\n        // if we have no tagManager Object then we'll just create it.\n        if (!w.conversant.tagManager) {\n\n            // link up tagManager object\n            w.conversant.tagManager = tagManager;\n\n            // if someone is trying to pass info and has already created a\n            // tagManager object then we need to be more careful with what\n            // is there.\n        } else {\n\n            // make our local tagManager object a reference to the one\n            // that is already created.\n            tagManager = w.conversant.tagManager;\n        }\n\n        // added to transfer locale\n        if(tagManager.locale) {\n          _.extend(locale, tagManager.locale)     \n        }\n\n\t\ttagManager.VERSION = VERSION;\n\n        // Create our ErrorReporter\n        errorReporter = __webpack_require__(22)(tagManager);\n\n        // Expose Libararies\n        tagManager.lib = {\n            $: $,\n            _: _\n        };\n\n        // Run all of our mixins to attach them to the underscore instance\n        __webpack_require__(7)();\n        __webpack_require__(8)();\n        __webpack_require__(9)();\n        __webpack_require__(5)();\n        __webpack_require__(25)();\n        __webpack_require__(10)();\n        __webpack_require__(26)();\n        __webpack_require__(24)();\n\n        // create init function -- could be later hooked up at\n        // window.conversant.tagManager.init.\n        initFunction = function(siteIdOrContainer, overrides) {\n\n            var buildFromContainer = function(container) {\n                var BodyAvailable = __webpack_require__(20);\n                var bodyAvailable = new BodyAvailable();\n\n                // Make what was received from the server available\n                tagManager.container = container;\n\n                if (container.debug) {\n                    container.plugIns.push(__webpack_require__(28)(locale));\n                    tagManager.debugUpdates = {\n                        queue: [],\n                        push: function(debugUpdate) {\n                            this.queue.push(debugUpdate);\n                        }\n                    };\n                }\n\n                if (container.actions) {\n                    containerEventsController = new ContainerEventsController(tagManager, container.actions);\n                }\n\n                // once our body is available\n                bodyAvailable.done(function() {\n\n                    var executionBlockSize = 10;\n                    var sets = [];\n                    var i;\n                    var totalSets;\n                    var remainder;\n                    var createTags;\n                    var plugIns;\n                    var plugInsLength;\n                    var failFunction = function(plugIn) {\n                        plugIn.status = \"fail\";\n                        notificationController.addToQueue(plugIn);\n                    };\n\n                    if ($.isPlainObject(container)) {\n\n                        // Shortcut for minify\n                        plugIns = container.plugIns;\n                        plugInsLength = plugIns.length;\n\n                        // totalSets gets whole numbers first\n                        totalSets = Math.floor(plugInsLength / executionBlockSize);\n\n                        // remainder get's the last non full set\n                        remainder = plugInsLength % executionBlockSize;\n\n                        // update total sets if it wasn't an even number\n                        totalSets = totalSets + (remainder > 0 ? 1 : 0);\n\n                        // Create tags will build a chunk of tags along the plugIns node\n                        createTags = function(startIndex, length) {\n                            var tag;\n                            var j;\n                            var plugIn;\n\n                            for (j = startIndex; j < (startIndex + length); j++) {\n\n                                // use a shortcut here (for minify)\n                                plugIn = plugIns[j];\n\n                                // Set our pending flag this will be useful in other parts\n                                // of the code and isn't given to us in the container\n                                plugIn.status = \"pending\";\n\n                                // Create the tag, tie resolution to the notification\n                                // controller for notifying the server\n                                try {\n                                    tag = new Tag(plugIn, tagManager.mainDIV, locale, srcRegistry, pendingTagCollection, unattachedEventsController);\n\n                                    if (notificationController) {\n                                        tag.done(notificationController.addToQueue);\n                                        tag.fail(failFunction);\n                                    }\n\n                                } catch (tagCreationError) {\n                                    errorReporter.reportError({\n                                        tagId: plugIn.tagId,\n                                        plugIn: plugIn,\n                                        message: \"Problem creating tag\",\n                                        error: tagCreationError\n                                    });\n                                }\n                            }\n                        };\n\n                        // Build an array (sets) that will contain the length of each chunk\n                        // Using our crazy math skillz we'll create full blocks as defined\n                        // by our executionBlockSize and then get the remainder if the\n                        // number of tags (plugIns) doesn't divide evenly. We'll shove those\n                        // into an array to use later as a length of a loop so we can know\n                        // when to stop.\n                        for (i = 0; i < totalSets; i++) {\n                            if (i === totalSets - 1 && remainder > 0) {\n                                sets.push(remainder);\n                            } else {\n                                sets.push(executionBlockSize);\n                            }\n                        }\n\n                        // Append our mainDIV to the body\n                        $(\"body\").append(tagManager.mainDIV);\n\n                        // Check to make sure we have plugIns, it could be 0\n                        if (tagManager.container.plugIns.length > 0) {\n\n                            // Create our Pending Tag Collection\n                            pendingTagCollection = new PendingTagCollection(tagManager);\n\n                            // Create our SrcRegistry for non duplication of tag srcs\n                            srcRegistry = new SrcRegistry();\n\n\n                            // Execute building our tags loop through our chunks we'll get the first\n                            // n (executionBlockSize) right away and then we'll break to not slow down\n                            // the page and put those in a set timeout to break the execution thread.\n                            for (i = 0; i < sets.length; i++) {\n                                if (i === 0) {\n\n                                    // first one free, just call it directly in the execution thread\n                                    createTags(i, sets[i]);\n                                } else {\n\n                                    // Set a timeout for the createTags function.  We're using the execution\n                                    // break multiplied by our iterator for how long to wait, shouldn't be long just\n                                    // enough to break the exuction of the script.  The start index will be\n                                    // our index multiplied by how many are in a block. Lastly, our length\n                                    // is stored in our sets array.\n                                    setTimeout(createTags, 0, i * executionBlockSize, sets[i]);\n\n                                }\n                            }\n                            setTimeout(unattachedEventsController.initiate, sets.length * executionBlockSize);\n                        }\n                    } else {\n                        errorReporter.reportError({\n                            message: \"Container is not an object\"\n                        });\n                    }\n                });\n            };\n\n            // if it's a string and a string is not empty or if it's a number and greater than 0\n            if ((_.isString(siteIdOrContainer) && _.isSet(siteIdOrContainer)) || (_.isNumber(siteIdOrContainer) && siteIdOrContainer > 0)) {\n\n                // it's a site id -- Use RPC to get the container\n                siteId = siteIdOrContainer;\n                rpc = new RPC(locale, siteId);\n                notificationController = new NotificationController(rpc, tagManager);\n\n                try {\n                    // Request our container\n                    rpc.getContainer(!_.isUndefined(w.MasterTmsUdo) ? w.MasterTmsUdo : undefined, overrides).done(buildFromContainer);\n                } catch (getContainerError) {\n                    errorReporter.reportError({\n                        message: \"Problem gettting container\",\n                        error: getContainerError\n                    });\n                }\n\n                // if it's an object, we know it's a container\n            } else if ($.isPlainObject(siteIdOrContainer)) {\n\n                try {\n                    // it's a container -- build it without doing an RPC request\n                    buildFromContainer(siteIdOrContainer);\n                } catch (buildFromContainerError) {\n                    errorReporter.reportError({\n                        message: \"Build from container\",\n                        error: buildFromContainerError\n                    });\n                }\n\n                // init was called with nothing, basically we can't do anything at this point.\n            } else {\n\n                // it's nothing so just die\n                errorReporter.reportError({\n                    initialization: \"No siteId and no container passed in on init()\"\n                });\n            }\n        };\n\n        clearFunction = function() {\n            delete tagManager.container;\n            if (errorReporter) {\n                errorReporter.clear();\n            }\n            tagManager.mainDIV.empty();\n            if (pendingTagCollection) {\n                pendingTagCollection.clear();\n            }\n            unattachedEventsController.clear();\n        };\n\n        resetFunction = function(siteIdOrContainer) {\n            tagManager.clear();\n            if ($.isPlainObject(siteIdOrContainer)) {\n                tagManager.container = siteIdOrContainer;\n                tagManager.init(siteIdOrContainer);\n\n            } else if (_.isString(siteIdOrContainer)) {\n\n                // it's a site id passed in\n                tagManager.init(siteIdOrContainer);\n            } else if (_.isString(siteId)) {\n\n                // it's nothing passed in use our Site Id\n                tagManager.init(siteId);\n\n            } else {\n                // NOTHING passed in... no reset.\n                errorReporter.reportError({\n                    msg: \"Unable to reset, no siteId or container\",\n                    obj: \"main ctm.js, in the reset function\"\n                });\n            }\n        };\n\n        // if we don't already have a div to put things into\n        if (!tagManager.mainDIV) {\n            tagManager.mainDIV = __webpack_require__(21)();\n        }\n\n        // if we don't already have an init funciton\n        if (!tagManager.init) {\n            tagManager.init = initFunction;\n        }\n\n        // if we don't already have a clear funciton\n        if (!tagManager.clear) {\n            tagManager.clear = clearFunction;\n        }\n\n        // if we don't already have a reset funciton\n        if (!tagManager.reset) {\n            tagManager.reset = resetFunction;\n        }\n\n        // if we don't already have a container object\n        if (!tagManager.container) {\n\n            // assume we're going off of our siteId and get that\n            siteId = getSiteId();\n\n            // if we successfully got the siteId from our script src tag\n            if (_.isSet(siteId)) {\n\n                tagManager.siteId = siteId;\n\n                // initialize our tags with a siteId\n                tagManager.init(siteId);\n\n            } // else sit idle because we're expecting to be initted from the outside\n        } else {\n\n            // We do have a container, so we run with that and don't call the server\n            tagManager.init(tagManager.container);\n\n        }\n    } catch (catchAllError) {\n\n        cnvr = w.conversant = w.conversant || {};\n        cnvr = cnvr.tagManager = cnvr.tagManager || {};\n        cnvr = cnvr.errors = cnvr.errors || [];\n\n        cnvr.push({\n            message: \"Catch All Error\",\n            error: catchAllError\n        });\n\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvY3RtLmpzPzUwN2EiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixRQUFROztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsRUFBUTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLOztBQUVMLENBQUM7O0FBRUQ7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxDQUFZO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLENBQU87O0FBRS9CO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsRUFBa0I7QUFDNUMscUNBQXFDLG1CQUFPLENBQUMsRUFBcUM7QUFDbEYseUNBQXlDLG1CQUFPLENBQUMsRUFBeUM7QUFDMUYsd0NBQXdDLG1CQUFPLENBQUMsRUFBd0M7O0FBRXhGO0FBQ0EsbUNBQW1DLG1CQUFPLENBQUMsRUFBNkI7QUFDeEUsMEJBQTBCLG1CQUFPLENBQUMsRUFBb0I7QUFDdEQsa0JBQWtCLG1CQUFPLENBQUMsRUFBbUI7O0FBRTdDO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsRUFBbUI7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxFQUF1Qjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsbUJBQU8sQ0FBQyxDQUFnQztBQUNoRCxRQUFRLG1CQUFPLENBQUMsQ0FBbUM7QUFDbkQsUUFBUSxtQkFBTyxDQUFDLENBQW9DO0FBQ3BELFFBQVEsbUJBQU8sQ0FBQyxDQUEyQjtBQUMzQyxRQUFRLG1CQUFPLENBQUMsRUFBNEI7QUFDNUMsUUFBUSxtQkFBTyxDQUFDLEVBQWtDO0FBQ2xELFFBQVEsbUJBQU8sQ0FBQyxFQUFtQztBQUNuRCxRQUFRLG1CQUFPLENBQUMsRUFBNkI7O0FBRTdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxtQkFBTyxDQUFDLEVBQWU7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxtQkFBTyxDQUFDLEVBQXdCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsMkJBQTJCOztBQUUzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQjtBQUN4RDs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxtQkFBTyxDQUFDLEVBQWU7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgbm9tZW46IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdmFyczp0cnVlLCBwbHVzcGx1czp0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIFZlcnNpb24gbnVtYmVyIHRoYXQgY2FuIGJlIGFjY2Vzc2VkIHZpYSB3aW5kb3cuY29udmVyc2FudC50YWdNYW5hZ2VyLlZFUlNJT05cbnZhciBWRVJTSU9OID0gXCJbQUlWXXt2ZXJzaW9ufVsvQUlWXVwiO1xuXG4vLyBhbGlhcyB0aGUgd2luZG93IGZvciBtaW5pZnlcbnZhciB3ID0gd2luZG93O1xuLy8gYWxpYXMgZG9jdW1lbnQgZm9yIG1pbmlmeVxudmFyIGQgPSBkb2N1bWVudDtcbnZhciBjbnZyO1xuXG4vLyB2YWx1ZSBpbmplY3RlZCBieSBncnVudCB3aWxsIGJlIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgbGlrZSB0YWdTZXJ2ZXJVUkkgZXRjLi4uXG4vLyB0aGlzIGlzIGFsaWFzZWQsIHNvIGlmIHRoZSBidWlsZCBjb25maWcgZG9lc24ndCB3b3JrIEkgZG9uJ3Qgd2FudCBpdCB0byBiZSB1bmRlZmluZWQuXG52YXIgbG9jYWxlID0gcmVxdWlyZShcImxvY2FsZVwiKTtcblxuLy8gV2Uga25vdyBmb3Igc3VyZSB0aGF0IE11dGF0aW9uT2JzZXJ2ZXIgaXMgaW1wbGVtZW50ZWQgZnJvbSBpZTExIGFuZCB1cC4gV2UgYXJlIGFzIG9mIDUvMDEvMjAxNyBhbGxvd2luZ1xuLy8gdGhlIGdyZWVuIHZlcnNpb24gb2YgdGhpcyBjbGllbnQgdG8gcnVuIGluIGllMTEgYW5kIHVwIHNpbmNlIE1pY3Jvc29mdCBoYXMgY2xlYW5lZCB1cCB0aGVpciBhY3QgYSBiaXQuXG4vLyBJJ20gZ29pbmcgdG8gZmVhdHVyZSBkZXRlY3QsIHNpbmNlIHdlIHJlbHkgb24gdGhpcyBmdW5jdGlvbmFsaXR5IGZvciB0YWcgZmlyaW5nIGFuZCBxdWVpbmcuICBJZiB0aGVcbi8vIE11dGF0aW9uT2JzZXJ2ZXIgZG9lc24ndCBleGlzdCwgd2UncmUgZ29pbmcgdG8gbG9hZCB0aGUgb2xkIHZlcnNpb24gb2YgdGhlIGNsaWVudCBzbyB0aGF0IHdlIGdldCBob3BlZnVsbHlcbi8vIHNvbWUgdGFnIGZpcmluZywga25vd2luZyBmdWxsIHdlbGwgd2UgYXJlbid0IHdyaXRpbmcgbmV3IGZlYXR1cmVzIGludG8gdGhhdCBjbGllbnQgYW55bW9yZS4gIEF0IHRoZSB0aW1lXG4vLyBvZiB0aGlzIGNvZGUgd3JpdGluZyBpdCdzIGxlc3MgdGhhbiAxLjUlIG9mIG91ciBlbnRpcmUgbWFya2V0LlxuaWYgKHcuTXV0YXRpb25PYnNlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG5cbiAgICAvLyBJJ20gZ29pbmcgdG8gd3JhcCB0aGlzIGludG8gYSBzZWxmIGV4ZXVjdGluZyBmdW5jdGlvbiAoSUlGRSkgdG8ga2VlcCB2YXJpYWJsZXMgd2l0aGluZyBhIGNsb3N1cmUuXG4gICAgKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzaXRlO1xuICAgICAgICB2YXIgc3JjO1xuICAgICAgICB2YXIgTWFzdGVyVE1TRWxlO1xuICAgICAgICB2YXIgcGFyZW50O1xuICAgICAgICB2YXIgbG9hZE9sZDtcbiAgICAgICAgdmFyIHNjcmlwdHMgPSBkLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgICAgICAgdmFyIGdyYWJTaXRlUmVnZXggPSBuZXcgUmVnRXhwKFwiI1swLTldK1wiKTtcbiAgICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICAgIC8vIGdvdCB0byBkbyBldmVyeXRoaW5nIHRoZSBoYXJkIHdheSBiZWNhdXNlIHdlIGFyZSBpbiBJRVxuICAgICAgICAvLyBhbmQgemVwdG8gaXMgbm9uLUlFIGNvbXBhdGlibGUgXG4gICAgICAgIGZvciAoaTsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgLy8gSWYgd2UgZmluZCBvdXQgc2NyaXB0IHRhZ1xuICAgICAgICAgICAgaWYgKHNjcmlwdHNbaV0uc3JjLmluZGV4T2YoJ01hc3RlclRNUycpID4gLTEpIHtcbiAgICAgICAgICAgICAgICBNYXN0ZXJUTVNFbGUgPSBzY3JpcHRzW2ldO1xuICAgICAgICAgICAgICAgIHNpdGUgPSBNYXN0ZXJUTVNFbGUuc3JjLm1hdGNoKGdyYWJTaXRlUmVnZXgpWzBdO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UndmUgbm93IGJ1aWx0IG91ciBlcXVpdmFsZW50IHZlcnNpb24gb2YgdGhlICdsZWdhY3knIGNsaWVudFxuICAgICAgICAgICAgICAgIHNyYyA9IGxvY2FsZS5jZG4gKyAnL3MvTWFzdGVyVE1TLWxlZ2FjeS5taW4uanMnICsgc2l0ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHBsYWNlIGZvciB0aGUgbGVnYWN5IHNjcmlwdFxuICAgICAgICBsb2FkT2xkID0gZC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgbG9hZE9sZC50eXBlID0gTWFzdGVyVE1TRWxlLnR5cGU7XG4gICAgICAgIGxvYWRPbGQuc3JjID0gc3JjO1xuXG4gICAgICAgIC8vIFJlbW92ZSBvdXIgc2NyaXB0IHRhZyBhbmQgcHV0IHRoZSAnbGVnYWN5JyB2ZXJzaW9uIG9uXG4gICAgICAgIHBhcmVudCA9IE1hc3RlclRNU0VsZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoTWFzdGVyVE1TRWxlKTtcbiAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGxvYWRPbGQpO1xuXG4gICAgfSgpKTtcblxufSBlbHNlIHtcblxuICAgIHRyeSB7XG5cbiAgICAgICAgLy8gbGliXG4gICAgICAgIHZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG4gICAgICAgIHZhciAkID0gcmVxdWlyZShcInplcHRvXCIpO1xuXG4gICAgICAgIC8vIGNvbnRyb2xsZXJcbiAgICAgICAgdmFyIFRhZyA9IHJlcXVpcmUoXCIuL2NvbnRyb2xsZXIvVGFnXCIpO1xuICAgICAgICB2YXIgTm90aWZpY2F0aW9uQ29udHJvbGxlciA9IHJlcXVpcmUoXCIuL2NvbnRyb2xsZXIvTm90aWZpY2F0aW9uQ29udHJvbGxlclwiKTtcbiAgICAgICAgdmFyIFVuYXR0YWNoZWRFdmVudHNDb250cm9sbGVyID0gcmVxdWlyZShcIi4vY29udHJvbGxlci9VbmF0dGFjaGVkRXZlbnRzQ29udHJvbGxlclwiKTtcbiAgICAgICAgdmFyIENvbnRhaW5lckV2ZW50c0NvbnRyb2xsZXIgPSByZXF1aXJlKFwiLi9jb250cm9sbGVyL0NvbnRhaW5lckV2ZW50c0NvbnRyb2xsZXJcIik7XG5cbiAgICAgICAgLy8gZGF0YVxuICAgICAgICB2YXIgUGVuZGluZ1RhZ0NvbGxlY3Rpb24gPSByZXF1aXJlKFwiLi9kYXRhL1BlbmRpbmdUYWdDb2xsZWN0aW9uXCIpO1xuICAgICAgICB2YXIgU3JjUmVnaXN0cnkgPSByZXF1aXJlKFwiLi9kYXRhL1NyY1JlZ2lzdHJ5XCIpO1xuICAgICAgICB2YXIgUlBDID0gcmVxdWlyZShcIi4vZGF0YS9ycGMvUlBDLmpzXCIpO1xuXG4gICAgICAgIC8vIHV0aWxzXG4gICAgICAgIHZhciBnZXRTaXRlSWQgPSByZXF1aXJlKFwiLi91dGlscy9nZXRTaXRlSWRcIik7XG5cbiAgICAgICAgLy8gT3VyIHNwZWNpZmljIHByb2R1Y3Qgd2l0aGluIHRoZSBjb252ZXJzYW50IGNvbXBhbnkgYW5kIG9iamVjdC5cbiAgICAgICAgdmFyIHRhZ01hbmFnZXIgPSB7fTtcblxuICAgICAgICAvLyBFcnJvciBSZXBvcnRlciBDbGFzc1xuICAgICAgICB2YXIgZXJyb3JSZXBvcnRlcjtcblxuICAgICAgICAvLyBQZW5kaW5nIFRhZyBDb2xsZWN0aW9uIGNyZWF0ZXMgc29tZXRoaW5nIG9uIHRoZSBjb252ZXJzYW50LnRhZ01hbmFnZXIucGVuZGluZ1RhZ3NcbiAgICAgICAgdmFyIHBlbmRpbmdUYWdDb2xsZWN0aW9uO1xuXG4gICAgICAgIC8vIFVuYXR0Y2hlZCBldmVudHMgYXJlIGV2ZW50LWJhc2VkIHRhZ3MgdGhhdCBhcmUgY3JlYXRlZCBidXQgaGF2ZSBub1xuICAgICAgICAvLyBjc3Mgc2VsZWN0b3IgdG8gYXR0YWNoIHRvLiAgSW4gdGhlb3J5LCB0aGUgY3NzIHNlbGVjdG9yIGNvdWxkIGNvbWUgXG4gICAgICAgIC8vIGluIGxhdGVyIHNvIHdlJ2xsIGNyZWF0ZSB0aGlzIGNvbnRyb2xsZXIgdG8gbWFuYWdlIHRoYXQuXG4gICAgICAgIHZhciB1bmF0dGFjaGVkRXZlbnRzQ29udHJvbGxlciA9IG5ldyBVbmF0dGFjaGVkRXZlbnRzQ29udHJvbGxlcigpO1xuXG4gICAgICAgIC8vIG91ciBpbnN0YWNlIG9mIFJQQyBjbGFzc1xuICAgICAgICB2YXIgcnBjO1xuXG4gICAgICAgIC8vIE91ciBjb250cm9sbGVyIGNsYXNzIGZvciBvdXIgTm90aWZpY2F0aW9uIG9mIHRoZSBjb250YWluZXJcbiAgICAgICAgdmFyIG5vdGlmaWNhdGlvbkNvbnRyb2xsZXI7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgZ2xvYmFsIHJlZ2lzdHJ5IG9mIHNyY3MgYnVpbHQsIGZvciBidWlsZFNyY09uY2UgcGFyYW1ldGVyIG9uIHRhZ3NcbiAgICAgICAgdmFyIHNyY1JlZ2lzdHJ5O1xuXG4gICAgICAgIC8vIGNvbnRhaW5lciBhY3Rpb25zYyBjb250cm9sbGVyIHZhciBzdHViXG4gICAgICAgIHZhciBjb250YWluZXJFdmVudHNDb250cm9sbGVyO1xuXG4gICAgICAgIC8vIG91ciBmdW5jdGlvbnMgZm9yIG91ciBBUEkgZnVuY3Rpb25zXG4gICAgICAgIHZhciBpbml0RnVuY3Rpb247XG4gICAgICAgIHZhciBjbGVhckZ1bmN0aW9uO1xuICAgICAgICB2YXIgcmVzZXRGdW5jdGlvbjtcblxuICAgICAgICAvLyBzaXRlSWQgZ3JhYmJlZCBmcm9tIHRoZSBVUkwgb2YgdGhpcyBzY3JpcCB0YWdcbiAgICAgICAgdmFyIHNpdGVJZDtcblxuICAgICAgICAvLyB3ZSdyZSBsb29raW5nIGZvciBhIGdsb2JhbCBvYmplY3QgbmFtZWQgJ2NvbnZlcnNhbnQnIGlmIGl0IGRvZXNuJ3RcbiAgICAgICAgLy8gZXhpc3Qgd2Ugd2lsbCBjcmVhdGUgaXQgYW5kIHB1dCBvdXIgdGFnTWFuYWdlciBvYmplY3QgdW5kZXIgaXQuXG4gICAgICAgIHcuY29udmVyc2FudCA9IHcuY29udmVyc2FudCB8fCB7fTtcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vIHRhZ01hbmFnZXIgT2JqZWN0IHRoZW4gd2UnbGwganVzdCBjcmVhdGUgaXQuXG4gICAgICAgIGlmICghdy5jb252ZXJzYW50LnRhZ01hbmFnZXIpIHtcblxuICAgICAgICAgICAgLy8gbGluayB1cCB0YWdNYW5hZ2VyIG9iamVjdFxuICAgICAgICAgICAgdy5jb252ZXJzYW50LnRhZ01hbmFnZXIgPSB0YWdNYW5hZ2VyO1xuXG4gICAgICAgICAgICAvLyBpZiBzb21lb25lIGlzIHRyeWluZyB0byBwYXNzIGluZm8gYW5kIGhhcyBhbHJlYWR5IGNyZWF0ZWQgYVxuICAgICAgICAgICAgLy8gdGFnTWFuYWdlciBvYmplY3QgdGhlbiB3ZSBuZWVkIHRvIGJlIG1vcmUgY2FyZWZ1bCB3aXRoIHdoYXRcbiAgICAgICAgICAgIC8vIGlzIHRoZXJlLlxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBtYWtlIG91ciBsb2NhbCB0YWdNYW5hZ2VyIG9iamVjdCBhIHJlZmVyZW5jZSB0byB0aGUgb25lXG4gICAgICAgICAgICAvLyB0aGF0IGlzIGFscmVhZHkgY3JlYXRlZC5cbiAgICAgICAgICAgIHRhZ01hbmFnZXIgPSB3LmNvbnZlcnNhbnQudGFnTWFuYWdlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZGVkIHRvIHRyYW5zZmVyIGxvY2FsZVxuICAgICAgICBpZih0YWdNYW5hZ2VyLmxvY2FsZSkge1xuICAgICAgICAgIF8uZXh0ZW5kKGxvY2FsZSwgdGFnTWFuYWdlci5sb2NhbGUpICAgICBcbiAgICAgICAgfVxuXG5cdFx0dGFnTWFuYWdlci5WRVJTSU9OID0gVkVSU0lPTjtcblxuICAgICAgICAvLyBDcmVhdGUgb3VyIEVycm9yUmVwb3J0ZXJcbiAgICAgICAgZXJyb3JSZXBvcnRlciA9IHJlcXVpcmUoXCIuL2Vycm9yL0Vycm9yUmVwb3J0ZXJcIikodGFnTWFuYWdlcik7XG5cbiAgICAgICAgLy8gRXhwb3NlIExpYmFyYXJpZXNcbiAgICAgICAgdGFnTWFuYWdlci5saWIgPSB7XG4gICAgICAgICAgICAkOiAkLFxuICAgICAgICAgICAgXzogX1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJ1biBhbGwgb2Ygb3VyIG1peGlucyB0byBhdHRhY2ggdGhlbSB0byB0aGUgdW5kZXJzY29yZSBpbnN0YW5jZVxuICAgICAgICByZXF1aXJlKFwiLi91bmRlcnNjb3JlX21peGlucy9jbG9uZUFycmF5XCIpKCk7XG4gICAgICAgIHJlcXVpcmUoXCIuL3VuZGVyc2NvcmVfbWl4aW5zL2NvbnZlcnRSZWdFeHBcIikoKTtcbiAgICAgICAgcmVxdWlyZShcIi4vdW5kZXJzY29yZV9taXhpbnMvaXNJbnRlcnBPYmplY3RcIikoKTtcbiAgICAgICAgcmVxdWlyZShcIi4vdW5kZXJzY29yZV9taXhpbnMvaXNTZXRcIikoKTtcbiAgICAgICAgcmVxdWlyZShcIi4vdW5kZXJzY29yZV9taXhpbnMvaXNUcnVlXCIpKCk7XG4gICAgICAgIHJlcXVpcmUoXCIuL3VuZGVyc2NvcmVfbWl4aW5zL3ByZXBlbmRBcnJheVwiKSgpO1xuICAgICAgICByZXF1aXJlKFwiLi91bmRlcnNjb3JlX21peGlucy90b1F1ZXJ5U3RyaW5nXCIpKCk7XG4gICAgICAgIHJlcXVpcmUoXCIuL3B1bHNlYWRhcHRlci9QdWxzZUFkYXB0ZXJcIikoKTtcblxuICAgICAgICAvLyBjcmVhdGUgaW5pdCBmdW5jdGlvbiAtLSBjb3VsZCBiZSBsYXRlciBob29rZWQgdXAgYXRcbiAgICAgICAgLy8gd2luZG93LmNvbnZlcnNhbnQudGFnTWFuYWdlci5pbml0LlxuICAgICAgICBpbml0RnVuY3Rpb24gPSBmdW5jdGlvbihzaXRlSWRPckNvbnRhaW5lciwgb3ZlcnJpZGVzKSB7XG5cbiAgICAgICAgICAgIHZhciBidWlsZEZyb21Db250YWluZXIgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgQm9keUF2YWlsYWJsZSA9IHJlcXVpcmUoXCJCb2R5QXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgICAgIHZhciBib2R5QXZhaWxhYmxlID0gbmV3IEJvZHlBdmFpbGFibGUoKTtcblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugd2hhdCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIHRhZ01hbmFnZXIuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIucGx1Z0lucy5wdXNoKHJlcXVpcmUoXCIuL3V0aWxzL3RhZ0J1ZGR5UGx1Z0luXCIpKGxvY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICB0YWdNYW5hZ2VyLmRlYnVnVXBkYXRlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uKGRlYnVnVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKGRlYnVnVXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyLmFjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyRXZlbnRzQ29udHJvbGxlciA9IG5ldyBDb250YWluZXJFdmVudHNDb250cm9sbGVyKHRhZ01hbmFnZXIsIGNvbnRhaW5lci5hY3Rpb25zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvbmNlIG91ciBib2R5IGlzIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGJvZHlBdmFpbGFibGUuZG9uZShmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhlY3V0aW9uQmxvY2tTaXplID0gMTA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXRzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxTZXRzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVtYWluZGVyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3JlYXRlVGFncztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsdWdJbnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbHVnSW5zTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmFpbEZ1bmN0aW9uID0gZnVuY3Rpb24ocGx1Z0luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbHVnSW4uc3RhdHVzID0gXCJmYWlsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb25Db250cm9sbGVyLmFkZFRvUXVldWUocGx1Z0luKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGNvbnRhaW5lcikpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIG1pbmlmeVxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z0lucyA9IGNvbnRhaW5lci5wbHVnSW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z0luc0xlbmd0aCA9IHBsdWdJbnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0b3RhbFNldHMgZ2V0cyB3aG9sZSBudW1iZXJzIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNldHMgPSBNYXRoLmZsb29yKHBsdWdJbnNMZW5ndGggLyBleGVjdXRpb25CbG9ja1NpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1haW5kZXIgZ2V0J3MgdGhlIGxhc3Qgbm9uIGZ1bGwgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXIgPSBwbHVnSW5zTGVuZ3RoICUgZXhlY3V0aW9uQmxvY2tTaXplO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdG90YWwgc2V0cyBpZiBpdCB3YXNuJ3QgYW4gZXZlbiBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2V0cyA9IHRvdGFsU2V0cyArIChyZW1haW5kZXIgPiAwID8gMSA6IDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGFncyB3aWxsIGJ1aWxkIGEgY2h1bmsgb2YgdGFncyBhbG9uZyB0aGUgcGx1Z0lucyBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVUYWdzID0gZnVuY3Rpb24oc3RhcnRJbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGx1Z0luO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gc3RhcnRJbmRleDsgaiA8IChzdGFydEluZGV4ICsgbGVuZ3RoKTsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGEgc2hvcnRjdXQgaGVyZSAoZm9yIG1pbmlmeSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z0luID0gcGx1Z0luc1tqXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgb3VyIHBlbmRpbmcgZmxhZyB0aGlzIHdpbGwgYmUgdXNlZnVsIGluIG90aGVyIHBhcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBjb2RlIGFuZCBpc24ndCBnaXZlbiB0byB1cyBpbiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdJbi5zdGF0dXMgPSBcInBlbmRpbmdcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHRhZywgdGllIHJlc29sdXRpb24gdG8gdGhlIG5vdGlmaWNhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sbGVyIGZvciBub3RpZnlpbmcgdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnID0gbmV3IFRhZyhwbHVnSW4sIHRhZ01hbmFnZXIubWFpbkRJViwgbG9jYWxlLCBzcmNSZWdpc3RyeSwgcGVuZGluZ1RhZ0NvbGxlY3Rpb24sIHVuYXR0YWNoZWRFdmVudHNDb250cm9sbGVyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGlmaWNhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcuZG9uZShub3RpZmljYXRpb25Db250cm9sbGVyLmFkZFRvUXVldWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZy5mYWlsKGZhaWxGdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodGFnQ3JlYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXBvcnRlci5yZXBvcnRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnSWQ6IHBsdWdJbi50YWdJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnSW46IHBsdWdJbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlByb2JsZW0gY3JlYXRpbmcgdGFnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRhZ0NyZWF0aW9uRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGQgYW4gYXJyYXkgKHNldHMpIHRoYXQgd2lsbCBjb250YWluIHRoZSBsZW5ndGggb2YgZWFjaCBjaHVua1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNpbmcgb3VyIGNyYXp5IG1hdGggc2tpbGx6IHdlJ2xsIGNyZWF0ZSBmdWxsIGJsb2NrcyBhcyBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBvdXIgZXhlY3V0aW9uQmxvY2tTaXplIGFuZCB0aGVuIGdldCB0aGUgcmVtYWluZGVyIGlmIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIHRhZ3MgKHBsdWdJbnMpIGRvZXNuJ3QgZGl2aWRlIGV2ZW5seS4gV2UnbGwgc2hvdmUgdGhvc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludG8gYW4gYXJyYXkgdG8gdXNlIGxhdGVyIGFzIGEgbGVuZ3RoIG9mIGEgbG9vcCBzbyB3ZSBjYW4ga25vd1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0byBzdG9wLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRvdGFsU2V0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHRvdGFsU2V0cyAtIDEgJiYgcmVtYWluZGVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRzLnB1c2gocmVtYWluZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRzLnB1c2goZXhlY3V0aW9uQmxvY2tTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBvdXIgbWFpbkRJViB0byB0aGUgYm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKHRhZ01hbmFnZXIubWFpbkRJVik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIG1ha2Ugc3VyZSB3ZSBoYXZlIHBsdWdJbnMsIGl0IGNvdWxkIGJlIDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWdNYW5hZ2VyLmNvbnRhaW5lci5wbHVnSW5zLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBvdXIgUGVuZGluZyBUYWcgQ29sbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdUYWdDb2xsZWN0aW9uID0gbmV3IFBlbmRpbmdUYWdDb2xsZWN0aW9uKHRhZ01hbmFnZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG91ciBTcmNSZWdpc3RyeSBmb3Igbm9uIGR1cGxpY2F0aW9uIG9mIHRhZyBzcmNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUmVnaXN0cnkgPSBuZXcgU3JjUmVnaXN0cnkoKTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhlY3V0ZSBidWlsZGluZyBvdXIgdGFncyBsb29wIHRocm91Z2ggb3VyIGNodW5rcyB3ZSdsbCBnZXQgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbiAoZXhlY3V0aW9uQmxvY2tTaXplKSByaWdodCBhd2F5IGFuZCB0aGVuIHdlJ2xsIGJyZWFrIHRvIG5vdCBzbG93IGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcGFnZSBhbmQgcHV0IHRob3NlIGluIGEgc2V0IHRpbWVvdXQgdG8gYnJlYWsgdGhlIGV4ZWN1dGlvbiB0aHJlYWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyc3Qgb25lIGZyZWUsIGp1c3QgY2FsbCBpdCBkaXJlY3RseSBpbiB0aGUgZXhlY3V0aW9uIHRocmVhZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlVGFncyhpLCBzZXRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGEgdGltZW91dCBmb3IgdGhlIGNyZWF0ZVRhZ3MgZnVuY3Rpb24uICBXZSdyZSB1c2luZyB0aGUgZXhlY3V0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBicmVhayBtdWx0aXBsaWVkIGJ5IG91ciBpdGVyYXRvciBmb3IgaG93IGxvbmcgdG8gd2FpdCwgc2hvdWxkbid0IGJlIGxvbmcganVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5vdWdoIHRvIGJyZWFrIHRoZSBleHVjdGlvbiBvZiB0aGUgc2NyaXB0LiAgVGhlIHN0YXJ0IGluZGV4IHdpbGwgYmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91ciBpbmRleCBtdWx0aXBsaWVkIGJ5IGhvdyBtYW55IGFyZSBpbiBhIGJsb2NrLiBMYXN0bHksIG91ciBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHN0b3JlZCBpbiBvdXIgc2V0cyBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY3JlYXRlVGFncywgMCwgaSAqIGV4ZWN1dGlvbkJsb2NrU2l6ZSwgc2V0c1tpXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHVuYXR0YWNoZWRFdmVudHNDb250cm9sbGVyLmluaXRpYXRlLCBzZXRzLmxlbmd0aCAqIGV4ZWN1dGlvbkJsb2NrU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlcG9ydGVyLnJlcG9ydEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkNvbnRhaW5lciBpcyBub3QgYW4gb2JqZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBpZiBpdCdzIGEgc3RyaW5nIGFuZCBhIHN0cmluZyBpcyBub3QgZW1wdHkgb3IgaWYgaXQncyBhIG51bWJlciBhbmQgZ3JlYXRlciB0aGFuIDBcbiAgICAgICAgICAgIGlmICgoXy5pc1N0cmluZyhzaXRlSWRPckNvbnRhaW5lcikgJiYgXy5pc1NldChzaXRlSWRPckNvbnRhaW5lcikpIHx8IChfLmlzTnVtYmVyKHNpdGVJZE9yQ29udGFpbmVyKSAmJiBzaXRlSWRPckNvbnRhaW5lciA+IDApKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBpdCdzIGEgc2l0ZSBpZCAtLSBVc2UgUlBDIHRvIGdldCB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgc2l0ZUlkID0gc2l0ZUlkT3JDb250YWluZXI7XG4gICAgICAgICAgICAgICAgcnBjID0gbmV3IFJQQyhsb2NhbGUsIHNpdGVJZCk7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uQ29udHJvbGxlciA9IG5ldyBOb3RpZmljYXRpb25Db250cm9sbGVyKHJwYywgdGFnTWFuYWdlcik7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXF1ZXN0IG91ciBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgcnBjLmdldENvbnRhaW5lcighXy5pc1VuZGVmaW5lZCh3Lk1hc3RlclRtc1VkbykgPyB3Lk1hc3RlclRtc1VkbyA6IHVuZGVmaW5lZCwgb3ZlcnJpZGVzKS5kb25lKGJ1aWxkRnJvbUNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZ2V0Q29udGFpbmVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JSZXBvcnRlci5yZXBvcnRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlByb2JsZW0gZ2V0dHRpbmcgY29udGFpbmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZ2V0Q29udGFpbmVyRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBhbiBvYmplY3QsIHdlIGtub3cgaXQncyBhIGNvbnRhaW5lclxuICAgICAgICAgICAgfSBlbHNlIGlmICgkLmlzUGxhaW5PYmplY3Qoc2l0ZUlkT3JDb250YWluZXIpKSB7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIGEgY29udGFpbmVyIC0tIGJ1aWxkIGl0IHdpdGhvdXQgZG9pbmcgYW4gUlBDIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRGcm9tQ29udGFpbmVyKHNpdGVJZE9yQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChidWlsZEZyb21Db250YWluZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvclJlcG9ydGVyLnJlcG9ydEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQnVpbGQgZnJvbSBjb250YWluZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBidWlsZEZyb21Db250YWluZXJFcnJvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpbml0IHdhcyBjYWxsZWQgd2l0aCBub3RoaW5nLCBiYXNpY2FsbHkgd2UgY2FuJ3QgZG8gYW55dGhpbmcgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdGhpbmcgc28ganVzdCBkaWVcbiAgICAgICAgICAgICAgICBlcnJvclJlcG9ydGVyLnJlcG9ydEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb246IFwiTm8gc2l0ZUlkIGFuZCBubyBjb250YWluZXIgcGFzc2VkIGluIG9uIGluaXQoKVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY2xlYXJGdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGVsZXRlIHRhZ01hbmFnZXIuY29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKGVycm9yUmVwb3J0ZXIpIHtcbiAgICAgICAgICAgICAgICBlcnJvclJlcG9ydGVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWdNYW5hZ2VyLm1haW5ESVYuZW1wdHkoKTtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nVGFnQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdUYWdDb2xsZWN0aW9uLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmF0dGFjaGVkRXZlbnRzQ29udHJvbGxlci5jbGVhcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlc2V0RnVuY3Rpb24gPSBmdW5jdGlvbihzaXRlSWRPckNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGFnTWFuYWdlci5jbGVhcigpO1xuICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChzaXRlSWRPckNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICB0YWdNYW5hZ2VyLmNvbnRhaW5lciA9IHNpdGVJZE9yQ29udGFpbmVyO1xuICAgICAgICAgICAgICAgIHRhZ01hbmFnZXIuaW5pdChzaXRlSWRPckNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc1N0cmluZyhzaXRlSWRPckNvbnRhaW5lcikpIHtcblxuICAgICAgICAgICAgICAgIC8vIGl0J3MgYSBzaXRlIGlkIHBhc3NlZCBpblxuICAgICAgICAgICAgICAgIHRhZ01hbmFnZXIuaW5pdChzaXRlSWRPckNvbnRhaW5lcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoc2l0ZUlkKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gaXQncyBub3RoaW5nIHBhc3NlZCBpbiB1c2Ugb3VyIFNpdGUgSWRcbiAgICAgICAgICAgICAgICB0YWdNYW5hZ2VyLmluaXQoc2l0ZUlkKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RISU5HIHBhc3NlZCBpbi4uLiBubyByZXNldC5cbiAgICAgICAgICAgICAgICBlcnJvclJlcG9ydGVyLnJlcG9ydEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgbXNnOiBcIlVuYWJsZSB0byByZXNldCwgbm8gc2l0ZUlkIG9yIGNvbnRhaW5lclwiLFxuICAgICAgICAgICAgICAgICAgICBvYmo6IFwibWFpbiBjdG0uanMsIGluIHRoZSByZXNldCBmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgZGl2IHRvIHB1dCB0aGluZ3MgaW50b1xuICAgICAgICBpZiAoIXRhZ01hbmFnZXIubWFpbkRJVikge1xuICAgICAgICAgICAgdGFnTWFuYWdlci5tYWluRElWID0gcmVxdWlyZShcIi4vZG9tL01haW5ESVZcIikoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhbiBpbml0IGZ1bmNpdG9uXG4gICAgICAgIGlmICghdGFnTWFuYWdlci5pbml0KSB7XG4gICAgICAgICAgICB0YWdNYW5hZ2VyLmluaXQgPSBpbml0RnVuY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSBjbGVhciBmdW5jaXRvblxuICAgICAgICBpZiAoIXRhZ01hbmFnZXIuY2xlYXIpIHtcbiAgICAgICAgICAgIHRhZ01hbmFnZXIuY2xlYXIgPSBjbGVhckZ1bmN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgcmVzZXQgZnVuY2l0b25cbiAgICAgICAgaWYgKCF0YWdNYW5hZ2VyLnJlc2V0KSB7XG4gICAgICAgICAgICB0YWdNYW5hZ2VyLnJlc2V0ID0gcmVzZXRGdW5jdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhIGNvbnRhaW5lciBvYmplY3RcbiAgICAgICAgaWYgKCF0YWdNYW5hZ2VyLmNvbnRhaW5lcikge1xuXG4gICAgICAgICAgICAvLyBhc3N1bWUgd2UncmUgZ29pbmcgb2ZmIG9mIG91ciBzaXRlSWQgYW5kIGdldCB0aGF0XG4gICAgICAgICAgICBzaXRlSWQgPSBnZXRTaXRlSWQoKTtcblxuICAgICAgICAgICAgLy8gaWYgd2Ugc3VjY2Vzc2Z1bGx5IGdvdCB0aGUgc2l0ZUlkIGZyb20gb3VyIHNjcmlwdCBzcmMgdGFnXG4gICAgICAgICAgICBpZiAoXy5pc1NldChzaXRlSWQpKSB7XG5cbiAgICAgICAgICAgICAgICB0YWdNYW5hZ2VyLnNpdGVJZCA9IHNpdGVJZDtcblxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxpemUgb3VyIHRhZ3Mgd2l0aCBhIHNpdGVJZFxuICAgICAgICAgICAgICAgIHRhZ01hbmFnZXIuaW5pdChzaXRlSWQpO1xuXG4gICAgICAgICAgICB9IC8vIGVsc2Ugc2l0IGlkbGUgYmVjYXVzZSB3ZSdyZSBleHBlY3RpbmcgdG8gYmUgaW5pdHRlZCBmcm9tIHRoZSBvdXRzaWRlXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIFdlIGRvIGhhdmUgYSBjb250YWluZXIsIHNvIHdlIHJ1biB3aXRoIHRoYXQgYW5kIGRvbid0IGNhbGwgdGhlIHNlcnZlclxuICAgICAgICAgICAgdGFnTWFuYWdlci5pbml0KHRhZ01hbmFnZXIuY29udGFpbmVyKTtcblxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoY2F0Y2hBbGxFcnJvcikge1xuXG4gICAgICAgIGNudnIgPSB3LmNvbnZlcnNhbnQgPSB3LmNvbnZlcnNhbnQgfHwge307XG4gICAgICAgIGNudnIgPSBjbnZyLnRhZ01hbmFnZXIgPSBjbnZyLnRhZ01hbmFnZXIgfHwge307XG4gICAgICAgIGNudnIgPSBjbnZyLmVycm9ycyA9IGNudnIuZXJyb3JzIHx8IFtdO1xuXG4gICAgICAgIGNudnIucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIkNhdGNoIEFsbCBFcnJvclwiLFxuICAgICAgICAgICAgZXJyb3I6IGNhdGNoQWxsRXJyb3JcbiAgICAgICAgfSk7XG5cbiAgICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9jdG0uanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n")},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, white: true, vars:true, nomen:true, plusplus:true  */\n/*global module, exports, require */\n\nmodule.exports = function() {\n  var self = this;\n\n  var _ = __webpack_require__(0);\n  var BinaryTreeNode = __webpack_require__(31);\n  var infixToPostfix = __webpack_require__(51);\n\n  var postfixAr;\n  var stack = [];\n\n  var walkTree = function(bTree) {\n\n    var retr;\n    var leftSideValue;\n    var rightSideValue;\n\n    // if we have an operator\n    if (bTree.value === "&&" || bTree.value === "||") {\n\n      // it\'s a branch\n      // Start with walking the left side and this should return a boolean\n      leftSideValue = walkTree(bTree.left);\n\n      // if this value is an operator and our left value is false we know\n      // it\'s going to be false because it\'s an \'and\'. false AND anything\n      // false\n      if (!leftSideValue && bTree.value === "&&") {\n        retr = false;\n\n        // if the left side is true and we are an OR operator, then we know\n        // that we evaluate to true, because have at least one condition is\n        // true\n      } else if (leftSideValue && bTree.value === "||") {\n        retr = true;\n\n        // In this case, there is no shortcut so we have to look at the right\n        // side to see it\'s value.\n      } else {\n        rightSideValue = walkTree(bTree.right);\n\n        // Evaluate both sides based on the operator\n        switch (bTree.value) {\n          case "&&":\n            retr = (leftSideValue && rightSideValue);\n            break;\n          case "||":\n            retr = (leftSideValue || rightSideValue);\n            break;\n        }\n      }\n    } else {\n      // it\'s a leaf\n      retr = (bTree.value === "true");\n    }\n    return retr;\n  };\n  var buildStack = function() {\n\n    var newNode;\n    var i;\n\n    // Loop through all of our tokens\n    for (i = 0; i < postfixAr.length; i++) {\n\n      // create a new binary tree node for our token and passing\n      // it to the constructor sets the value of that node to what\n      // we pass.  If it\'s a boolean, it\'s a leaf if it\'s an\n      // operator then we\'ll set that and do more work.\n      newNode = new BinaryTreeNode((postfixAr[i]));\n\n      // It\'s an operator, so we\'ll set the left and right values\n      // by taking the last two items of the stack\n      switch (postfixAr[i]) {\n        case "&&":\n        case "||":\n          newNode.right = stack.pop();\n          newNode.left = stack.pop();\n          break;\n      }\n\n      // push our new node to the stack\n      stack.push(newNode);\n    }\n  };\n\n  // Builds the Binary tree and sets the value. expects a postfix\n  // binary expression\n  self.setPostfixBinaryExp = function(exp) {\n    if (_.isString(exp)) {\n      postfixAr = exp.split(" ");\n      postfixAr = _.without(postfixAr, "");\n    } else if (_.isArray(exp)) {\n      postfixAr = exp;\n      buildStack();\n    } else {\n      throw new Error("Incorrect format for binary expression passed to setPostfixBinaryExp");\n    }\n  };\n\n  // In case you have an infix notation this will convert it to\n  // postfix and call the setPostfixBinaryExp\n  self.setInfixBindaryExp = function(exp) {\n    self.setPostfixBinaryExp(infixToPostfix(exp));\n  };\n\n  // Returns a boolean result of our expression\n  self.getResult = function() {\n    return walkTree(stack.pop());\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9CaW5hcnlFeHByZXNzaW9uRXZhbHVhdG9yLmpzP2JkOTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsbUJBQU8sQ0FBQyxDQUFZO0FBQzlCLHVCQUF1QixtQkFBTyxDQUFDLEVBQWtCO0FBQ2pELHVCQUF1QixtQkFBTyxDQUFDLEVBQXlCOztBQUV4RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxzQkFBc0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCB2YXJzOnRydWUsIG5vbWVuOnRydWUsIHBsdXNwbHVzOnRydWUgICovXG4vKmdsb2JhbCBtb2R1bGUsIGV4cG9ydHMsIHJlcXVpcmUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG4gIHZhciBCaW5hcnlUcmVlTm9kZSA9IHJlcXVpcmUoXCIuL0JpbmFyeVRyZWVOb2RlXCIpO1xuICB2YXIgaW5maXhUb1Bvc3RmaXggPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5maXhUb1Bvc3RmaXhcIik7XG5cbiAgdmFyIHBvc3RmaXhBcjtcbiAgdmFyIHN0YWNrID0gW107XG5cbiAgdmFyIHdhbGtUcmVlID0gZnVuY3Rpb24oYlRyZWUpIHtcblxuICAgIHZhciByZXRyO1xuICAgIHZhciBsZWZ0U2lkZVZhbHVlO1xuICAgIHZhciByaWdodFNpZGVWYWx1ZTtcblxuICAgIC8vIGlmIHdlIGhhdmUgYW4gb3BlcmF0b3JcbiAgICBpZiAoYlRyZWUudmFsdWUgPT09IFwiJiZcIiB8fCBiVHJlZS52YWx1ZSA9PT0gXCJ8fFwiKSB7XG5cbiAgICAgIC8vIGl0J3MgYSBicmFuY2hcbiAgICAgIC8vIFN0YXJ0IHdpdGggd2Fsa2luZyB0aGUgbGVmdCBzaWRlIGFuZCB0aGlzIHNob3VsZCByZXR1cm4gYSBib29sZWFuXG4gICAgICBsZWZ0U2lkZVZhbHVlID0gd2Fsa1RyZWUoYlRyZWUubGVmdCk7XG5cbiAgICAgIC8vIGlmIHRoaXMgdmFsdWUgaXMgYW4gb3BlcmF0b3IgYW5kIG91ciBsZWZ0IHZhbHVlIGlzIGZhbHNlIHdlIGtub3dcbiAgICAgIC8vIGl0J3MgZ29pbmcgdG8gYmUgZmFsc2UgYmVjYXVzZSBpdCdzIGFuICdhbmQnLiBmYWxzZSBBTkQgYW55dGhpbmdcbiAgICAgIC8vIGZhbHNlXG4gICAgICBpZiAoIWxlZnRTaWRlVmFsdWUgJiYgYlRyZWUudmFsdWUgPT09IFwiJiZcIikge1xuICAgICAgICByZXRyID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgdGhlIGxlZnQgc2lkZSBpcyB0cnVlIGFuZCB3ZSBhcmUgYW4gT1Igb3BlcmF0b3IsIHRoZW4gd2Uga25vd1xuICAgICAgICAvLyB0aGF0IHdlIGV2YWx1YXRlIHRvIHRydWUsIGJlY2F1c2UgaGF2ZSBhdCBsZWFzdCBvbmUgY29uZGl0aW9uIGlzXG4gICAgICAgIC8vIHRydWVcbiAgICAgIH0gZWxzZSBpZiAobGVmdFNpZGVWYWx1ZSAmJiBiVHJlZS52YWx1ZSA9PT0gXCJ8fFwiKSB7XG4gICAgICAgIHJldHIgPSB0cnVlO1xuXG4gICAgICAgIC8vIEluIHRoaXMgY2FzZSwgdGhlcmUgaXMgbm8gc2hvcnRjdXQgc28gd2UgaGF2ZSB0byBsb29rIGF0IHRoZSByaWdodFxuICAgICAgICAvLyBzaWRlIHRvIHNlZSBpdCdzIHZhbHVlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmlnaHRTaWRlVmFsdWUgPSB3YWxrVHJlZShiVHJlZS5yaWdodCk7XG5cbiAgICAgICAgLy8gRXZhbHVhdGUgYm90aCBzaWRlcyBiYXNlZCBvbiB0aGUgb3BlcmF0b3JcbiAgICAgICAgc3dpdGNoIChiVHJlZS52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgXCImJlwiOlxuICAgICAgICAgICAgcmV0ciA9IChsZWZ0U2lkZVZhbHVlICYmIHJpZ2h0U2lkZVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ8fFwiOlxuICAgICAgICAgICAgcmV0ciA9IChsZWZ0U2lkZVZhbHVlIHx8IHJpZ2h0U2lkZVZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGl0J3MgYSBsZWFmXG4gICAgICByZXRyID0gKGJUcmVlLnZhbHVlID09PSBcInRydWVcIik7XG4gICAgfVxuICAgIHJldHVybiByZXRyO1xuICB9O1xuICB2YXIgYnVpbGRTdGFjayA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIG5ld05vZGU7XG4gICAgdmFyIGk7XG5cbiAgICAvLyBMb29wIHRocm91Z2ggYWxsIG9mIG91ciB0b2tlbnNcbiAgICBmb3IgKGkgPSAwOyBpIDwgcG9zdGZpeEFyLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIC8vIGNyZWF0ZSBhIG5ldyBiaW5hcnkgdHJlZSBub2RlIGZvciBvdXIgdG9rZW4gYW5kIHBhc3NpbmdcbiAgICAgIC8vIGl0IHRvIHRoZSBjb25zdHJ1Y3RvciBzZXRzIHRoZSB2YWx1ZSBvZiB0aGF0IG5vZGUgdG8gd2hhdFxuICAgICAgLy8gd2UgcGFzcy4gIElmIGl0J3MgYSBib29sZWFuLCBpdCdzIGEgbGVhZiBpZiBpdCdzIGFuXG4gICAgICAvLyBvcGVyYXRvciB0aGVuIHdlJ2xsIHNldCB0aGF0IGFuZCBkbyBtb3JlIHdvcmsuXG4gICAgICBuZXdOb2RlID0gbmV3IEJpbmFyeVRyZWVOb2RlKChwb3N0Zml4QXJbaV0pKTtcblxuICAgICAgLy8gSXQncyBhbiBvcGVyYXRvciwgc28gd2UnbGwgc2V0IHRoZSBsZWZ0IGFuZCByaWdodCB2YWx1ZXNcbiAgICAgIC8vIGJ5IHRha2luZyB0aGUgbGFzdCB0d28gaXRlbXMgb2YgdGhlIHN0YWNrXG4gICAgICBzd2l0Y2ggKHBvc3RmaXhBcltpXSkge1xuICAgICAgICBjYXNlIFwiJiZcIjpcbiAgICAgICAgY2FzZSBcInx8XCI6XG4gICAgICAgICAgbmV3Tm9kZS5yaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgIG5ld05vZGUubGVmdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBwdXNoIG91ciBuZXcgbm9kZSB0byB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLnB1c2gobmV3Tm9kZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEJ1aWxkcyB0aGUgQmluYXJ5IHRyZWUgYW5kIHNldHMgdGhlIHZhbHVlLiBleHBlY3RzIGEgcG9zdGZpeFxuICAvLyBiaW5hcnkgZXhwcmVzc2lvblxuICBzZWxmLnNldFBvc3RmaXhCaW5hcnlFeHAgPSBmdW5jdGlvbihleHApIHtcbiAgICBpZiAoXy5pc1N0cmluZyhleHApKSB7XG4gICAgICBwb3N0Zml4QXIgPSBleHAuc3BsaXQoXCIgXCIpO1xuICAgICAgcG9zdGZpeEFyID0gXy53aXRob3V0KHBvc3RmaXhBciwgXCJcIik7XG4gICAgfSBlbHNlIGlmIChfLmlzQXJyYXkoZXhwKSkge1xuICAgICAgcG9zdGZpeEFyID0gZXhwO1xuICAgICAgYnVpbGRTdGFjaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3QgZm9ybWF0IGZvciBiaW5hcnkgZXhwcmVzc2lvbiBwYXNzZWQgdG8gc2V0UG9zdGZpeEJpbmFyeUV4cFwiKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSW4gY2FzZSB5b3UgaGF2ZSBhbiBpbmZpeCBub3RhdGlvbiB0aGlzIHdpbGwgY29udmVydCBpdCB0b1xuICAvLyBwb3N0Zml4IGFuZCBjYWxsIHRoZSBzZXRQb3N0Zml4QmluYXJ5RXhwXG4gIHNlbGYuc2V0SW5maXhCaW5kYXJ5RXhwID0gZnVuY3Rpb24oZXhwKSB7XG4gICAgc2VsZi5zZXRQb3N0Zml4QmluYXJ5RXhwKGluZml4VG9Qb3N0Zml4KGV4cCkpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBib29sZWFuIHJlc3VsdCBvZiBvdXIgZXhwcmVzc2lvblxuICBzZWxmLmdldFJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB3YWxrVHJlZShzdGFjay5wb3AoKSk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZGF0YS9CaW5hcnlFeHByZXNzaW9uRXZhbHVhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30\n')},function(module,exports){eval("/*jslint browser: true, sloppy: true, white: true, vars:true, nomen:true  */\n/*global module */\n\nmodule.exports = function(val) {\n  var self = this;\n\n  self.value = val;\n  self.left = null;\n  self.right = null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9CaW5hcnlUcmVlTm9kZS5qcz80YTQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIHZhcnM6dHJ1ZSwgbm9tZW46dHJ1ZSAgKi9cbi8qZ2xvYmFsIG1vZHVsZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgc2VsZi52YWx1ZSA9IHZhbDtcbiAgc2VsZi5sZWZ0ID0gbnVsbDtcbiAgc2VsZi5yaWdodCA9IG51bGw7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZGF0YS9CaW5hcnlUcmVlTm9kZS5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31\n")},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, exports, require */\n\nmodule.exports = function(data) {\n\n    var _ = __webpack_require__(0);\n    var TokenReplacer = __webpack_require__(4);\n    var LogicalExpressionEvaluator = __webpack_require__(36);\n\n    // `parseExpression`: function to evaluate a standard conditon object and return true or false\n    // 1. `condition`: standard condition object\n    var parseExpression = function(condition) {\n\n        var a = condition.a;\n        var b = condition.b;\n        var comparator = condition.comparator;\n        var returnValue;\n\n        switch (comparator) {\n\n            case 'regEx':\n                returnValue = _.convertRegExp(a).test(b);\n                break;\n\n            case '!regEx':\n                returnValue = !(_.convertRegExp(a).test(b));\n                break;\n\n            case 'def':\n                a = a || undefined;\n                returnValue = !_.isUndefined(a);\n                break;\n\n            case 'unDef':\n                a = a || undefined;\n                returnValue = _.isUndefined(a);\n                break;\n\n            case '===':\n                returnValue = (a === b);\n                break;\n\n            case '!==':\n                returnValue = (a !== b);\n                break;\n\n            case '>=':\n                returnValue = (a >= b);\n                break;\n\n            case '<=':\n                returnValue = (a <= b);\n                break;\n\n            case '>':\n                returnValue = (a > b);\n                break;\n\n            case '<':\n                returnValue = (a < b);\n                break;\n        }\n        return returnValue;\n    };\n\n    // `interpretedConditions` holds an interpreted version of the conditions\n    var interpretedConditions = [];\n\n    // `tokenReplacer` instance to resolve data tokens\n    var tokenReplacer = new TokenReplacer(data);\n\n    // **Public Methods**\n    // `.run()`: Function for evaluating the conditons of a tag\n    // 1. `conditions`: a standard condtions object\n    // 2. `map`: a standard conditon map\n    this.run = function(conditions, map) {\n        var lee, allConditionsResult = true;\n\n        interpretedConditions = [];\n\n        if (_.isArray(conditions)) {\n            _.each(conditions, function(condition) {\n                var workingObj = _.extend({}, condition);\n\n                interpretedConditions.push(workingObj);\n\n                // If we don't have a result already, then we'll evaluate the condition\n                // if we already have a result, there is no reason to re-evaluate\n                if (_.isUndefined(workingObj.result)) {\n\n                    // loop through the keys we care about and shove those into the return object\n                    // safely interpreted\n                    _.each([\"a\", \"b\"], function(key) {\n                        if (_.isObject(workingObj[key]) && _.isString(workingObj[key].interp)) {\n                            workingObj[key] = tokenReplacer.replace(workingObj[key].interp);\n                        }\n                    });\n                    workingObj.result = parseExpression(workingObj);\n                }\n            });\n\n            // if there's only one condition we just return the result of that\n            if (interpretedConditions.length === 1) {\n                allConditionsResult = interpretedConditions[0].result;\n\n                // if there's no map we assume it's the result of all of them being true\n            } else if (_.isUndefined(map)) {\n                allConditionsResult = _.chain(interpretedConditions).pluck(\"result\").every().value();\n\n                // the real deal, we have a condtion map and there is more than one condition\n            } else {\n                lee = new LogicalExpressionEvaluator(map, _.pluck(interpretedConditions, \"result\"));\n                allConditionsResult = lee.result();\n            }\n        }\n        return allConditionsResult;\n    };\n\n    // `.get()`: returns the interpreted conditons for use in a notice object\n    this.get = function() {\n        return interpretedConditions;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9Db25kaXRpb25zLmpzPzA3NDUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsQ0FBWTtBQUNoQyx3QkFBd0IsbUJBQU8sQ0FBQyxDQUFpQjtBQUNqRCxxQ0FBcUMsbUJBQU8sQ0FBQyxFQUE4Qjs7QUFFM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIG5vbWVuOiB0cnVlLCByZWdleHA6IHRydWUsIHZhcnM6dHJ1ZSwgcGx1c3BsdXM6dHJ1ZSAqL1xuLypnbG9iYWwgbW9kdWxlLCBleHBvcnRzLCByZXF1aXJlICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgdmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbiAgICB2YXIgVG9rZW5SZXBsYWNlciA9IHJlcXVpcmUoXCIuL1Rva2VuUmVwbGFjZXJcIik7XG4gICAgdmFyIExvZ2ljYWxFeHByZXNzaW9uRXZhbHVhdG9yID0gcmVxdWlyZShcIi4vTG9naWNhbEV4cHJlc3Npb25FdmFsdWF0b3JcIik7XG5cbiAgICAvLyBgcGFyc2VFeHByZXNzaW9uYDogZnVuY3Rpb24gdG8gZXZhbHVhdGUgYSBzdGFuZGFyZCBjb25kaXRvbiBvYmplY3QgYW5kIHJldHVybiB0cnVlIG9yIGZhbHNlXG4gICAgLy8gMS4gYGNvbmRpdGlvbmA6IHN0YW5kYXJkIGNvbmRpdGlvbiBvYmplY3RcbiAgICB2YXIgcGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24oY29uZGl0aW9uKSB7XG5cbiAgICAgICAgdmFyIGEgPSBjb25kaXRpb24uYTtcbiAgICAgICAgdmFyIGIgPSBjb25kaXRpb24uYjtcbiAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSBjb25kaXRpb24uY29tcGFyYXRvcjtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlO1xuXG4gICAgICAgIHN3aXRjaCAoY29tcGFyYXRvcikge1xuXG4gICAgICAgICAgICBjYXNlICdyZWdFeCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBfLmNvbnZlcnRSZWdFeHAoYSkudGVzdChiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnIXJlZ0V4JzpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9ICEoXy5jb252ZXJ0UmVnRXhwKGEpLnRlc3QoYikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdkZWYnOlxuICAgICAgICAgICAgICAgIGEgPSBhIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9ICFfLmlzVW5kZWZpbmVkKGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd1bkRlZic6XG4gICAgICAgICAgICAgICAgYSA9IGEgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gXy5pc1VuZGVmaW5lZChhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnPT09JzpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IChhID09PSBiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IChhICE9PSBiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gKGEgPj0gYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJzw9JzpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IChhIDw9IGIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IChhID4gYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gKGEgPCBiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfTtcblxuICAgIC8vIGBpbnRlcnByZXRlZENvbmRpdGlvbnNgIGhvbGRzIGFuIGludGVycHJldGVkIHZlcnNpb24gb2YgdGhlIGNvbmRpdGlvbnNcbiAgICB2YXIgaW50ZXJwcmV0ZWRDb25kaXRpb25zID0gW107XG5cbiAgICAvLyBgdG9rZW5SZXBsYWNlcmAgaW5zdGFuY2UgdG8gcmVzb2x2ZSBkYXRhIHRva2Vuc1xuICAgIHZhciB0b2tlblJlcGxhY2VyID0gbmV3IFRva2VuUmVwbGFjZXIoZGF0YSk7XG5cbiAgICAvLyAqKlB1YmxpYyBNZXRob2RzKipcbiAgICAvLyBgLnJ1bigpYDogRnVuY3Rpb24gZm9yIGV2YWx1YXRpbmcgdGhlIGNvbmRpdG9ucyBvZiBhIHRhZ1xuICAgIC8vIDEuIGBjb25kaXRpb25zYDogYSBzdGFuZGFyZCBjb25kdGlvbnMgb2JqZWN0XG4gICAgLy8gMi4gYG1hcGA6IGEgc3RhbmRhcmQgY29uZGl0b24gbWFwXG4gICAgdGhpcy5ydW4gPSBmdW5jdGlvbihjb25kaXRpb25zLCBtYXApIHtcbiAgICAgICAgdmFyIGxlZSwgYWxsQ29uZGl0aW9uc1Jlc3VsdCA9IHRydWU7XG5cbiAgICAgICAgaW50ZXJwcmV0ZWRDb25kaXRpb25zID0gW107XG5cbiAgICAgICAgaWYgKF8uaXNBcnJheShjb25kaXRpb25zKSkge1xuICAgICAgICAgICAgXy5lYWNoKGNvbmRpdGlvbnMsIGZ1bmN0aW9uKGNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciB3b3JraW5nT2JqID0gXy5leHRlbmQoe30sIGNvbmRpdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpbnRlcnByZXRlZENvbmRpdGlvbnMucHVzaCh3b3JraW5nT2JqKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSByZXN1bHQgYWxyZWFkeSwgdGhlbiB3ZSdsbCBldmFsdWF0ZSB0aGUgY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgcmVzdWx0LCB0aGVyZSBpcyBubyByZWFzb24gdG8gcmUtZXZhbHVhdGVcbiAgICAgICAgICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZCh3b3JraW5nT2JqLnJlc3VsdCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIGtleXMgd2UgY2FyZSBhYm91dCBhbmQgc2hvdmUgdGhvc2UgaW50byB0aGUgcmV0dXJuIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAvLyBzYWZlbHkgaW50ZXJwcmV0ZWRcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKFtcImFcIiwgXCJiXCJdLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLmlzT2JqZWN0KHdvcmtpbmdPYmpba2V5XSkgJiYgXy5pc1N0cmluZyh3b3JraW5nT2JqW2tleV0uaW50ZXJwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdPYmpba2V5XSA9IHRva2VuUmVwbGFjZXIucmVwbGFjZSh3b3JraW5nT2JqW2tleV0uaW50ZXJwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmtpbmdPYmoucmVzdWx0ID0gcGFyc2VFeHByZXNzaW9uKHdvcmtpbmdPYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSdzIG9ubHkgb25lIGNvbmRpdGlvbiB3ZSBqdXN0IHJldHVybiB0aGUgcmVzdWx0IG9mIHRoYXRcbiAgICAgICAgICAgIGlmIChpbnRlcnByZXRlZENvbmRpdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYWxsQ29uZGl0aW9uc1Jlc3VsdCA9IGludGVycHJldGVkQ29uZGl0aW9uc1swXS5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIG5vIG1hcCB3ZSBhc3N1bWUgaXQncyB0aGUgcmVzdWx0IG9mIGFsbCBvZiB0aGVtIGJlaW5nIHRydWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc1VuZGVmaW5lZChtYXApKSB7XG4gICAgICAgICAgICAgICAgYWxsQ29uZGl0aW9uc1Jlc3VsdCA9IF8uY2hhaW4oaW50ZXJwcmV0ZWRDb25kaXRpb25zKS5wbHVjayhcInJlc3VsdFwiKS5ldmVyeSgpLnZhbHVlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVhbCBkZWFsLCB3ZSBoYXZlIGEgY29uZHRpb24gbWFwIGFuZCB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIGNvbmRpdGlvblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZWUgPSBuZXcgTG9naWNhbEV4cHJlc3Npb25FdmFsdWF0b3IobWFwLCBfLnBsdWNrKGludGVycHJldGVkQ29uZGl0aW9ucywgXCJyZXN1bHRcIikpO1xuICAgICAgICAgICAgICAgIGFsbENvbmRpdGlvbnNSZXN1bHQgPSBsZWUucmVzdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbENvbmRpdGlvbnNSZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIGAuZ2V0KClgOiByZXR1cm5zIHRoZSBpbnRlcnByZXRlZCBjb25kaXRvbnMgZm9yIHVzZSBpbiBhIG5vdGljZSBvYmplY3RcbiAgICB0aGlzLmdldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW50ZXJwcmV0ZWRDb25kaXRpb25zO1xuICAgIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZGF0YS9Db25kaXRpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n")},function(module,exports,__webpack_require__){eval("module.exports = function() {\n\n    var _ = __webpack_require__(0);\n    var $ = __webpack_require__(1);\n    var ProcessWith = __webpack_require__(37);\n\n    __webpack_require__(7)();\n    __webpack_require__(10)();\n\n    // Calculated unprocessed raw data\n    var rawData = [];\n    var dataDef;\n\n    // Flag to only parse dataDef once\n    var dataIsSet = false;\n\n    // For easy substituting of attribte.src when it is calculate\n    var indicesOfGetTagSrc = [];\n\n    // Function that turns the cookie string to a object. the cookieString is\n    // a string formatted like document.cookie in a standard browser\n    var parseCookies = function(cookieString) {\n\n        // Perform several operations on the cookieString: First split the string\n        // on semicolon denoting a separation in key value pairs. We should now have\n        // an array that looks like [\"key=value\",\"key2=value2\"] then create a two\n        // dimensional array of of those with our map by splitting the pair on the\n        // '='.  So our array should look like [['key','value'],['key2','value2']]\n        // then use underscore's object function to convert that to an object that\n        // will look like {key:'value', key2:'value2'}\n        return _.chain(cookieString.split('; ')).map(function(pair) {\n            return pair.split(\"=\");\n        }).object().value();\n    };\n\n    // Function that turns the search (query) string to a hash the searchString\n    // is a string formatted like window.location.search in a standard browser\n    var parseSearch = function(searchString) {\n\n        // Regex needed to separate query string if using '&'\n        var ampersandSeparator = /([^&=]+)=?([^&]*)/g,\n\n            // Regex needed to separate query string if using ';'\n            semiColonSeparator = /([^;=]+)=?([^;]*)/g,\n\n            // If there is an '&' in the queryString, assume it is separated by it,\n            // otherwise use \";\" as the separator\n            separator = (searchString.indexOf(\"&\") === -1) ? semiColonSeparator : ampersandSeparator,\n\n            // Used to make Seach Parameters evaluation compatible with some servers\n            // element is an array of 1 or maore values\n            cleanSearchParamsArray = function(element) {\n                if (element.length === 1) {\n                    element = element[0];\n                }\n            },\n\n            // Function to and replace the \"+'s\". 'string' is Probably the part of\n            // a query string between the '=' and the next '&'\n            decode = function(string) {\n\n                // First replace our +'s with blanks\n                var retr = string.replace(/\\+/g, \" \");\n\n                // Decode and return the encoding\n                return decodeURIComponent(retr);\n            },\n            keepLooping = true,\n            searchParams = {},\n            searchParamsArray = {},\n            i;\n\n        // knock off the leading '?'\n        searchString = searchString.substring(1);\n\n        while (keepLooping) {\n\n            i = separator.exec(searchString);\n            if (i) {\n\n                // Load the searchParams cache used for dataType: 'string'\n                searchParams[decode(i[1])] = decode(i[2]);\n\n                // Load the searchParamsArray cache used for dataType: 'array'\n                // We have these two options to mimick two common server behaviors\n                if (!_.isArray(searchParamsArray[decode(i[1])])) {\n                    searchParamsArray[decode(i[1])] = [];\n                }\n                searchParamsArray[decode(i[1])].push(decode(i[2]));\n\n            } else {\n\n                // nothing more, break the loop\n                keepLooping = false;\n\n                // Clean up the SearchParamsArray cache to convert arrays of length=1 to strings\n                _.each(searchParamsArray, cleanSearchParamsArray);\n            }\n        }\n        return {\n            s: searchParams,\n            a: searchParamsArray\n        };\n    };\n\n    // Function for processing each element in a dataDef that returns a value of any type.\n    // If processing fails, it returns undefined. dataElement is an individual dataDef\n    // Element, including processWiths. index is t he dataElement index, used to pre-tag\n    // get->tagSrc for later\n    var processType = function(dataElement, index, cookies, search) {\n\n        // is defaulted to undefined if processing fails\n        var returnValue, type = dataElement.type;\n        var value = dataElement.value;\n        var processWith;\n        var processWithSpec = dataElement.processWith;\n        var dataType = dataElement.dataType || 'string';\n        var $selector;\n        var cookieValue;\n\n        try {\n            switch (type) {\n\n                // returns the value of what is stored in the variable.  This can be an array\n                case 'obj':\n\n                    // replace all '[' with '.' delete all ']' split on \".\" and return an array\n                    value = value.replace(/\\[/g, '.').replace(/\\]/g, '').split('.');\n\n                    // drop the first item if its 'window' as a string and add the actual object\n                    if (value[0] === 'window') {\n\n                        value[0] = window;\n                    } else {\n\n                        // add the window to the beginning\n                        value = _.prependArray(value, window);\n                    }\n\n\n                    // combine using block notation\n                    returnValue = _.reduce(value, function(memo, item) {\n                        return memo[item];\n                    });\n\n                    break;\n\n                    // returns the value of a custom function.  This can be an array. fnc is not publically exposed.\n                case 'fnc':\n\n                    returnValue = eval(value);\n\n                    break;\n\n                    // returns the value in an attribute of a css selector.  It can be a string (where it will get the attr value of the first match) or an array - will it will get all of the attr of all the matches.\n                    // In an `attr`, the value is an array with the first being the selector and the second being the attr.\n                case 'attr':\n\n                    // If the $selector finds anything...\n                    // e.g. the value array contains['div','data'] the following selector creates $(div[data]) - which selects all div's with a data attr.\n                    $selector = $(value[0] + \"[\" + value[1] + \"]\");\n\n                    if ($selector.length) {\n\n                        returnValue = [];\n\n                        // Iterate through all of the values\n                        $selector.each(function() {\n                            returnValue.push($(this).attr(value[1]));\n                        });\n\n                        // If the datatype is a string, use just the first value\n                        if (dataType === 'string') {\n                            returnValue = returnValue[0];\n                        }\n                    }\n                    break;\n\n                    // returns the value of the jquery selection.  Jquery will only return a string based on the first value of a collection.  However, we will return an array based on all matching selectors  if it is indicated\n                case 'css':\n\n                    // If the $selector finds anything...\n                    $selector = $(value);\n\n                    if ($selector.length) {\n\n                        // set returnValue to an array as selectors return arrays\n                        returnValue = [];\n\n                        // Iterate through all of the values\n                        $selector.each(function() {\n\n                            var $this = $(this);\n\n                            //If the selector is anything but these three items, just return the text\n                            if (!$this.is(\"input, select, textarea\")) {\n\n                                returnValue.push($this.text());\n                            } else {\n\n                                switch ($this.attr(\"type\")) {\n\n                                    // If `select` get the selected value\n                                    case 'select':\n\n                                        $this = $this.filter(\":selected\");\n                                        if ($this.length) {\n                                            returnValue.push($this.val());\n                                        }\n\n                                        break;\n\n                                        // If `checkbox` or `radio` get the checked value(s)\n                                    case 'checkbox':\n                                    case 'radio':\n\n                                        $this = $this.filter(\":checked\");\n                                        if ($this.length) {\n                                            returnValue.push($this.val());\n                                        }\n\n                                        break;\n\n                                        // yeah...  No.\n                                    case 'password':\n                                        returnValue.push(undefined);\n                                        break;\n\n                                        // Anything else, just get the value\n                                    default:\n                                        returnValue.push($this.val());\n                                }\n                            }\n                        });\n\n                        // If the datatype is not specifically an array, return just the first value\n                        // This also makes the nonsensical datatype of 'object' work as a string\n                        if (dataType !== 'array') {\n                            returnValue = returnValue[0];\n                        }\n                    }\n\n                    break;\n\n                    // grabs a value from the cookie.  It can only be a string\n                case 'cke':\n\n                    cookieValue = cookies[value];\n\n                    // cookies should always be stored encoded.  We will always decode the value\n                    // or there is no way we can really use it\n                    returnValue = !_.isUndefined(cookieValue) ? decodeURIComponent(cookieValue) : undefined;\n\n                    break;\n\n                    // grabs a value from the `location.search`.  It can only be a string\n                case 'qry':\n\n                    returnValue = dataType === 'string' ? search.s[value] : search.a[value];\n\n                    break;\n\n                    // is set to undefined and then loaded when the value is calculated\n                    //  because we only have a tagSrc to get - we don't bother checking the value\n                case 'get':\n\n                    indicesOfGetTagSrc.push(index);\n\n                    break;\n            }\n\n            // If something blows up, just returned the default - undefined.\n        } catch (ignore) {}\n\n        // We don't use processWith with the \"get\" type\n        if (type !== 'get' && !_.isUndefined(processWithSpec)) {\n            if (!processWith) {\n                processWith = new ProcessWith();\n            }\n            returnValue = processWith.process(returnValue, processWithSpec);\n        }\n\n        // Return our value.\n        return returnValue;\n    };\n\n\n    // Function to make sense of crap data. val can be Virtually anything...\n    // This should turn functions, regexp, undefined, null into empty strings\n    var cleanReturnValue = function(val) {\n\n        var returnValue;\n\n        if (_.isString(val) || _.isNumber(val) || _.isBoolean(val) || _.isFunction(val)) {\n            returnValue = val;\n        }\n\n        // Otherwise we dive into recursion if its a non-empty object or an array\n        else if ((_.isArray(val) && val.length) || (_.isObject(val) && _.size(val))) {\n\n            _.each(val, function(element, indexOrKey, collection) {\n                collection[indexOrKey] = cleanReturnValue(element);\n            });\n\n            returnValue = val;\n\n            // But wait! what if its a date? We want a standard reply\n        } else if (_.isDate(val)) {\n\n            returnValue = val.toISOString();\n        } else {\n\n            //Finally, what if we don't know what it is?  Just return an empty string.\n            returnValue = \"\";\n        }\n        return returnValue;\n    };\n\n    // Function for accessing All values in data elements\n    this.getAll = function() {\n        return rawData;\n    };\n\n    // Function for accessing the Raw value in data elements. The index is the index\n    // of data node needed\n    this.getRaw = function(index) {\n        return rawData[index];\n    };\n\n    // Function for accessing the cleaned value in data elements - converts weird\n    // stuff to empty strings and other odd values to empty strings. The index is\n    // the index of data node needed\n    this.getClean = function(index) {\n        return cleanReturnValue(this.getRaw(index));\n    };\n\n    // Function for returning an array as a nested array for templates. Also,\n    // All strings get wrapped in single quotes. The index is the index of\n    // data node needed\n    this.getMunged = function(index) {\n        var returnValue, val = this.getClean(index);\n\n        if (_.isArray(val)) {\n            returnValue = _.map(val, function(v) {\n                return _.isArray(v) ? v : [v];\n            });\n        } else {\n            returnValue = val;\n        }\n\n        return returnValue;\n    };\n\n    // Function for returning the clean value and URI Encoding it. The index\n    // is the index of data node needed\n    this.getEnc = function(index) {\n        return encodeURIComponent(this.getClean(index));\n    };\n\n    // Function for setting the data directly, by passing the collection of\n    // data via the dataDef.  'data' is the processed rawData needed for a tag\n    this.setData = function(data) {\n        if (!dataIsSet) {\n            dataIsSet = true;\n            rawData = _.cloneArray(data);\n        }\n        return this;\n    };\n\n    // Function for gathering the data based on the dataDef\n    // incomingDataDef is a standard dataDef structured.\n    // overrides is an object consisting of cookie and search\n    // override strings for testing purposes\n    this.setDataDef = function(incomingDataDef, overrides) {\n\n        // The normal place to find these values\n        var sources = {\n            cookie: document.cookie,\n            search: window.location.search\n        };\n        var cookies = {};\n\n        // object that holds a string and array version of search params, depending on server need.\n        // Sorry, attributes kept short for minification reasons...\n        var search;\n\n        if (overrides) {\n            _.extend(sources, overrides || {});\n        }\n\n        // If we haven't laded data yet...\n        if (!dataIsSet) {\n\n            // Clone the dataDef, so we don't modify the original\n            dataDef = _.cloneArray(incomingDataDef);\n\n            // Set the flag so we don't set data again\n            dataIsSet = true;\n\n            // safely parse cookies and search string;\n            try {\n\n                cookies = parseCookies(sources.cookie);\n            } catch (ignore) {}\n\n            try {\n                search = parseSearch(sources.search);\n            } catch (ignore) {}\n\n            // Iterate through each dataElement in the DataDef\n            _.each(dataDef, function(dataElement, index) {\n                rawData.push(processType(dataElement, index, cookies, search));\n            });\n        }\n        return this;\n    };\n    // `.setTagSrc()`: Function for updating the value of the tagSrc in rawData, once calculated\n    // 1. `tagSrc`: The calculated tagSrc.\n    this.setTagSrc = function(tagSrc) {\n        _.each(indicesOfGetTagSrc, function(value) {\n            rawData[value] = tagSrc;\n        });\n    };\n    return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9EYXRhLmpzPzk0YTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLENBQVk7QUFDaEMsWUFBWSxtQkFBTyxDQUFDLENBQU87QUFDM0Isc0JBQXNCLG1CQUFPLENBQUMsRUFBZTs7QUFFN0MsSUFBSSxtQkFBTyxDQUFDLENBQXdDO0FBQ3BELElBQUksbUJBQU8sQ0FBQyxFQUEwQzs7QUFFdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDRDQUE0QztBQUM1QztBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnRUFBZ0U7QUFDaEUsc0NBQXNDLFVBQVU7O0FBRWhEO0FBQ0EsK0JBQStCO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDZCQUE2QjtBQUM3QixrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCOztBQUU3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuICAgIHZhciAkID0gcmVxdWlyZShcInplcHRvXCIpO1xuICAgIHZhciBQcm9jZXNzV2l0aCA9IHJlcXVpcmUoXCIuL1Byb2Nlc3NXaXRoXCIpO1xuXG4gICAgcmVxdWlyZShcIi4uLy4uL2xpYi91bmRlcnNjb3JlX21peGlucy9jbG9uZUFycmF5XCIpKCk7XG4gICAgcmVxdWlyZShcIi4uLy4uL2xpYi91bmRlcnNjb3JlX21peGlucy9wcmVwZW5kQXJyYXlcIikoKTtcblxuICAgIC8vIENhbGN1bGF0ZWQgdW5wcm9jZXNzZWQgcmF3IGRhdGFcbiAgICB2YXIgcmF3RGF0YSA9IFtdO1xuICAgIHZhciBkYXRhRGVmO1xuXG4gICAgLy8gRmxhZyB0byBvbmx5IHBhcnNlIGRhdGFEZWYgb25jZVxuICAgIHZhciBkYXRhSXNTZXQgPSBmYWxzZTtcblxuICAgIC8vIEZvciBlYXN5IHN1YnN0aXR1dGluZyBvZiBhdHRyaWJ0ZS5zcmMgd2hlbiBpdCBpcyBjYWxjdWxhdGVcbiAgICB2YXIgaW5kaWNlc09mR2V0VGFnU3JjID0gW107XG5cbiAgICAvLyBGdW5jdGlvbiB0aGF0IHR1cm5zIHRoZSBjb29raWUgc3RyaW5nIHRvIGEgb2JqZWN0LiB0aGUgY29va2llU3RyaW5nIGlzXG4gICAgLy8gYSBzdHJpbmcgZm9ybWF0dGVkIGxpa2UgZG9jdW1lbnQuY29va2llIGluIGEgc3RhbmRhcmQgYnJvd3NlclxuICAgIHZhciBwYXJzZUNvb2tpZXMgPSBmdW5jdGlvbihjb29raWVTdHJpbmcpIHtcblxuICAgICAgICAvLyBQZXJmb3JtIHNldmVyYWwgb3BlcmF0aW9ucyBvbiB0aGUgY29va2llU3RyaW5nOiBGaXJzdCBzcGxpdCB0aGUgc3RyaW5nXG4gICAgICAgIC8vIG9uIHNlbWljb2xvbiBkZW5vdGluZyBhIHNlcGFyYXRpb24gaW4ga2V5IHZhbHVlIHBhaXJzLiBXZSBzaG91bGQgbm93IGhhdmVcbiAgICAgICAgLy8gYW4gYXJyYXkgdGhhdCBsb29rcyBsaWtlIFtcImtleT12YWx1ZVwiLFwia2V5Mj12YWx1ZTJcIl0gdGhlbiBjcmVhdGUgYSB0d29cbiAgICAgICAgLy8gZGltZW5zaW9uYWwgYXJyYXkgb2Ygb2YgdGhvc2Ugd2l0aCBvdXIgbWFwIGJ5IHNwbGl0dGluZyB0aGUgcGFpciBvbiB0aGVcbiAgICAgICAgLy8gJz0nLiAgU28gb3VyIGFycmF5IHNob3VsZCBsb29rIGxpa2UgW1sna2V5JywndmFsdWUnXSxbJ2tleTInLCd2YWx1ZTInXV1cbiAgICAgICAgLy8gdGhlbiB1c2UgdW5kZXJzY29yZSdzIG9iamVjdCBmdW5jdGlvbiB0byBjb252ZXJ0IHRoYXQgdG8gYW4gb2JqZWN0IHRoYXRcbiAgICAgICAgLy8gd2lsbCBsb29rIGxpa2Uge2tleTondmFsdWUnLCBrZXkyOid2YWx1ZTInfVxuICAgICAgICByZXR1cm4gXy5jaGFpbihjb29raWVTdHJpbmcuc3BsaXQoJzsgJykpLm1hcChmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFpci5zcGxpdChcIj1cIik7XG4gICAgICAgIH0pLm9iamVjdCgpLnZhbHVlKCk7XG4gICAgfTtcblxuICAgIC8vIEZ1bmN0aW9uIHRoYXQgdHVybnMgdGhlIHNlYXJjaCAocXVlcnkpIHN0cmluZyB0byBhIGhhc2ggdGhlIHNlYXJjaFN0cmluZ1xuICAgIC8vIGlzIGEgc3RyaW5nIGZvcm1hdHRlZCBsaWtlIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggaW4gYSBzdGFuZGFyZCBicm93c2VyXG4gICAgdmFyIHBhcnNlU2VhcmNoID0gZnVuY3Rpb24oc2VhcmNoU3RyaW5nKSB7XG5cbiAgICAgICAgLy8gUmVnZXggbmVlZGVkIHRvIHNlcGFyYXRlIHF1ZXJ5IHN0cmluZyBpZiB1c2luZyAnJidcbiAgICAgICAgdmFyIGFtcGVyc2FuZFNlcGFyYXRvciA9IC8oW14mPV0rKT0/KFteJl0qKS9nLFxuXG4gICAgICAgICAgICAvLyBSZWdleCBuZWVkZWQgdG8gc2VwYXJhdGUgcXVlcnkgc3RyaW5nIGlmIHVzaW5nICc7J1xuICAgICAgICAgICAgc2VtaUNvbG9uU2VwYXJhdG9yID0gLyhbXjs9XSspPT8oW147XSopL2csXG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuICcmJyBpbiB0aGUgcXVlcnlTdHJpbmcsIGFzc3VtZSBpdCBpcyBzZXBhcmF0ZWQgYnkgaXQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgdXNlIFwiO1wiIGFzIHRoZSBzZXBhcmF0b3JcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IChzZWFyY2hTdHJpbmcuaW5kZXhPZihcIiZcIikgPT09IC0xKSA/IHNlbWlDb2xvblNlcGFyYXRvciA6IGFtcGVyc2FuZFNlcGFyYXRvcixcblxuICAgICAgICAgICAgLy8gVXNlZCB0byBtYWtlIFNlYWNoIFBhcmFtZXRlcnMgZXZhbHVhdGlvbiBjb21wYXRpYmxlIHdpdGggc29tZSBzZXJ2ZXJzXG4gICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFuIGFycmF5IG9mIDEgb3IgbWFvcmUgdmFsdWVzXG4gICAgICAgICAgICBjbGVhblNlYXJjaFBhcmFtc0FycmF5ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZWxlbWVudFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBGdW5jdGlvbiB0byBhbmQgcmVwbGFjZSB0aGUgXCIrJ3NcIi4gJ3N0cmluZycgaXMgUHJvYmFibHkgdGhlIHBhcnQgb2ZcbiAgICAgICAgICAgIC8vIGEgcXVlcnkgc3RyaW5nIGJldHdlZW4gdGhlICc9JyBhbmQgdGhlIG5leHQgJyYnXG4gICAgICAgICAgICBkZWNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcblxuICAgICAgICAgICAgICAgIC8vIEZpcnN0IHJlcGxhY2Ugb3VyICsncyB3aXRoIGJsYW5rc1xuICAgICAgICAgICAgICAgIHZhciByZXRyID0gc3RyaW5nLnJlcGxhY2UoL1xcKy9nLCBcIiBcIik7XG5cbiAgICAgICAgICAgICAgICAvLyBEZWNvZGUgYW5kIHJldHVybiB0aGUgZW5jb2RpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHJldHIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtlZXBMb29waW5nID0gdHJ1ZSxcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcyA9IHt9LFxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zQXJyYXkgPSB7fSxcbiAgICAgICAgICAgIGk7XG5cbiAgICAgICAgLy8ga25vY2sgb2ZmIHRoZSBsZWFkaW5nICc/J1xuICAgICAgICBzZWFyY2hTdHJpbmcgPSBzZWFyY2hTdHJpbmcuc3Vic3RyaW5nKDEpO1xuXG4gICAgICAgIHdoaWxlIChrZWVwTG9vcGluZykge1xuXG4gICAgICAgICAgICBpID0gc2VwYXJhdG9yLmV4ZWMoc2VhcmNoU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBzZWFyY2hQYXJhbXMgY2FjaGUgdXNlZCBmb3IgZGF0YVR5cGU6ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgc2VhcmNoUGFyYW1zW2RlY29kZShpWzFdKV0gPSBkZWNvZGUoaVsyXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBMb2FkIHRoZSBzZWFyY2hQYXJhbXNBcnJheSBjYWNoZSB1c2VkIGZvciBkYXRhVHlwZTogJ2FycmF5J1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdGhlc2UgdHdvIG9wdGlvbnMgdG8gbWltaWNrIHR3byBjb21tb24gc2VydmVyIGJlaGF2aW9yc1xuICAgICAgICAgICAgICAgIGlmICghXy5pc0FycmF5KHNlYXJjaFBhcmFtc0FycmF5W2RlY29kZShpWzFdKV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtc0FycmF5W2RlY29kZShpWzFdKV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VhcmNoUGFyYW1zQXJyYXlbZGVjb2RlKGlbMV0pXS5wdXNoKGRlY29kZShpWzJdKSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBub3RoaW5nIG1vcmUsIGJyZWFrIHRoZSBsb29wXG4gICAgICAgICAgICAgICAga2VlcExvb3BpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBTZWFyY2hQYXJhbXNBcnJheSBjYWNoZSB0byBjb252ZXJ0IGFycmF5cyBvZiBsZW5ndGg9MSB0byBzdHJpbmdzXG4gICAgICAgICAgICAgICAgXy5lYWNoKHNlYXJjaFBhcmFtc0FycmF5LCBjbGVhblNlYXJjaFBhcmFtc0FycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgczogc2VhcmNoUGFyYW1zLFxuICAgICAgICAgICAgYTogc2VhcmNoUGFyYW1zQXJyYXlcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gRnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgZWFjaCBlbGVtZW50IGluIGEgZGF0YURlZiB0aGF0IHJldHVybnMgYSB2YWx1ZSBvZiBhbnkgdHlwZS5cbiAgICAvLyBJZiBwcm9jZXNzaW5nIGZhaWxzLCBpdCByZXR1cm5zIHVuZGVmaW5lZC4gZGF0YUVsZW1lbnQgaXMgYW4gaW5kaXZpZHVhbCBkYXRhRGVmXG4gICAgLy8gRWxlbWVudCwgaW5jbHVkaW5nIHByb2Nlc3NXaXRocy4gaW5kZXggaXMgdCBoZSBkYXRhRWxlbWVudCBpbmRleCwgdXNlZCB0byBwcmUtdGFnXG4gICAgLy8gZ2V0LT50YWdTcmMgZm9yIGxhdGVyXG4gICAgdmFyIHByb2Nlc3NUeXBlID0gZnVuY3Rpb24oZGF0YUVsZW1lbnQsIGluZGV4LCBjb29raWVzLCBzZWFyY2gpIHtcblxuICAgICAgICAvLyBpcyBkZWZhdWx0ZWQgdG8gdW5kZWZpbmVkIGlmIHByb2Nlc3NpbmcgZmFpbHNcbiAgICAgICAgdmFyIHJldHVyblZhbHVlLCB0eXBlID0gZGF0YUVsZW1lbnQudHlwZTtcbiAgICAgICAgdmFyIHZhbHVlID0gZGF0YUVsZW1lbnQudmFsdWU7XG4gICAgICAgIHZhciBwcm9jZXNzV2l0aDtcbiAgICAgICAgdmFyIHByb2Nlc3NXaXRoU3BlYyA9IGRhdGFFbGVtZW50LnByb2Nlc3NXaXRoO1xuICAgICAgICB2YXIgZGF0YVR5cGUgPSBkYXRhRWxlbWVudC5kYXRhVHlwZSB8fCAnc3RyaW5nJztcbiAgICAgICAgdmFyICRzZWxlY3RvcjtcbiAgICAgICAgdmFyIGNvb2tpZVZhbHVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcblxuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdGhlIHZhbHVlIG9mIHdoYXQgaXMgc3RvcmVkIGluIHRoZSB2YXJpYWJsZS4gIFRoaXMgY2FuIGJlIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqJzpcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlIGFsbCAnWycgd2l0aCAnLicgZGVsZXRlIGFsbCAnXScgc3BsaXQgb24gXCIuXCIgYW5kIHJldHVybiBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcWy9nLCAnLicpLnJlcGxhY2UoL1xcXS9nLCAnJykuc3BsaXQoJy4nKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkcm9wIHRoZSBmaXJzdCBpdGVtIGlmIGl0cyAnd2luZG93JyBhcyBhIHN0cmluZyBhbmQgYWRkIHRoZSBhY3R1YWwgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVswXSA9PT0gJ3dpbmRvdycpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVbMF0gPSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgd2luZG93IHRvIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gXy5wcmVwZW5kQXJyYXkodmFsdWUsIHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbWJpbmUgdXNpbmcgYmxvY2sgbm90YXRpb25cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBfLnJlZHVjZSh2YWx1ZSwgZnVuY3Rpb24obWVtbywgaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9baXRlbV07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybnMgdGhlIHZhbHVlIG9mIGEgY3VzdG9tIGZ1bmN0aW9uLiAgVGhpcyBjYW4gYmUgYW4gYXJyYXkuIGZuYyBpcyBub3QgcHVibGljYWxseSBleHBvc2VkLlxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZuYyc6XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBldmFsKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5zIHRoZSB2YWx1ZSBpbiBhbiBhdHRyaWJ1dGUgb2YgYSBjc3Mgc2VsZWN0b3IuICBJdCBjYW4gYmUgYSBzdHJpbmcgKHdoZXJlIGl0IHdpbGwgZ2V0IHRoZSBhdHRyIHZhbHVlIG9mIHRoZSBmaXJzdCBtYXRjaCkgb3IgYW4gYXJyYXkgLSB3aWxsIGl0IHdpbGwgZ2V0IGFsbCBvZiB0aGUgYXR0ciBvZiBhbGwgdGhlIG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIGFuIGBhdHRyYCwgdGhlIHZhbHVlIGlzIGFuIGFycmF5IHdpdGggdGhlIGZpcnN0IGJlaW5nIHRoZSBzZWxlY3RvciBhbmQgdGhlIHNlY29uZCBiZWluZyB0aGUgYXR0ci5cbiAgICAgICAgICAgICAgICBjYXNlICdhdHRyJzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgJHNlbGVjdG9yIGZpbmRzIGFueXRoaW5nLi4uXG4gICAgICAgICAgICAgICAgICAgIC8vIGUuZy4gdGhlIHZhbHVlIGFycmF5IGNvbnRhaW5zWydkaXYnLCdkYXRhJ10gdGhlIGZvbGxvd2luZyBzZWxlY3RvciBjcmVhdGVzICQoZGl2W2RhdGFdKSAtIHdoaWNoIHNlbGVjdHMgYWxsIGRpdidzIHdpdGggYSBkYXRhIGF0dHIuXG4gICAgICAgICAgICAgICAgICAgICRzZWxlY3RvciA9ICQodmFsdWVbMF0gKyBcIltcIiArIHZhbHVlWzFdICsgXCJdXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgkc2VsZWN0b3IubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNlbGVjdG9yLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUucHVzaCgkKHRoaXMpLmF0dHIodmFsdWVbMV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGF0YXR5cGUgaXMgYSBzdHJpbmcsIHVzZSBqdXN0IHRoZSBmaXJzdCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmV0dXJuVmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGpxdWVyeSBzZWxlY3Rpb24uICBKcXVlcnkgd2lsbCBvbmx5IHJldHVybiBhIHN0cmluZyBiYXNlZCBvbiB0aGUgZmlyc3QgdmFsdWUgb2YgYSBjb2xsZWN0aW9uLiAgSG93ZXZlciwgd2Ugd2lsbCByZXR1cm4gYW4gYXJyYXkgYmFzZWQgb24gYWxsIG1hdGNoaW5nIHNlbGVjdG9ycyAgaWYgaXQgaXMgaW5kaWNhdGVkXG4gICAgICAgICAgICAgICAgY2FzZSAnY3NzJzpcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgJHNlbGVjdG9yIGZpbmRzIGFueXRoaW5nLi4uXG4gICAgICAgICAgICAgICAgICAgICRzZWxlY3RvciA9ICQodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgkc2VsZWN0b3IubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCByZXR1cm5WYWx1ZSB0byBhbiBhcnJheSBhcyBzZWxlY3RvcnMgcmV0dXJuIGFycmF5c1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAkc2VsZWN0b3IuZWFjaChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0lmIHRoZSBzZWxlY3RvciBpcyBhbnl0aGluZyBidXQgdGhlc2UgdGhyZWUgaXRlbXMsIGp1c3QgcmV0dXJuIHRoZSB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEkdGhpcy5pcyhcImlucHV0LCBzZWxlY3QsIHRleHRhcmVhXCIpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUucHVzaCgkdGhpcy50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICgkdGhpcy5hdHRyKFwidHlwZVwiKSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBgc2VsZWN0YCBnZXQgdGhlIHNlbGVjdGVkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzZWxlY3QnOlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMgPSAkdGhpcy5maWx0ZXIoXCI6c2VsZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS5wdXNoKCR0aGlzLnZhbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGBjaGVja2JveGAgb3IgYHJhZGlvYCBnZXQgdGhlIGNoZWNrZWQgdmFsdWUocylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzID0gJHRoaXMuZmlsdGVyKFwiOmNoZWNrZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS5wdXNoKCR0aGlzLnZhbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHllYWguLi4gIE5vLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncGFzc3dvcmQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFueXRoaW5nIGVsc2UsIGp1c3QgZ2V0IHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZS5wdXNoKCR0aGlzLnZhbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGF0YXR5cGUgaXMgbm90IHNwZWNpZmljYWxseSBhbiBhcnJheSwgcmV0dXJuIGp1c3QgdGhlIGZpcnN0IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFsc28gbWFrZXMgdGhlIG5vbnNlbnNpY2FsIGRhdGF0eXBlIG9mICdvYmplY3QnIHdvcmsgYXMgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVHlwZSAhPT0gJ2FycmF5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gcmV0dXJuVmFsdWVbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAvLyBncmFicyBhIHZhbHVlIGZyb20gdGhlIGNvb2tpZS4gIEl0IGNhbiBvbmx5IGJlIGEgc3RyaW5nXG4gICAgICAgICAgICAgICAgY2FzZSAnY2tlJzpcblxuICAgICAgICAgICAgICAgICAgICBjb29raWVWYWx1ZSA9IGNvb2tpZXNbdmFsdWVdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvb2tpZXMgc2hvdWxkIGFsd2F5cyBiZSBzdG9yZWQgZW5jb2RlZC4gIFdlIHdpbGwgYWx3YXlzIGRlY29kZSB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgdGhlcmUgaXMgbm8gd2F5IHdlIGNhbiByZWFsbHkgdXNlIGl0XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gIV8uaXNVbmRlZmluZWQoY29va2llVmFsdWUpID8gZGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZVZhbHVlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAvLyBncmFicyBhIHZhbHVlIGZyb20gdGhlIGBsb2NhdGlvbi5zZWFyY2hgLiAgSXQgY2FuIG9ubHkgYmUgYSBzdHJpbmdcbiAgICAgICAgICAgICAgICBjYXNlICdxcnknOlxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gZGF0YVR5cGUgPT09ICdzdHJpbmcnID8gc2VhcmNoLnNbdmFsdWVdIDogc2VhcmNoLmFbdmFsdWVdO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIHNldCB0byB1bmRlZmluZWQgYW5kIHRoZW4gbG9hZGVkIHdoZW4gdGhlIHZhbHVlIGlzIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gIGJlY2F1c2Ugd2Ugb25seSBoYXZlIGEgdGFnU3JjIHRvIGdldCAtIHdlIGRvbid0IGJvdGhlciBjaGVja2luZyB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuXG4gICAgICAgICAgICAgICAgICAgIGluZGljZXNPZkdldFRhZ1NyYy5wdXNoKGluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIGJsb3dzIHVwLCBqdXN0IHJldHVybmVkIHRoZSBkZWZhdWx0IC0gdW5kZWZpbmVkLlxuICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIHByb2Nlc3NXaXRoIHdpdGggdGhlIFwiZ2V0XCIgdHlwZVxuICAgICAgICBpZiAodHlwZSAhPT0gJ2dldCcgJiYgIV8uaXNVbmRlZmluZWQocHJvY2Vzc1dpdGhTcGVjKSkge1xuICAgICAgICAgICAgaWYgKCFwcm9jZXNzV2l0aCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NXaXRoID0gbmV3IFByb2Nlc3NXaXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHByb2Nlc3NXaXRoLnByb2Nlc3MocmV0dXJuVmFsdWUsIHByb2Nlc3NXaXRoU3BlYyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gb3VyIHZhbHVlLlxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfTtcblxuXG4gICAgLy8gRnVuY3Rpb24gdG8gbWFrZSBzZW5zZSBvZiBjcmFwIGRhdGEuIHZhbCBjYW4gYmUgVmlydHVhbGx5IGFueXRoaW5nLi4uXG4gICAgLy8gVGhpcyBzaG91bGQgdHVybiBmdW5jdGlvbnMsIHJlZ2V4cCwgdW5kZWZpbmVkLCBudWxsIGludG8gZW1wdHkgc3RyaW5nc1xuICAgIHZhciBjbGVhblJldHVyblZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG5cbiAgICAgICAgdmFyIHJldHVyblZhbHVlO1xuXG4gICAgICAgIGlmIChfLmlzU3RyaW5nKHZhbCkgfHwgXy5pc051bWJlcih2YWwpIHx8IF8uaXNCb29sZWFuKHZhbCkgfHwgXy5pc0Z1bmN0aW9uKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGRpdmUgaW50byByZWN1cnNpb24gaWYgaXRzIGEgbm9uLWVtcHR5IG9iamVjdCBvciBhbiBhcnJheVxuICAgICAgICBlbHNlIGlmICgoXy5pc0FycmF5KHZhbCkgJiYgdmFsLmxlbmd0aCkgfHwgKF8uaXNPYmplY3QodmFsKSAmJiBfLnNpemUodmFsKSkpIHtcblxuICAgICAgICAgICAgXy5lYWNoKHZhbCwgZnVuY3Rpb24oZWxlbWVudCwgaW5kZXhPcktleSwgY29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25baW5kZXhPcktleV0gPSBjbGVhblJldHVyblZhbHVlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdmFsO1xuXG4gICAgICAgICAgICAvLyBCdXQgd2FpdCEgd2hhdCBpZiBpdHMgYSBkYXRlPyBXZSB3YW50IGEgc3RhbmRhcmQgcmVwbHlcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzRGF0ZSh2YWwpKSB7XG5cbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdmFsLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vRmluYWxseSwgd2hhdCBpZiB3ZSBkb24ndCBrbm93IHdoYXQgaXQgaXM/ICBKdXN0IHJldHVybiBhbiBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAgICByZXR1cm5WYWx1ZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBGdW5jdGlvbiBmb3IgYWNjZXNzaW5nIEFsbCB2YWx1ZXMgaW4gZGF0YSBlbGVtZW50c1xuICAgIHRoaXMuZ2V0QWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByYXdEYXRhO1xuICAgIH07XG5cbiAgICAvLyBGdW5jdGlvbiBmb3IgYWNjZXNzaW5nIHRoZSBSYXcgdmFsdWUgaW4gZGF0YSBlbGVtZW50cy4gVGhlIGluZGV4IGlzIHRoZSBpbmRleFxuICAgIC8vIG9mIGRhdGEgbm9kZSBuZWVkZWRcbiAgICB0aGlzLmdldFJhdyA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiByYXdEYXRhW2luZGV4XTtcbiAgICB9O1xuXG4gICAgLy8gRnVuY3Rpb24gZm9yIGFjY2Vzc2luZyB0aGUgY2xlYW5lZCB2YWx1ZSBpbiBkYXRhIGVsZW1lbnRzIC0gY29udmVydHMgd2VpcmRcbiAgICAvLyBzdHVmZiB0byBlbXB0eSBzdHJpbmdzIGFuZCBvdGhlciBvZGQgdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuIFRoZSBpbmRleCBpc1xuICAgIC8vIHRoZSBpbmRleCBvZiBkYXRhIG5vZGUgbmVlZGVkXG4gICAgdGhpcy5nZXRDbGVhbiA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBjbGVhblJldHVyblZhbHVlKHRoaXMuZ2V0UmF3KGluZGV4KSk7XG4gICAgfTtcblxuICAgIC8vIEZ1bmN0aW9uIGZvciByZXR1cm5pbmcgYW4gYXJyYXkgYXMgYSBuZXN0ZWQgYXJyYXkgZm9yIHRlbXBsYXRlcy4gQWxzbyxcbiAgICAvLyBBbGwgc3RyaW5ncyBnZXQgd3JhcHBlZCBpbiBzaW5nbGUgcXVvdGVzLiBUaGUgaW5kZXggaXMgdGhlIGluZGV4IG9mXG4gICAgLy8gZGF0YSBub2RlIG5lZWRlZFxuICAgIHRoaXMuZ2V0TXVuZ2VkID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIHJldHVyblZhbHVlLCB2YWwgPSB0aGlzLmdldENsZWFuKGluZGV4KTtcblxuICAgICAgICBpZiAoXy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gXy5tYXAodmFsLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF8uaXNBcnJheSh2KSA/IHYgOiBbdl07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH07XG5cbiAgICAvLyBGdW5jdGlvbiBmb3IgcmV0dXJuaW5nIHRoZSBjbGVhbiB2YWx1ZSBhbmQgVVJJIEVuY29kaW5nIGl0LiBUaGUgaW5kZXhcbiAgICAvLyBpcyB0aGUgaW5kZXggb2YgZGF0YSBub2RlIG5lZWRlZFxuICAgIHRoaXMuZ2V0RW5jID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLmdldENsZWFuKGluZGV4KSk7XG4gICAgfTtcblxuICAgIC8vIEZ1bmN0aW9uIGZvciBzZXR0aW5nIHRoZSBkYXRhIGRpcmVjdGx5LCBieSBwYXNzaW5nIHRoZSBjb2xsZWN0aW9uIG9mXG4gICAgLy8gZGF0YSB2aWEgdGhlIGRhdGFEZWYuICAnZGF0YScgaXMgdGhlIHByb2Nlc3NlZCByYXdEYXRhIG5lZWRlZCBmb3IgYSB0YWdcbiAgICB0aGlzLnNldERhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YUlzU2V0KSB7XG4gICAgICAgICAgICBkYXRhSXNTZXQgPSB0cnVlO1xuICAgICAgICAgICAgcmF3RGF0YSA9IF8uY2xvbmVBcnJheShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLy8gRnVuY3Rpb24gZm9yIGdhdGhlcmluZyB0aGUgZGF0YSBiYXNlZCBvbiB0aGUgZGF0YURlZlxuICAgIC8vIGluY29taW5nRGF0YURlZiBpcyBhIHN0YW5kYXJkIGRhdGFEZWYgc3RydWN0dXJlZC5cbiAgICAvLyBvdmVycmlkZXMgaXMgYW4gb2JqZWN0IGNvbnNpc3Rpbmcgb2YgY29va2llIGFuZCBzZWFyY2hcbiAgICAvLyBvdmVycmlkZSBzdHJpbmdzIGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gICAgdGhpcy5zZXREYXRhRGVmID0gZnVuY3Rpb24oaW5jb21pbmdEYXRhRGVmLCBvdmVycmlkZXMpIHtcblxuICAgICAgICAvLyBUaGUgbm9ybWFsIHBsYWNlIHRvIGZpbmQgdGhlc2UgdmFsdWVzXG4gICAgICAgIHZhciBzb3VyY2VzID0ge1xuICAgICAgICAgICAgY29va2llOiBkb2N1bWVudC5jb29raWUsXG4gICAgICAgICAgICBzZWFyY2g6IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2hcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvb2tpZXMgPSB7fTtcblxuICAgICAgICAvLyBvYmplY3QgdGhhdCBob2xkcyBhIHN0cmluZyBhbmQgYXJyYXkgdmVyc2lvbiBvZiBzZWFyY2ggcGFyYW1zLCBkZXBlbmRpbmcgb24gc2VydmVyIG5lZWQuXG4gICAgICAgIC8vIFNvcnJ5LCBhdHRyaWJ1dGVzIGtlcHQgc2hvcnQgZm9yIG1pbmlmaWNhdGlvbiByZWFzb25zLi4uXG4gICAgICAgIHZhciBzZWFyY2g7XG5cbiAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuICAgICAgICAgICAgXy5leHRlbmQoc291cmNlcywgb3ZlcnJpZGVzIHx8IHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGhhdmVuJ3QgbGFkZWQgZGF0YSB5ZXQuLi5cbiAgICAgICAgaWYgKCFkYXRhSXNTZXQpIHtcblxuICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGRhdGFEZWYsIHNvIHdlIGRvbid0IG1vZGlmeSB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgIGRhdGFEZWYgPSBfLmNsb25lQXJyYXkoaW5jb21pbmdEYXRhRGVmKTtcblxuICAgICAgICAgICAgLy8gU2V0IHRoZSBmbGFnIHNvIHdlIGRvbid0IHNldCBkYXRhIGFnYWluXG4gICAgICAgICAgICBkYXRhSXNTZXQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBzYWZlbHkgcGFyc2UgY29va2llcyBhbmQgc2VhcmNoIHN0cmluZztcbiAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICBjb29raWVzID0gcGFyc2VDb29raWVzKHNvdXJjZXMuY29va2llKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZWFyY2ggPSBwYXJzZVNlYXJjaChzb3VyY2VzLnNlYXJjaCk7XG4gICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIGRhdGFFbGVtZW50IGluIHRoZSBEYXRhRGVmXG4gICAgICAgICAgICBfLmVhY2goZGF0YURlZiwgZnVuY3Rpb24oZGF0YUVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmF3RGF0YS5wdXNoKHByb2Nlc3NUeXBlKGRhdGFFbGVtZW50LCBpbmRleCwgY29va2llcywgc2VhcmNoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIGAuc2V0VGFnU3JjKClgOiBGdW5jdGlvbiBmb3IgdXBkYXRpbmcgdGhlIHZhbHVlIG9mIHRoZSB0YWdTcmMgaW4gcmF3RGF0YSwgb25jZSBjYWxjdWxhdGVkXG4gICAgLy8gMS4gYHRhZ1NyY2A6IFRoZSBjYWxjdWxhdGVkIHRhZ1NyYy5cbiAgICB0aGlzLnNldFRhZ1NyYyA9IGZ1bmN0aW9uKHRhZ1NyYykge1xuICAgICAgICBfLmVhY2goaW5kaWNlc09mR2V0VGFnU3JjLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmF3RGF0YVt2YWx1ZV0gPSB0YWdTcmM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZGF0YS9EYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33\n")},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, vars:true, nomen:true  */\n/*global module */\n\nmodule.exports = function() {\n\tvar self = this;\n\tvar Node = __webpack_require__(35);\n\n\tself.head = null;\n\n\tself.add = function(value) {\n\n\t\tvar node = new Node(value);\n\t\tvar currentNode;\n\n\t\t// first node in the list so just add it to \n\t\t// head and we're done.\n\t\tif(self.head === null) {\n\n\t\t\tself.head = node;\n\n\t\t} else {\n\t\t\t\n\t\t\t// start at the head\n\t\t\tcurrentNode = self.head;\n\n\t\t\t// go to the end of the linkedList and get \n\t\t\t// a reference to the last node\n\t\t\twhile(currentNode.next !== null) {\n\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t}\n\n\t\t\tcurrentNode.next = node;\n\t\t}\n\t\tself.length++;\n\n\t\treturn node;\n\n\t};\n\n\tself.empty = function() {\n\t\tself.head = null;\n\t\tself.length = 0;\n\t};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9MaW5rZWRMaXN0LmpzPzJmNDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLEVBQWtCOztBQUV0Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIHZhcnM6dHJ1ZSwgbm9tZW46dHJ1ZSAgKi9cbi8qZ2xvYmFsIG1vZHVsZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cdHZhciBOb2RlID0gcmVxdWlyZShcIi4vTGlua2VkTGlzdE5vZGVcIik7XG5cblx0c2VsZi5oZWFkID0gbnVsbDtcblxuXHRzZWxmLmFkZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cblx0XHR2YXIgbm9kZSA9IG5ldyBOb2RlKHZhbHVlKTtcblx0XHR2YXIgY3VycmVudE5vZGU7XG5cblx0XHQvLyBmaXJzdCBub2RlIGluIHRoZSBsaXN0IHNvIGp1c3QgYWRkIGl0IHRvIFxuXHRcdC8vIGhlYWQgYW5kIHdlJ3JlIGRvbmUuXG5cdFx0aWYoc2VsZi5oZWFkID09PSBudWxsKSB7XG5cblx0XHRcdHNlbGYuaGVhZCA9IG5vZGU7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0XG5cdFx0XHQvLyBzdGFydCBhdCB0aGUgaGVhZFxuXHRcdFx0Y3VycmVudE5vZGUgPSBzZWxmLmhlYWQ7XG5cblx0XHRcdC8vIGdvIHRvIHRoZSBlbmQgb2YgdGhlIGxpbmtlZExpc3QgYW5kIGdldCBcblx0XHRcdC8vIGEgcmVmZXJlbmNlIHRvIHRoZSBsYXN0IG5vZGVcblx0XHRcdHdoaWxlKGN1cnJlbnROb2RlLm5leHQgIT09IG51bGwpIHtcblx0XHRcdFx0Y3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0O1xuXHRcdFx0fVxuXG5cdFx0XHRjdXJyZW50Tm9kZS5uZXh0ID0gbm9kZTtcblx0XHR9XG5cdFx0c2VsZi5sZW5ndGgrKztcblxuXHRcdHJldHVybiBub2RlO1xuXG5cdH07XG5cblx0c2VsZi5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHNlbGYuaGVhZCA9IG51bGw7XG5cdFx0c2VsZi5sZW5ndGggPSAwO1xuXHR9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2RhdGEvTGlua2VkTGlzdC5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n")},function(module,exports){eval("/*jslint browser: true, sloppy: true, white: true, vars:true, nomen:true  */\n/*global module */\n\nmodule.exports = function(data) {\n  var self = this;\n\n  self.data = data;\n  self.next = null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9MaW5rZWRMaXN0Tm9kZS5qcz9lMjZlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCB2YXJzOnRydWUsIG5vbWVuOnRydWUgICovXG4vKmdsb2JhbCBtb2R1bGUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBzZWxmLmRhdGEgPSBkYXRhO1xuICBzZWxmLm5leHQgPSBudWxsO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2RhdGEvTGlua2VkTGlzdE5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///35\n")},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, require */\n\nmodule.exports = function(expression, valuesAr) {\n\n  var _ = __webpack_require__(0);\n  var BinaryExpressionEvaluator = __webpack_require__(30);\n\n  var exp = expression;\n  var bee;\n  var values = valuesAr;\n\n  // function to make sure the expression is a string\n  // and that the valuesAr is an array with all\n  // values being boolean values\n  var argsAreValid = function(expression, valuesAr) {\n    return (_.isString(expression) && _.isArray(valuesAr) && _.every(valuesAr, _.isBoolean));\n  };\n\n  // Use the array to replace the numbers in the\n  // expression\n  var replaceIndeces = function(inputStr, replacements) {\n    var numberFindRegex = /\\d+/g;\n    var result;\n\n    // Loop through matches and replace indeces with the\n    // corresponding in the array\n    while (result = numberFindRegex.exec(inputStr)) {\n      inputStr = inputStr.substr(0, result.index) + replacements[parseInt(result[0], 10)] + inputStr.substr(result.index + result[0].length);\n    }\n    return inputStr;\n  };\n\n\n  // Public method that evaluates an expression string with integers\n  // replaces integers with boolean values and returns the result as\n  // a single boolean value\n  this.result = function(expression, valuesAr) {\n    var retr;\n    var canProceed;\n\n    // set a flag to check first if we have arguments passed into this\n    // method that are valid, or if we're processing arguments passed\n    // into the constructor or from before\n    canProceed = (argsAreValid(expression, valuesAr) || argsAreValid(exp, values));\n\n    // if our canProceed flag is set to true then we've gotten arguments\n    // somewhere along the way to process\n    if (canProceed) {\n\n      // if we passed in new values into this method, otherwise we will\n      // use the ones passed in before.\n      exp = expression || exp;\n      values = valuesAr || values;\n\n      // Short circuit if we only have one value in our array, there is\n      // no need to evaluate the expression.  Especially since we don't\n      // allow unary operators\n      if (values.length === 1) {\n\n        // assign the only value to the return object\n        retr = values[0];\n\n        // It is necessary to check and make sure we've got a string with\n        // something in it to evaluate, otherwise this will break and\n        // throw an exception, we'd rather just return false.\n      } else if (exp !== \"\") {\n\n        // Use our BinaryExpressionEvaluator to evaluate the condition\n        // we'll replace the indeces with their values and pass that\n        // as an infix expression, then return the result.\n        bee = new BinaryExpressionEvaluator();\n        bee.setInfixBindaryExp(replaceIndeces(exp, values));\n        retr = bee.getResult();\n      }\n\n      // One last check if we got the value we expected, if not who\n      // knows what was passed in and we'll just evaluate to false\n      // for type safety.  This would be the case if an expression\n      // was passed as an empty string or valuesAr as an empty array\n      if (!_.isBoolean(retr)) {\n        retr = false;\n      }\n    } else {\n\n      // if we have no valid arguments to process, then we'll throw\n      // a meaningful exception, instead of some vague exception that\n      // will bubble up natively.\n      throw new Error(\"Invalid parameters passed to Logical Expression Evaluator\");\n    }\n\n    // Return our final value, which should always be a Boolean\n    return retr;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9Mb2dpY2FsRXhwcmVzc2lvbkV2YWx1YXRvci5qcz82ZjkyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLENBQVk7QUFDOUIsa0NBQWtDLG1CQUFPLENBQUMsRUFBNkI7O0FBRXZFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUsIHBsdXNwbHVzOnRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIHZhbHVlc0FyKSB7XG5cbiAgdmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbiAgdmFyIEJpbmFyeUV4cHJlc3Npb25FdmFsdWF0b3IgPSByZXF1aXJlKFwiLi9CaW5hcnlFeHByZXNzaW9uRXZhbHVhdG9yXCIpO1xuXG4gIHZhciBleHAgPSBleHByZXNzaW9uO1xuICB2YXIgYmVlO1xuICB2YXIgdmFsdWVzID0gdmFsdWVzQXI7XG5cbiAgLy8gZnVuY3Rpb24gdG8gbWFrZSBzdXJlIHRoZSBleHByZXNzaW9uIGlzIGEgc3RyaW5nXG4gIC8vIGFuZCB0aGF0IHRoZSB2YWx1ZXNBciBpcyBhbiBhcnJheSB3aXRoIGFsbFxuICAvLyB2YWx1ZXMgYmVpbmcgYm9vbGVhbiB2YWx1ZXNcbiAgdmFyIGFyZ3NBcmVWYWxpZCA9IGZ1bmN0aW9uKGV4cHJlc3Npb24sIHZhbHVlc0FyKSB7XG4gICAgcmV0dXJuIChfLmlzU3RyaW5nKGV4cHJlc3Npb24pICYmIF8uaXNBcnJheSh2YWx1ZXNBcikgJiYgXy5ldmVyeSh2YWx1ZXNBciwgXy5pc0Jvb2xlYW4pKTtcbiAgfTtcblxuICAvLyBVc2UgdGhlIGFycmF5IHRvIHJlcGxhY2UgdGhlIG51bWJlcnMgaW4gdGhlXG4gIC8vIGV4cHJlc3Npb25cbiAgdmFyIHJlcGxhY2VJbmRlY2VzID0gZnVuY3Rpb24oaW5wdXRTdHIsIHJlcGxhY2VtZW50cykge1xuICAgIHZhciBudW1iZXJGaW5kUmVnZXggPSAvXFxkKy9nO1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICAvLyBMb29wIHRocm91Z2ggbWF0Y2hlcyBhbmQgcmVwbGFjZSBpbmRlY2VzIHdpdGggdGhlXG4gICAgLy8gY29ycmVzcG9uZGluZyBpbiB0aGUgYXJyYXlcbiAgICB3aGlsZSAocmVzdWx0ID0gbnVtYmVyRmluZFJlZ2V4LmV4ZWMoaW5wdXRTdHIpKSB7XG4gICAgICBpbnB1dFN0ciA9IGlucHV0U3RyLnN1YnN0cigwLCByZXN1bHQuaW5kZXgpICsgcmVwbGFjZW1lbnRzW3BhcnNlSW50KHJlc3VsdFswXSwgMTApXSArIGlucHV0U3RyLnN1YnN0cihyZXN1bHQuaW5kZXggKyByZXN1bHRbMF0ubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0U3RyO1xuICB9O1xuXG5cbiAgLy8gUHVibGljIG1ldGhvZCB0aGF0IGV2YWx1YXRlcyBhbiBleHByZXNzaW9uIHN0cmluZyB3aXRoIGludGVnZXJzXG4gIC8vIHJlcGxhY2VzIGludGVnZXJzIHdpdGggYm9vbGVhbiB2YWx1ZXMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhc1xuICAvLyBhIHNpbmdsZSBib29sZWFuIHZhbHVlXG4gIHRoaXMucmVzdWx0ID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgdmFsdWVzQXIpIHtcbiAgICB2YXIgcmV0cjtcbiAgICB2YXIgY2FuUHJvY2VlZDtcblxuICAgIC8vIHNldCBhIGZsYWcgdG8gY2hlY2sgZmlyc3QgaWYgd2UgaGF2ZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhpc1xuICAgIC8vIG1ldGhvZCB0aGF0IGFyZSB2YWxpZCwgb3IgaWYgd2UncmUgcHJvY2Vzc2luZyBhcmd1bWVudHMgcGFzc2VkXG4gICAgLy8gaW50byB0aGUgY29uc3RydWN0b3Igb3IgZnJvbSBiZWZvcmVcbiAgICBjYW5Qcm9jZWVkID0gKGFyZ3NBcmVWYWxpZChleHByZXNzaW9uLCB2YWx1ZXNBcikgfHwgYXJnc0FyZVZhbGlkKGV4cCwgdmFsdWVzKSk7XG5cbiAgICAvLyBpZiBvdXIgY2FuUHJvY2VlZCBmbGFnIGlzIHNldCB0byB0cnVlIHRoZW4gd2UndmUgZ290dGVuIGFyZ3VtZW50c1xuICAgIC8vIHNvbWV3aGVyZSBhbG9uZyB0aGUgd2F5IHRvIHByb2Nlc3NcbiAgICBpZiAoY2FuUHJvY2VlZCkge1xuXG4gICAgICAvLyBpZiB3ZSBwYXNzZWQgaW4gbmV3IHZhbHVlcyBpbnRvIHRoaXMgbWV0aG9kLCBvdGhlcndpc2Ugd2Ugd2lsbFxuICAgICAgLy8gdXNlIHRoZSBvbmVzIHBhc3NlZCBpbiBiZWZvcmUuXG4gICAgICBleHAgPSBleHByZXNzaW9uIHx8IGV4cDtcbiAgICAgIHZhbHVlcyA9IHZhbHVlc0FyIHx8IHZhbHVlcztcblxuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBvbmx5IGhhdmUgb25lIHZhbHVlIGluIG91ciBhcnJheSwgdGhlcmUgaXNcbiAgICAgIC8vIG5vIG5lZWQgdG8gZXZhbHVhdGUgdGhlIGV4cHJlc3Npb24uICBFc3BlY2lhbGx5IHNpbmNlIHdlIGRvbid0XG4gICAgICAvLyBhbGxvdyB1bmFyeSBvcGVyYXRvcnNcbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAxKSB7XG5cbiAgICAgICAgLy8gYXNzaWduIHRoZSBvbmx5IHZhbHVlIHRvIHRoZSByZXR1cm4gb2JqZWN0XG4gICAgICAgIHJldHIgPSB2YWx1ZXNbMF07XG5cbiAgICAgICAgLy8gSXQgaXMgbmVjZXNzYXJ5IHRvIGNoZWNrIGFuZCBtYWtlIHN1cmUgd2UndmUgZ290IGEgc3RyaW5nIHdpdGhcbiAgICAgICAgLy8gc29tZXRoaW5nIGluIGl0IHRvIGV2YWx1YXRlLCBvdGhlcndpc2UgdGhpcyB3aWxsIGJyZWFrIGFuZFxuICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHdlJ2QgcmF0aGVyIGp1c3QgcmV0dXJuIGZhbHNlLlxuICAgICAgfSBlbHNlIGlmIChleHAgIT09IFwiXCIpIHtcblxuICAgICAgICAvLyBVc2Ugb3VyIEJpbmFyeUV4cHJlc3Npb25FdmFsdWF0b3IgdG8gZXZhbHVhdGUgdGhlIGNvbmRpdGlvblxuICAgICAgICAvLyB3ZSdsbCByZXBsYWNlIHRoZSBpbmRlY2VzIHdpdGggdGhlaXIgdmFsdWVzIGFuZCBwYXNzIHRoYXRcbiAgICAgICAgLy8gYXMgYW4gaW5maXggZXhwcmVzc2lvbiwgdGhlbiByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgYmVlID0gbmV3IEJpbmFyeUV4cHJlc3Npb25FdmFsdWF0b3IoKTtcbiAgICAgICAgYmVlLnNldEluZml4QmluZGFyeUV4cChyZXBsYWNlSW5kZWNlcyhleHAsIHZhbHVlcykpO1xuICAgICAgICByZXRyID0gYmVlLmdldFJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmUgbGFzdCBjaGVjayBpZiB3ZSBnb3QgdGhlIHZhbHVlIHdlIGV4cGVjdGVkLCBpZiBub3Qgd2hvXG4gICAgICAvLyBrbm93cyB3aGF0IHdhcyBwYXNzZWQgaW4gYW5kIHdlJ2xsIGp1c3QgZXZhbHVhdGUgdG8gZmFsc2VcbiAgICAgIC8vIGZvciB0eXBlIHNhZmV0eS4gIFRoaXMgd291bGQgYmUgdGhlIGNhc2UgaWYgYW4gZXhwcmVzc2lvblxuICAgICAgLy8gd2FzIHBhc3NlZCBhcyBhbiBlbXB0eSBzdHJpbmcgb3IgdmFsdWVzQXIgYXMgYW4gZW1wdHkgYXJyYXlcbiAgICAgIGlmICghXy5pc0Jvb2xlYW4ocmV0cikpIHtcbiAgICAgICAgcmV0ciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgbm8gdmFsaWQgYXJndW1lbnRzIHRvIHByb2Nlc3MsIHRoZW4gd2UnbGwgdGhyb3dcbiAgICAgIC8vIGEgbWVhbmluZ2Z1bCBleGNlcHRpb24sIGluc3RlYWQgb2Ygc29tZSB2YWd1ZSBleGNlcHRpb24gdGhhdFxuICAgICAgLy8gd2lsbCBidWJibGUgdXAgbmF0aXZlbHkuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlcnMgcGFzc2VkIHRvIExvZ2ljYWwgRXhwcmVzc2lvbiBFdmFsdWF0b3JcIik7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIG91ciBmaW5hbCB2YWx1ZSwgd2hpY2ggc2hvdWxkIGFsd2F5cyBiZSBhIEJvb2xlYW5cbiAgICByZXR1cm4gcmV0cjtcbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9kYXRhL0xvZ2ljYWxFeHByZXNzaW9uRXZhbHVhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36\n")},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, require */\n\nmodule.exports = function () {\n\tvar self = this;\n\tvar _ = __webpack_require__(0);\n\t__webpack_require__(8)();\n\tvar $ = __webpack_require__(1);\n\tvar getRegExInfo = function (regExStr) {\n\t\t\tvar info = {};\n\t\t\tvar matchLeftEscParen = regExStr.match(/\\\\\\(/g);\n\t\t\tvar matchLeftParen = regExStr.match(/\\(/g);\n\t\t\tvar matchRightEscParen = regExStr.match(/\\\\\\)/g);\n\t\t\tvar matchRightParen = regExStr.match(/\\)/g);\n\t\t\tvar trickyLeftParen = regExStr.match(/\\[.*\\(.*\\]/g);\n\t\t\tvar trickyRightParen = regExStr.match(/\\[.*\\).*\\]/g);\n\n\t\t\tif (!_.isNull(trickyLeftParen)) {\n\t\t\t\tmatchLeftEscParen += trickyLeftParen.length;\n\t\t\t}\n\t\t\tif (!_.isNull(trickyRightParen)) {\n\t\t\t\tmatchRightEscParen += trickyRightParen.length;\n\t\t\t}\n\n\t\t\tif (!_.isNull(matchLeftEscParen)) {\n\t\t\t\tinfo.numLeftEscParen = matchLeftEscParen.length;\n\t\t\t} else {\n\t\t\t\tinfo.numLeftEscParen = 0;\n\t\t\t}\n\t\t\tif (!_.isNull(matchRightEscParen)) {\n\t\t\t\tinfo.numRightEscParen = matchRightEscParen.length;\n\t\t\t} else {\n\t\t\t\tinfo.numRightEscParen = 0;\n\t\t\t}\n\n\t\t\tif (!_.isNull(matchLeftParen)) {\n\t\t\t\tinfo.numLeftParen = matchLeftParen.length - info.numLeftEscParen;\n\t\t\t} else {\n\t\t\t\tinfo.numLeftParen = 0;\n\t\t\t}\n\n\t\t\tif (!_.isNull(matchRightParen)) {\n\t\t\t\tinfo.numRightParen = matchRightParen.length - info.numRightEscParen;\n\t\t\t} else {\n\t\t\t\tinfo.numRightParen = 0;\n\t\t\t}\n\n\t\t\treturn info;\n\t\t};\n\tvar isUsableString = function (val) {\n\t\t\treturn _.isString(val) && val !== \'\';\n\t\t};\n\n\t// Try to make sense of crap data.  This should turn functions, regexp, undefined, null into empty strings\n\tvar cleanReturnValue = function (val) {\n\t\t\tvar returnValue;\n\t\t\tif (_.isString(val) || _.isNumber(val) || _.isBoolean(val) || _.isFunction(val)) {\n\t\t\t\treturnValue = val;\n\t\t\t}\n\t\t\t// Otherwise we dive into recursion if its a non-empty object or an array\n\t\t\telse if ((_.isArray(val) && val.length) || (_.isObject(val) && _.size(val))) {\n\t\t\t\t_.each(val, function (element, indexOrKey, collection) {\n\t\t\t\t\tcollection[indexOrKey] = cleanReturnValue(element);\n\t\t\t\t});\n\t\t\t\treturnValue = val;\n\t\t\t\t// But wait! what if its a date? We want a standard reply\n\t\t\t} else if (_.isDate(val)) {\n\t\t\t\treturnValue = val.toISOString();\n\t\t\t} else {\n\t\t\t\t//Finally, what if we don\'t know what it is?  Just return an empty string.\n\t\t\t\treturnValue = "";\n\t\t\t}\n\t\t\treturn returnValue;\n\t\t};\n\n\tself.process = function (value, processWith) {\n\t\tvar returnValue = value;\n\t\tvar methods = {\n\t\t\tregEx: function (exec) {\n\n\t\t\t\t// If a blank string is the returnValue that means\n\t\t\t\t// that the value was undefined not found.  Therefore\n\t\t\t\t// we aren\'t going to use it.\n\t\t\t\tif (isUsableString(returnValue)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturnValue = _.convertRegExp(exec).exec(returnValue)[0];\n\t\t\t\t\t} catch (err1) {\n\t\t\t\t\t\treturnValue = "";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = "";\n\t\t\t\t}\n\t\t\t},\n\t\t\tregExAdv: function (exec) {\n\n\t\t\t\tvar regExInfo;\n\t\t\t\tif (isUsableString(returnValue) && !_.isArray(exec)) {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturnValue = _.convertRegExp(exec).exec(returnValue);\n\t\t\t\t\t\t// returnValue = returnValue.match(_.convertRegExp(processExec))\n\t\t\t\t\t\tregExInfo = getRegExInfo(exec);\n\t\t\t\t\t\tif (regExInfo.numLeftParen > 0) {\n\t\t\t\t\t\t\treturnValue = _.rest(returnValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (err2) {\n\t\t\t\t\t\treturnValue = [];\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = [];\n\t\t\t\t}\n\t\t\t},\n\t\t\tsplit: function (exec) {\n\t\t\t\tif (isUsableString(returnValue)) {\n\t\t\t\t\treturnValue = returnValue.split(exec);\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = [];\n\t\t\t\t}\n\t\t\t},\n\t\t\tjoin: function (exec) {\n\n\t\t\t\tif (_.isArray(returnValue)) {\n\t\t\t\t\treturnValue = returnValue.join(exec);\n\t\t\t\t} else if (!isUsableString(returnValue)) {\n\t\t\t\t\treturnValue = "";\n\t\t\t\t}\n\t\t\t},\n\t\t\tpluck: function (exec) {\n\n\t\t\t\t// First check if it\'s an \'object\': Array, Object or function\n\t\t\t\t// and if it\'s not an array make it one for pluckin\'\n\t\t\t\tif (_.isObject(returnValue)) {\n\t\t\t\t\tif (!_.isArray(returnValue)) {\n\t\t\t\t\t\treturnValue = [returnValue];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Can pass multiple processExec\'s as an array.  We need to\n\t\t\t\t\t// Check to see if it\'s a string or not.\n\t\t\t\t\tif (isUsableString(exec)) {\n\t\t\t\t\t\tif (exec.indexOf(",") >= 0) {\n\t\t\t\t\t\t\texec = exec.split(",");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\texec = [exec];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\texec = _.map(exec, function (a) {\n\t\t\t\t\t\tif (a !== "") {\n\t\t\t\t\t\t\treturn $.trim(a);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (exec.length === 1) {\n\t\t\t\t\t\treturnValue = _.pluck(returnValue, exec[0]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturnValue = _.map(returnValue, function (rv) {\n\t\t\t\t\t\t\tvar peLen = exec.length,\n\t\t\t\t\t\t\t\ti, rAr = [];\n\t\t\t\t\t\t\trv = _.pick.apply(this, [rv, exec]);\n\t\t\t\t\t\t\tfor (i = 0; i < peLen; i += 1) {\n\t\t\t\t\t\t\t\trAr[i] = (_.isUndefined(rv[exec[i]])) ? "" : rv[exec[i]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn rAr;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = [];\n\t\t\t\t}\n\t\t\t},\n\t\t\tflatten: function () {\n\n\t\t\t\tif (_.isArray(returnValue)) {\n\t\t\t\t\treturnValue = _.flatten(returnValue);\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = [];\n\t\t\t\t}\n\t\t\t},\n\t\t\twithout: function (exec) {\n\n\t\t\t\tif (_.isArray(returnValue)) {\n\n\t\t\t\t\t// It is possible to pass multiple processExecs but this does not support it.\n\t\t\t\t\t// it would look like (just uncomment):\n\t\t\t\t\t// processExec.unshift(returnValue);\n\t\t\t\t\t// returnValue = _.without.apply(exec);\n\t\t\t\t\treturnValue = _.without(returnValue, exec);\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = [];\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoArray: function () {\n\n\t\t\t\tif (_.isObject(returnValue)) {\n\t\t\t\t\treturnValue = _.toArray(returnValue);\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = [];\n\t\t\t\t}\n\t\t\t},\n\t\t\tmax: function (exec) {\n\n\t\t\t\tif (_.isArray(returnValue)) {\n\t\t\t\t\treturnValue = _.max(returnValue, exec);\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = "";\n\t\t\t\t}\n\t\t\t},\n\t\t\tmin: function (exec) {\n\n\t\t\t\tif (_.isArray(returnValue)) {\n\t\t\t\t\treturnValue = _.min(returnValue, exec);\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = "";\n\t\t\t\t}\n\t\t\t},\n\t\t\tfirst: function (exec) {\n\n\t\t\t\tif (_.isArray(returnValue)) {\n\t\t\t\t\tif (exec > 0) {\n\t\t\t\t\t\treturnValue = _.first(returnValue, exec);\n\t\t\t\t\t} else if (_.isUndefined(exec)) {\n\t\t\t\t\t\treturnValue = _.first(returnValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturnValue = [];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = [];\n\t\t\t\t}\n\t\t\t},\n\t\t\tlast: function (exec) {\n\n\t\t\t\tif (_.isArray(returnValue)) {\n\t\t\t\t\tif (exec > 0) {\n\t\t\t\t\t\treturnValue = _.last(returnValue, exec);\n\t\t\t\t\t} else if (_.isUndefined(exec)) {\n\t\t\t\t\t\treturnValue = _.last(returnValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturnValue = [];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = [];\n\t\t\t\t}\n\t\t\t},\n\t\t\trest: function (exec) {\n\n\t\t\t\tif (_.isArray(returnValue)) {\n\t\t\t\t\treturnValue = _.rest(returnValue, exec);\n\t\t\t\t} else if (exec > 0) {\n\t\t\t\t\treturnValue = [];\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = "";\n\t\t\t\t}\n\t\t\t},\n\t\t\tinitial: function (exec) {\n\n\t\t\t\tif (_.isArray(returnValue)) {\n\t\t\t\t\treturnValue = _.initial(returnValue, exec);\n\t\t\t\t} else if (exec > 0) {\n\t\t\t\t\treturnValue = [];\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = "";\n\t\t\t\t}\n\t\t\t},\n\t\t\tpairs: function () {\n\n\t\t\t\tif (_.isObject(returnValue) && !_.isFunction(returnValue)) {\n\t\t\t\t\treturnValue = _.pairs(returnValue);\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = [];\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoUpperCase: function () {\n\n\t\t\t\tif (_.isString(returnValue)) {\n\t\t\t\t\treturnValue = returnValue.toUpperCase();\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = \'\';\n\t\t\t\t}\n\t\t\t},\n\t\t\ttoLowerCase: function () {\n\t\t\t\tif (_.isString(returnValue)) {\n\t\t\t\t\treturnValue = returnValue.toLowerCase();\n\t\t\t\t} else {\n\t\t\t\t\treturnValue = \'\';\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tgetItemByIndex: function (exec) {\n\n\t\t\t\t//if we have an array and a number index (exec), \n\t\t\t\t//we will need to return the object at the specified index\n\t\t\t\tif (_.isArray(returnValue) && _.isNumber(exec) && exec >= 0 && exec < returnValue.length) {\n\n\t\t\t\t\t//return the object at the specified index\n\t\t\t\t\treturnValue = returnValue[exec];\n\t\t\t\t} else {\n\n\t\t\t\t\t// we didnt have an array or had a bad index, return empty string\n\t\t\t\t\t// per james, we should just return empty string here\n\t\t\t\t\treturnValue = \'\';\n\n\t\t\t\t}\n\t\t\t},\n\n      deserializeMatrix: function (exec) {\n        if (_.isString(returnValue)){\n          returnValue = returnValue.split(exec.row);\n          _.each(returnValue, function(item, i) {\n            if(_.isSet(item)){\n              returnValue[i] = item.split(exec.col); \n            } else {\n              returnValue[i] = [];\n            }\n          })\n        } else {\n          returnValue = [];\n        }\n      },\n\n      columnFromMatrix: function(exec) {\n        if (_.isArray(returnValue)) {\n          var col = [];\n          _.each(returnValue, function(row) {\n            value = row[exec];\n            if (_.isSet(value)){\n              col.push(row[exec])\n            } else {\n              col.push("")\n            }\n          })\n          returnValue = col;\n        } else {\n          returnValue = [];\n        }\n      }\n\t\t};\n\n\t\ttry {\n\t\t\t_.each(processWith, function (pwObj) {\n\n\t\t\t\tvar method = methods[pwObj.method];\n\n\t\t\t\tif (_.isFunction(method)) {\n\t\t\t\t\tmethod(pwObj.exec);\n\t\t\t\t}\n\n\t\t\t\t//Make sure the return value is a compliant after every processWith run.\n\t\t\t\treturnValue = cleanReturnValue(returnValue);\n\n\t\t\t});\n\t\t} catch (e) {\n\t\t\treturnValue = undefined;\n\t\t}\n\t\treturn returnValue;\n\t};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9Qcm9jZXNzV2l0aC5qcz84YzAwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxDQUFZO0FBQzdCLENBQUMsbUJBQU8sQ0FBQyxDQUEyQztBQUNwRCxTQUFTLG1CQUFPLENBQUMsQ0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUsIHBsdXNwbHVzOnRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXHRyZXF1aXJlKFwiLi4vLi4vbGliL3VuZGVyc2NvcmVfbWl4aW5zL2NvbnZlcnRSZWdFeHBcIikoKTtcblx0dmFyICQgPSByZXF1aXJlKFwiemVwdG9cIik7XG5cdHZhciBnZXRSZWdFeEluZm8gPSBmdW5jdGlvbiAocmVnRXhTdHIpIHtcblx0XHRcdHZhciBpbmZvID0ge307XG5cdFx0XHR2YXIgbWF0Y2hMZWZ0RXNjUGFyZW4gPSByZWdFeFN0ci5tYXRjaCgvXFxcXFxcKC9nKTtcblx0XHRcdHZhciBtYXRjaExlZnRQYXJlbiA9IHJlZ0V4U3RyLm1hdGNoKC9cXCgvZyk7XG5cdFx0XHR2YXIgbWF0Y2hSaWdodEVzY1BhcmVuID0gcmVnRXhTdHIubWF0Y2goL1xcXFxcXCkvZyk7XG5cdFx0XHR2YXIgbWF0Y2hSaWdodFBhcmVuID0gcmVnRXhTdHIubWF0Y2goL1xcKS9nKTtcblx0XHRcdHZhciB0cmlja3lMZWZ0UGFyZW4gPSByZWdFeFN0ci5tYXRjaCgvXFxbLipcXCguKlxcXS9nKTtcblx0XHRcdHZhciB0cmlja3lSaWdodFBhcmVuID0gcmVnRXhTdHIubWF0Y2goL1xcWy4qXFwpLipcXF0vZyk7XG5cblx0XHRcdGlmICghXy5pc051bGwodHJpY2t5TGVmdFBhcmVuKSkge1xuXHRcdFx0XHRtYXRjaExlZnRFc2NQYXJlbiArPSB0cmlja3lMZWZ0UGFyZW4ubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFfLmlzTnVsbCh0cmlja3lSaWdodFBhcmVuKSkge1xuXHRcdFx0XHRtYXRjaFJpZ2h0RXNjUGFyZW4gKz0gdHJpY2t5UmlnaHRQYXJlbi5sZW5ndGg7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghXy5pc051bGwobWF0Y2hMZWZ0RXNjUGFyZW4pKSB7XG5cdFx0XHRcdGluZm8ubnVtTGVmdEVzY1BhcmVuID0gbWF0Y2hMZWZ0RXNjUGFyZW4ubGVuZ3RoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5mby5udW1MZWZ0RXNjUGFyZW4gPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFfLmlzTnVsbChtYXRjaFJpZ2h0RXNjUGFyZW4pKSB7XG5cdFx0XHRcdGluZm8ubnVtUmlnaHRFc2NQYXJlbiA9IG1hdGNoUmlnaHRFc2NQYXJlbi5sZW5ndGg7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpbmZvLm51bVJpZ2h0RXNjUGFyZW4gPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIV8uaXNOdWxsKG1hdGNoTGVmdFBhcmVuKSkge1xuXHRcdFx0XHRpbmZvLm51bUxlZnRQYXJlbiA9IG1hdGNoTGVmdFBhcmVuLmxlbmd0aCAtIGluZm8ubnVtTGVmdEVzY1BhcmVuO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW5mby5udW1MZWZ0UGFyZW4gPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIV8uaXNOdWxsKG1hdGNoUmlnaHRQYXJlbikpIHtcblx0XHRcdFx0aW5mby5udW1SaWdodFBhcmVuID0gbWF0Y2hSaWdodFBhcmVuLmxlbmd0aCAtIGluZm8ubnVtUmlnaHRFc2NQYXJlbjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluZm8ubnVtUmlnaHRQYXJlbiA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBpbmZvO1xuXHRcdH07XG5cdHZhciBpc1VzYWJsZVN0cmluZyA9IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRcdHJldHVybiBfLmlzU3RyaW5nKHZhbCkgJiYgdmFsICE9PSAnJztcblx0XHR9O1xuXG5cdC8vIFRyeSB0byBtYWtlIHNlbnNlIG9mIGNyYXAgZGF0YS4gIFRoaXMgc2hvdWxkIHR1cm4gZnVuY3Rpb25zLCByZWdleHAsIHVuZGVmaW5lZCwgbnVsbCBpbnRvIGVtcHR5IHN0cmluZ3Ncblx0dmFyIGNsZWFuUmV0dXJuVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG5cdFx0XHR2YXIgcmV0dXJuVmFsdWU7XG5cdFx0XHRpZiAoXy5pc1N0cmluZyh2YWwpIHx8IF8uaXNOdW1iZXIodmFsKSB8fCBfLmlzQm9vbGVhbih2YWwpIHx8IF8uaXNGdW5jdGlvbih2YWwpKSB7XG5cdFx0XHRcdHJldHVyblZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGRpdmUgaW50byByZWN1cnNpb24gaWYgaXRzIGEgbm9uLWVtcHR5IG9iamVjdCBvciBhbiBhcnJheVxuXHRcdFx0ZWxzZSBpZiAoKF8uaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGgpIHx8IChfLmlzT2JqZWN0KHZhbCkgJiYgXy5zaXplKHZhbCkpKSB7XG5cdFx0XHRcdF8uZWFjaCh2YWwsIGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleE9yS2V5LCBjb2xsZWN0aW9uKSB7XG5cdFx0XHRcdFx0Y29sbGVjdGlvbltpbmRleE9yS2V5XSA9IGNsZWFuUmV0dXJuVmFsdWUoZWxlbWVudCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHZhbDtcblx0XHRcdFx0Ly8gQnV0IHdhaXQhIHdoYXQgaWYgaXRzIGEgZGF0ZT8gV2Ugd2FudCBhIHN0YW5kYXJkIHJlcGx5XG5cdFx0XHR9IGVsc2UgaWYgKF8uaXNEYXRlKHZhbCkpIHtcblx0XHRcdFx0cmV0dXJuVmFsdWUgPSB2YWwudG9JU09TdHJpbmcoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vRmluYWxseSwgd2hhdCBpZiB3ZSBkb24ndCBrbm93IHdoYXQgaXQgaXM/ICBKdXN0IHJldHVybiBhbiBlbXB0eSBzdHJpbmcuXG5cdFx0XHRcdHJldHVyblZhbHVlID0gXCJcIjtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXR1cm5WYWx1ZTtcblx0XHR9O1xuXG5cdHNlbGYucHJvY2VzcyA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJvY2Vzc1dpdGgpIHtcblx0XHR2YXIgcmV0dXJuVmFsdWUgPSB2YWx1ZTtcblx0XHR2YXIgbWV0aG9kcyA9IHtcblx0XHRcdHJlZ0V4OiBmdW5jdGlvbiAoZXhlYykge1xuXG5cdFx0XHRcdC8vIElmIGEgYmxhbmsgc3RyaW5nIGlzIHRoZSByZXR1cm5WYWx1ZSB0aGF0IG1lYW5zXG5cdFx0XHRcdC8vIHRoYXQgdGhlIHZhbHVlIHdhcyB1bmRlZmluZWQgbm90IGZvdW5kLiAgVGhlcmVmb3JlXG5cdFx0XHRcdC8vIHdlIGFyZW4ndCBnb2luZyB0byB1c2UgaXQuXG5cdFx0XHRcdGlmIChpc1VzYWJsZVN0cmluZyhyZXR1cm5WYWx1ZSkpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBfLmNvbnZlcnRSZWdFeHAoZXhlYykuZXhlYyhyZXR1cm5WYWx1ZSlbMF07XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyMSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBcIlwiO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZWdFeEFkdjogZnVuY3Rpb24gKGV4ZWMpIHtcblxuXHRcdFx0XHR2YXIgcmVnRXhJbmZvO1xuXHRcdFx0XHRpZiAoaXNVc2FibGVTdHJpbmcocmV0dXJuVmFsdWUpICYmICFfLmlzQXJyYXkoZXhlYykpIHtcblxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IF8uY29udmVydFJlZ0V4cChleGVjKS5leGVjKHJldHVyblZhbHVlKTtcblx0XHRcdFx0XHRcdC8vIHJldHVyblZhbHVlID0gcmV0dXJuVmFsdWUubWF0Y2goXy5jb252ZXJ0UmVnRXhwKHByb2Nlc3NFeGVjKSlcblx0XHRcdFx0XHRcdHJlZ0V4SW5mbyA9IGdldFJlZ0V4SW5mbyhleGVjKTtcblx0XHRcdFx0XHRcdGlmIChyZWdFeEluZm8ubnVtTGVmdFBhcmVuID4gMCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IF8ucmVzdChyZXR1cm5WYWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBjYXRjaCAoZXJyMikge1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c3BsaXQ6IGZ1bmN0aW9uIChleGVjKSB7XG5cdFx0XHRcdGlmIChpc1VzYWJsZVN0cmluZyhyZXR1cm5WYWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlLnNwbGl0KGV4ZWMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gW107XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRqb2luOiBmdW5jdGlvbiAoZXhlYykge1xuXG5cdFx0XHRcdGlmIChfLmlzQXJyYXkocmV0dXJuVmFsdWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZS5qb2luKGV4ZWMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFpc1VzYWJsZVN0cmluZyhyZXR1cm5WYWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRwbHVjazogZnVuY3Rpb24gKGV4ZWMpIHtcblxuXHRcdFx0XHQvLyBGaXJzdCBjaGVjayBpZiBpdCdzIGFuICdvYmplY3QnOiBBcnJheSwgT2JqZWN0IG9yIGZ1bmN0aW9uXG5cdFx0XHRcdC8vIGFuZCBpZiBpdCdzIG5vdCBhbiBhcnJheSBtYWtlIGl0IG9uZSBmb3IgcGx1Y2tpbidcblx0XHRcdFx0aWYgKF8uaXNPYmplY3QocmV0dXJuVmFsdWUpKSB7XG5cdFx0XHRcdFx0aWYgKCFfLmlzQXJyYXkocmV0dXJuVmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IFtyZXR1cm5WYWx1ZV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gQ2FuIHBhc3MgbXVsdGlwbGUgcHJvY2Vzc0V4ZWMncyBhcyBhbiBhcnJheS4gIFdlIG5lZWQgdG9cblx0XHRcdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBhIHN0cmluZyBvciBub3QuXG5cdFx0XHRcdFx0aWYgKGlzVXNhYmxlU3RyaW5nKGV4ZWMpKSB7XG5cdFx0XHRcdFx0XHRpZiAoZXhlYy5pbmRleE9mKFwiLFwiKSA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGV4ZWMgPSBleGVjLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGV4ZWMgPSBbZXhlY107XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGV4ZWMgPSBfLm1hcChleGVjLCBmdW5jdGlvbiAoYSkge1xuXHRcdFx0XHRcdFx0aWYgKGEgIT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuICQudHJpbShhKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAoZXhlYy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlID0gXy5wbHVjayhyZXR1cm5WYWx1ZSwgZXhlY1swXSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlID0gXy5tYXAocmV0dXJuVmFsdWUsIGZ1bmN0aW9uIChydikge1xuXHRcdFx0XHRcdFx0XHR2YXIgcGVMZW4gPSBleGVjLmxlbmd0aCxcblx0XHRcdFx0XHRcdFx0XHRpLCByQXIgPSBbXTtcblx0XHRcdFx0XHRcdFx0cnYgPSBfLnBpY2suYXBwbHkodGhpcywgW3J2LCBleGVjXSk7XG5cdFx0XHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBwZUxlbjsgaSArPSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0ckFyW2ldID0gKF8uaXNVbmRlZmluZWQocnZbZXhlY1tpXV0pKSA/IFwiXCIgOiBydltleGVjW2ldXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gckFyO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gW107XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmbGF0dGVuOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0aWYgKF8uaXNBcnJheShyZXR1cm5WYWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IF8uZmxhdHRlbihyZXR1cm5WYWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHdpdGhvdXQ6IGZ1bmN0aW9uIChleGVjKSB7XG5cblx0XHRcdFx0aWYgKF8uaXNBcnJheShyZXR1cm5WYWx1ZSkpIHtcblxuXHRcdFx0XHRcdC8vIEl0IGlzIHBvc3NpYmxlIHRvIHBhc3MgbXVsdGlwbGUgcHJvY2Vzc0V4ZWNzIGJ1dCB0aGlzIGRvZXMgbm90IHN1cHBvcnQgaXQuXG5cdFx0XHRcdFx0Ly8gaXQgd291bGQgbG9vayBsaWtlIChqdXN0IHVuY29tbWVudCk6XG5cdFx0XHRcdFx0Ly8gcHJvY2Vzc0V4ZWMudW5zaGlmdChyZXR1cm5WYWx1ZSk7XG5cdFx0XHRcdFx0Ly8gcmV0dXJuVmFsdWUgPSBfLndpdGhvdXQuYXBwbHkoZXhlYyk7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBfLndpdGhvdXQocmV0dXJuVmFsdWUsIGV4ZWMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gW107XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0b0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0aWYgKF8uaXNPYmplY3QocmV0dXJuVmFsdWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBfLnRvQXJyYXkocmV0dXJuVmFsdWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gW107XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRtYXg6IGZ1bmN0aW9uIChleGVjKSB7XG5cblx0XHRcdFx0aWYgKF8uaXNBcnJheShyZXR1cm5WYWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IF8ubWF4KHJldHVyblZhbHVlLCBleGVjKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRtaW46IGZ1bmN0aW9uIChleGVjKSB7XG5cblx0XHRcdFx0aWYgKF8uaXNBcnJheShyZXR1cm5WYWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IF8ubWluKHJldHVyblZhbHVlLCBleGVjKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmaXJzdDogZnVuY3Rpb24gKGV4ZWMpIHtcblxuXHRcdFx0XHRpZiAoXy5pc0FycmF5KHJldHVyblZhbHVlKSkge1xuXHRcdFx0XHRcdGlmIChleGVjID4gMCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBfLmZpcnN0KHJldHVyblZhbHVlLCBleGVjKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKF8uaXNVbmRlZmluZWQoZXhlYykpIHtcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlID0gXy5maXJzdChyZXR1cm5WYWx1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gW107XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRsYXN0OiBmdW5jdGlvbiAoZXhlYykge1xuXG5cdFx0XHRcdGlmIChfLmlzQXJyYXkocmV0dXJuVmFsdWUpKSB7XG5cdFx0XHRcdFx0aWYgKGV4ZWMgPiAwKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IF8ubGFzdChyZXR1cm5WYWx1ZSwgZXhlYyk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChfLmlzVW5kZWZpbmVkKGV4ZWMpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IF8ubGFzdChyZXR1cm5WYWx1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJldHVyblZhbHVlID0gW107XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gW107XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZXN0OiBmdW5jdGlvbiAoZXhlYykge1xuXG5cdFx0XHRcdGlmIChfLmlzQXJyYXkocmV0dXJuVmFsdWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBfLnJlc3QocmV0dXJuVmFsdWUsIGV4ZWMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGV4ZWMgPiAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBbXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRpbml0aWFsOiBmdW5jdGlvbiAoZXhlYykge1xuXG5cdFx0XHRcdGlmIChfLmlzQXJyYXkocmV0dXJuVmFsdWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBfLmluaXRpYWwocmV0dXJuVmFsdWUsIGV4ZWMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGV4ZWMgPiAwKSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBbXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRwYWlyczogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdGlmIChfLmlzT2JqZWN0KHJldHVyblZhbHVlKSAmJiAhXy5pc0Z1bmN0aW9uKHJldHVyblZhbHVlKSkge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gXy5wYWlycyhyZXR1cm5WYWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHRvVXBwZXJDYXNlOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0aWYgKF8uaXNTdHJpbmcocmV0dXJuVmFsdWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSByZXR1cm5WYWx1ZS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0b0xvd2VyQ2FzZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoXy5pc1N0cmluZyhyZXR1cm5WYWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSAnJztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0Z2V0SXRlbUJ5SW5kZXg6IGZ1bmN0aW9uIChleGVjKSB7XG5cblx0XHRcdFx0Ly9pZiB3ZSBoYXZlIGFuIGFycmF5IGFuZCBhIG51bWJlciBpbmRleCAoZXhlYyksIFxuXHRcdFx0XHQvL3dlIHdpbGwgbmVlZCB0byByZXR1cm4gdGhlIG9iamVjdCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XG5cdFx0XHRcdGlmIChfLmlzQXJyYXkocmV0dXJuVmFsdWUpICYmIF8uaXNOdW1iZXIoZXhlYykgJiYgZXhlYyA+PSAwICYmIGV4ZWMgPCByZXR1cm5WYWx1ZS5sZW5ndGgpIHtcblxuXHRcdFx0XHRcdC8vcmV0dXJuIHRoZSBvYmplY3QgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxuXHRcdFx0XHRcdHJldHVyblZhbHVlID0gcmV0dXJuVmFsdWVbZXhlY107XG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyB3ZSBkaWRudCBoYXZlIGFuIGFycmF5IG9yIGhhZCBhIGJhZCBpbmRleCwgcmV0dXJuIGVtcHR5IHN0cmluZ1xuXHRcdFx0XHRcdC8vIHBlciBqYW1lcywgd2Ugc2hvdWxkIGp1c3QgcmV0dXJuIGVtcHR5IHN0cmluZyBoZXJlXG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUgPSAnJztcblxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG4gICAgICBkZXNlcmlhbGl6ZU1hdHJpeDogZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgICAgaWYgKF8uaXNTdHJpbmcocmV0dXJuVmFsdWUpKXtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IHJldHVyblZhbHVlLnNwbGl0KGV4ZWMucm93KTtcbiAgICAgICAgICBfLmVhY2gocmV0dXJuVmFsdWUsIGZ1bmN0aW9uKGl0ZW0sIGkpIHtcbiAgICAgICAgICAgIGlmKF8uaXNTZXQoaXRlbSkpe1xuICAgICAgICAgICAgICByZXR1cm5WYWx1ZVtpXSA9IGl0ZW0uc3BsaXQoZXhlYy5jb2wpOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVyblZhbHVlW2ldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjb2x1bW5Gcm9tTWF0cml4OiBmdW5jdGlvbihleGVjKSB7XG4gICAgICAgIGlmIChfLmlzQXJyYXkocmV0dXJuVmFsdWUpKSB7XG4gICAgICAgICAgdmFyIGNvbCA9IFtdO1xuICAgICAgICAgIF8uZWFjaChyZXR1cm5WYWx1ZSwgZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJvd1tleGVjXTtcbiAgICAgICAgICAgIGlmIChfLmlzU2V0KHZhbHVlKSl7XG4gICAgICAgICAgICAgIGNvbC5wdXNoKHJvd1tleGVjXSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbC5wdXNoKFwiXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGNvbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG5cdFx0fTtcblxuXHRcdHRyeSB7XG5cdFx0XHRfLmVhY2gocHJvY2Vzc1dpdGgsIGZ1bmN0aW9uIChwd09iaikge1xuXG5cdFx0XHRcdHZhciBtZXRob2QgPSBtZXRob2RzW3B3T2JqLm1ldGhvZF07XG5cblx0XHRcdFx0aWYgKF8uaXNGdW5jdGlvbihtZXRob2QpKSB7XG5cdFx0XHRcdFx0bWV0aG9kKHB3T2JqLmV4ZWMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly9NYWtlIHN1cmUgdGhlIHJldHVybiB2YWx1ZSBpcyBhIGNvbXBsaWFudCBhZnRlciBldmVyeSBwcm9jZXNzV2l0aCBydW4uXG5cdFx0XHRcdHJldHVyblZhbHVlID0gY2xlYW5SZXR1cm5WYWx1ZShyZXR1cm5WYWx1ZSk7XG5cblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHJldHVyblZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0dXJuVmFsdWU7XG5cdH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZGF0YS9Qcm9jZXNzV2l0aC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///37\n')},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, evil:true, vars:true, plusplus:true */\n/*global module, require */\n\nmodule.exports = function(func, args) {\n  var _ = __webpack_require__(0);\n  __webpack_require__(5)();\n  \n  if(_.isSet(func))\n  {\n\t  func = eval(func);\n  }\n  \n  this.run = function() {\n\t  if(_.isFunction(func))\n\t  {\n\t\t  return (args && _.isArray(args)) ? func.apply(this, args) : func.call(this);\n\t  }\n\t  else\n\t  {\n\t\t  return null;\n\t  }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9TdHJpbmdGdW5jdGlvbi5qcz85MjFmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG1CQUFPLENBQUMsQ0FBWTtBQUM5QixFQUFFLG1CQUFPLENBQUMsQ0FBbUM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCBldmlsOnRydWUsIHZhcnM6dHJ1ZSwgcGx1c3BsdXM6dHJ1ZSAqL1xuLypnbG9iYWwgbW9kdWxlLCByZXF1aXJlICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZnVuYywgYXJncykge1xuICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuICByZXF1aXJlKFwiLi4vLi4vbGliL3VuZGVyc2NvcmVfbWl4aW5zL2lzU2V0XCIpKCk7XG4gIFxuICBpZihfLmlzU2V0KGZ1bmMpKVxuICB7XG5cdCAgZnVuYyA9IGV2YWwoZnVuYyk7XG4gIH1cbiAgXG4gIHRoaXMucnVuID0gZnVuY3Rpb24oKSB7XG5cdCAgaWYoXy5pc0Z1bmN0aW9uKGZ1bmMpKVxuXHQgIHtcblx0XHQgIHJldHVybiAoYXJncyAmJiBfLmlzQXJyYXkoYXJncykpID8gZnVuYy5hcHBseSh0aGlzLCBhcmdzKSA6IGZ1bmMuY2FsbCh0aGlzKTtcblx0ICB9XG5cdCAgZWxzZVxuXHQgIHtcblx0XHQgIHJldHVybiBudWxsO1xuXHQgIH1cbiAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9kYXRhL1N0cmluZ0Z1bmN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///38\n")},function(module,exports,__webpack_require__){eval('/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, require */\n\nmodule.exports = function(data) {\n\n\tvar _ = __webpack_require__(0);\n  var FunctionRunner = __webpack_require__(6);\n  var TokenReplacer = __webpack_require__(4);\n\n  var tokenReplacer;\n\n  // returns an array of all values to be join\'d on by the appropriate separator later.\n  // Processes {interp:""} objects and {func:"",args[]} objects and rolls them up into\n  // an array with nothing but strings in it\n  var processAndReturnStringArray = function(obj) {\n\n    // Return maped array that cleans up interps and func and args objects and replaces values\n    return _.map(obj, function(val) {\n\n      var retr = val;\n\n      // first check to see if our val is an object, because if it is it\'ll need additional\n      // processing.  If it\'s a string, we just return it at the end without even processing.\n      if (_.isObject(val)) {\n\n        // Once we know we have an object then we can determine whether we have an interp object\n        // which would require just a simple replace of the token value inside it and then return\n        // making it no longer an object.\n        if (_.isString(val.interp)) {\n          retr = tokenReplacer.replace(val.interp);\n          if (retr.indexOf("=") === retr.length - 1 && !val.insertIfEmpty) {\n            retr = "";\n          }\n\n          // This one would be the case for a func and args array (formerly multi). First we make sure\n          // that we have both the func as a string (for eval) or as an actual function and the args\n          // as an array.\n        } else if (_.isString(val.func) && _.isArray(val.args)) {\n\n          retr = FunctionRunner(val, data);\n\n          // This is the catch all case where it\'s some weird object that we don\'t know what it is.  In\n          // most cases I would just ignore this, however we\'ll get unusual results if we return a strigified\n          // version of [object Object] so we\'ll explicitly send back an empty string\n        } else {\n\n          // was an object of some kind, but now is an empty string\n          retr = "";\n        }\n      } // end if(is object)\n      // return of mapped value.  If it was an object it got some special processing.  If it was a string\n      // it\'ll be returned untouched.\n      return retr;\n    });\n  };\n\n  // holds the final calculated value derived from the uriSpec\n  var caluclatedURI;\n\n  // Create our tokenReplacer if we need to.  If there is no Data object passed in, that implicitly means\n  // there are no string substituions for tokens.  In that case, we don\'t need to replace them with\n  // the TokenReplacer class.\n  tokenReplacer = new TokenReplacer(data);\n\n  // Function for setting the URI value.  Call in context of data object if the eval\'s contained within it need to reference it as "this"\n  this.setURI = function(uriSpec) {\n\n    // placeholders for initial and calculated values of each\n    var origin;\n    var pathname;\n    var search;\n    var hash;\n\n    // Takes origin object and converts it to a protocol + hostname (with subdomains)\n    var buildOrigin = function(origin) {\n      var retr = "",\n        host, hostname, port;\n\n      if (_.isObject(origin)) {\n\n        host = origin.host;\n\n        if (_.isObject(host) && !_.isUndefined(host.hostname)) {\n\n          hostname = host.hostname;\n\n          if (_.isObject(hostname)) {\n            hostname = processAndReturnStringArray(hostname).join(".");\n          }\n          if (!_.isUndefined(host.port)) {\n            port = host.port;\n          }\n\n          host = _.isUndefined(port) ? hostname : hostname + \':\' + port;\n          retr = origin.protocol ? origin.protocol + \'://\' + host : "//" + host;\n        }\n\n      } else if (_.isString(origin)) {\n        retr = origin;\n      }\n      return retr;\n    };\n\n    // MAIN URI CODE\n    if (uriSpec) {\n      // if the src is a string return that\n      if (_.isString(uriSpec)) {\n        caluclatedURI = uriSpec;\n      } else {\n        // if the src isn\'t a string we have to concatenate origin + pathname + search + hash\n        // First we do the source\n        origin = uriSpec.origin;\n        origin = buildOrigin(origin);\n\n        // Then we do the pathname\n        pathname = uriSpec.pathname;\n        pathname = (_.isUndefined(pathname)) ? \'\' : (_.isString(pathname)) ? \'/\' + pathname : _.prependArray(processAndReturnStringArray(pathname), "").join("/");\n\n        //Then we do the Search\n        search = uriSpec.search;\n        if (_.isUndefined(search)) {\n          search = \'\';\n        } else if (_.isString(search)) {\n          search = "?" + search;\n        } else {\n          search = "?" + _.without(processAndReturnStringArray(search), "").join(uriSpec.separatedBy || "&");\n        }\n\n        //Then we do the Search\n        hash = uriSpec.hash;\n        hash = (_.isUndefined(hash)) ? \'\' : (_.isString(hash)) ? \'#\' + hash : \'\';\n\n        //Finally we concatenate and put in the caluclatedURI\n        caluclatedURI = origin + pathname + search + hash;\n      }\n    }\n    if (data) {\n      data.setTagSrc(caluclatedURI);\n    }\n    return this;\n  };\n  //`.getURI()`: Getter Funciton to return the calculated URI\n  this.getURI = function() {\n    return caluclatedURI;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9VUkkuanM/NDAwYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyxDQUFZO0FBQzdCLHVCQUF1QixtQkFBTyxDQUFDLENBQXdCO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLENBQWlCOztBQUUvQzs7QUFFQTtBQUNBLGdCQUFnQixVQUFVLGNBQWMsZUFBZTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIGV2aWw6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIG5vbWVuOiB0cnVlLCByZWdleHA6IHRydWUsIHZhcnM6dHJ1ZSwgcGx1c3BsdXM6dHJ1ZSAqL1xuLypnbG9iYWwgbW9kdWxlLCByZXF1aXJlICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSkge1xuXG5cdHZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG4gIHZhciBGdW5jdGlvblJ1bm5lciA9IHJlcXVpcmUoXCIuLi9kYXRhL0Z1bmN0aW9uUnVubmVyXCIpO1xuICB2YXIgVG9rZW5SZXBsYWNlciA9IHJlcXVpcmUoXCIuL1Rva2VuUmVwbGFjZXJcIik7XG5cbiAgdmFyIHRva2VuUmVwbGFjZXI7XG5cbiAgLy8gcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdmFsdWVzIHRvIGJlIGpvaW4nZCBvbiBieSB0aGUgYXBwcm9wcmlhdGUgc2VwYXJhdG9yIGxhdGVyLlxuICAvLyBQcm9jZXNzZXMge2ludGVycDpcIlwifSBvYmplY3RzIGFuZCB7ZnVuYzpcIlwiLGFyZ3NbXX0gb2JqZWN0cyBhbmQgcm9sbHMgdGhlbSB1cCBpbnRvXG4gIC8vIGFuIGFycmF5IHdpdGggbm90aGluZyBidXQgc3RyaW5ncyBpbiBpdFxuICB2YXIgcHJvY2Vzc0FuZFJldHVyblN0cmluZ0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG5cbiAgICAvLyBSZXR1cm4gbWFwZWQgYXJyYXkgdGhhdCBjbGVhbnMgdXAgaW50ZXJwcyBhbmQgZnVuYyBhbmQgYXJncyBvYmplY3RzIGFuZCByZXBsYWNlcyB2YWx1ZXNcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWwpIHtcblxuICAgICAgdmFyIHJldHIgPSB2YWw7XG5cbiAgICAgIC8vIGZpcnN0IGNoZWNrIHRvIHNlZSBpZiBvdXIgdmFsIGlzIGFuIG9iamVjdCwgYmVjYXVzZSBpZiBpdCBpcyBpdCdsbCBuZWVkIGFkZGl0aW9uYWxcbiAgICAgIC8vIHByb2Nlc3NpbmcuICBJZiBpdCdzIGEgc3RyaW5nLCB3ZSBqdXN0IHJldHVybiBpdCBhdCB0aGUgZW5kIHdpdGhvdXQgZXZlbiBwcm9jZXNzaW5nLlxuICAgICAgaWYgKF8uaXNPYmplY3QodmFsKSkge1xuXG4gICAgICAgIC8vIE9uY2Ugd2Uga25vdyB3ZSBoYXZlIGFuIG9iamVjdCB0aGVuIHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB3ZSBoYXZlIGFuIGludGVycCBvYmplY3RcbiAgICAgICAgLy8gd2hpY2ggd291bGQgcmVxdWlyZSBqdXN0IGEgc2ltcGxlIHJlcGxhY2Ugb2YgdGhlIHRva2VuIHZhbHVlIGluc2lkZSBpdCBhbmQgdGhlbiByZXR1cm5cbiAgICAgICAgLy8gbWFraW5nIGl0IG5vIGxvbmdlciBhbiBvYmplY3QuXG4gICAgICAgIGlmIChfLmlzU3RyaW5nKHZhbC5pbnRlcnApKSB7XG4gICAgICAgICAgcmV0ciA9IHRva2VuUmVwbGFjZXIucmVwbGFjZSh2YWwuaW50ZXJwKTtcbiAgICAgICAgICBpZiAocmV0ci5pbmRleE9mKFwiPVwiKSA9PT0gcmV0ci5sZW5ndGggLSAxICYmICF2YWwuaW5zZXJ0SWZFbXB0eSkge1xuICAgICAgICAgICAgcmV0ciA9IFwiXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhpcyBvbmUgd291bGQgYmUgdGhlIGNhc2UgZm9yIGEgZnVuYyBhbmQgYXJncyBhcnJheSAoZm9ybWVybHkgbXVsdGkpLiBGaXJzdCB3ZSBtYWtlIHN1cmVcbiAgICAgICAgICAvLyB0aGF0IHdlIGhhdmUgYm90aCB0aGUgZnVuYyBhcyBhIHN0cmluZyAoZm9yIGV2YWwpIG9yIGFzIGFuIGFjdHVhbCBmdW5jdGlvbiBhbmQgdGhlIGFyZ3NcbiAgICAgICAgICAvLyBhcyBhbiBhcnJheS5cbiAgICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHZhbC5mdW5jKSAmJiBfLmlzQXJyYXkodmFsLmFyZ3MpKSB7XG5cbiAgICAgICAgICByZXRyID0gRnVuY3Rpb25SdW5uZXIodmFsLCBkYXRhKTtcblxuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGNhdGNoIGFsbCBjYXNlIHdoZXJlIGl0J3Mgc29tZSB3ZWlyZCBvYmplY3QgdGhhdCB3ZSBkb24ndCBrbm93IHdoYXQgaXQgaXMuICBJblxuICAgICAgICAgIC8vIG1vc3QgY2FzZXMgSSB3b3VsZCBqdXN0IGlnbm9yZSB0aGlzLCBob3dldmVyIHdlJ2xsIGdldCB1bnVzdWFsIHJlc3VsdHMgaWYgd2UgcmV0dXJuIGEgc3RyaWdpZmllZFxuICAgICAgICAgIC8vIHZlcnNpb24gb2YgW29iamVjdCBPYmplY3RdIHNvIHdlJ2xsIGV4cGxpY2l0bHkgc2VuZCBiYWNrIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gd2FzIGFuIG9iamVjdCBvZiBzb21lIGtpbmQsIGJ1dCBub3cgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgcmV0ciA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZW5kIGlmKGlzIG9iamVjdClcbiAgICAgIC8vIHJldHVybiBvZiBtYXBwZWQgdmFsdWUuICBJZiBpdCB3YXMgYW4gb2JqZWN0IGl0IGdvdCBzb21lIHNwZWNpYWwgcHJvY2Vzc2luZy4gIElmIGl0IHdhcyBhIHN0cmluZ1xuICAgICAgLy8gaXQnbGwgYmUgcmV0dXJuZWQgdW50b3VjaGVkLlxuICAgICAgcmV0dXJuIHJldHI7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gaG9sZHMgdGhlIGZpbmFsIGNhbGN1bGF0ZWQgdmFsdWUgZGVyaXZlZCBmcm9tIHRoZSB1cmlTcGVjXG4gIHZhciBjYWx1Y2xhdGVkVVJJO1xuXG4gIC8vIENyZWF0ZSBvdXIgdG9rZW5SZXBsYWNlciBpZiB3ZSBuZWVkIHRvLiAgSWYgdGhlcmUgaXMgbm8gRGF0YSBvYmplY3QgcGFzc2VkIGluLCB0aGF0IGltcGxpY2l0bHkgbWVhbnNcbiAgLy8gdGhlcmUgYXJlIG5vIHN0cmluZyBzdWJzdGl0dWlvbnMgZm9yIHRva2Vucy4gIEluIHRoYXQgY2FzZSwgd2UgZG9uJ3QgbmVlZCB0byByZXBsYWNlIHRoZW0gd2l0aFxuICAvLyB0aGUgVG9rZW5SZXBsYWNlciBjbGFzcy5cbiAgdG9rZW5SZXBsYWNlciA9IG5ldyBUb2tlblJlcGxhY2VyKGRhdGEpO1xuXG4gIC8vIEZ1bmN0aW9uIGZvciBzZXR0aW5nIHRoZSBVUkkgdmFsdWUuICBDYWxsIGluIGNvbnRleHQgb2YgZGF0YSBvYmplY3QgaWYgdGhlIGV2YWwncyBjb250YWluZWQgd2l0aGluIGl0IG5lZWQgdG8gcmVmZXJlbmNlIGl0IGFzIFwidGhpc1wiXG4gIHRoaXMuc2V0VVJJID0gZnVuY3Rpb24odXJpU3BlYykge1xuXG4gICAgLy8gcGxhY2Vob2xkZXJzIGZvciBpbml0aWFsIGFuZCBjYWxjdWxhdGVkIHZhbHVlcyBvZiBlYWNoXG4gICAgdmFyIG9yaWdpbjtcbiAgICB2YXIgcGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaDtcbiAgICB2YXIgaGFzaDtcblxuICAgIC8vIFRha2VzIG9yaWdpbiBvYmplY3QgYW5kIGNvbnZlcnRzIGl0IHRvIGEgcHJvdG9jb2wgKyBob3N0bmFtZSAod2l0aCBzdWJkb21haW5zKVxuICAgIHZhciBidWlsZE9yaWdpbiA9IGZ1bmN0aW9uKG9yaWdpbikge1xuICAgICAgdmFyIHJldHIgPSBcIlwiLFxuICAgICAgICBob3N0LCBob3N0bmFtZSwgcG9ydDtcblxuICAgICAgaWYgKF8uaXNPYmplY3Qob3JpZ2luKSkge1xuXG4gICAgICAgIGhvc3QgPSBvcmlnaW4uaG9zdDtcblxuICAgICAgICBpZiAoXy5pc09iamVjdChob3N0KSAmJiAhXy5pc1VuZGVmaW5lZChob3N0Lmhvc3RuYW1lKSkge1xuXG4gICAgICAgICAgaG9zdG5hbWUgPSBob3N0Lmhvc3RuYW1lO1xuXG4gICAgICAgICAgaWYgKF8uaXNPYmplY3QoaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICBob3N0bmFtZSA9IHByb2Nlc3NBbmRSZXR1cm5TdHJpbmdBcnJheShob3N0bmFtZSkuam9pbihcIi5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChob3N0LnBvcnQpKSB7XG4gICAgICAgICAgICBwb3J0ID0gaG9zdC5wb3J0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhvc3QgPSBfLmlzVW5kZWZpbmVkKHBvcnQpID8gaG9zdG5hbWUgOiBob3N0bmFtZSArICc6JyArIHBvcnQ7XG4gICAgICAgICAgcmV0ciA9IG9yaWdpbi5wcm90b2NvbCA/IG9yaWdpbi5wcm90b2NvbCArICc6Ly8nICsgaG9zdCA6IFwiLy9cIiArIGhvc3Q7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKG9yaWdpbikpIHtcbiAgICAgICAgcmV0ciA9IG9yaWdpbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRyO1xuICAgIH07XG5cbiAgICAvLyBNQUlOIFVSSSBDT0RFXG4gICAgaWYgKHVyaVNwZWMpIHtcbiAgICAgIC8vIGlmIHRoZSBzcmMgaXMgYSBzdHJpbmcgcmV0dXJuIHRoYXRcbiAgICAgIGlmIChfLmlzU3RyaW5nKHVyaVNwZWMpKSB7XG4gICAgICAgIGNhbHVjbGF0ZWRVUkkgPSB1cmlTcGVjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgdGhlIHNyYyBpc24ndCBhIHN0cmluZyB3ZSBoYXZlIHRvIGNvbmNhdGVuYXRlIG9yaWdpbiArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaFxuICAgICAgICAvLyBGaXJzdCB3ZSBkbyB0aGUgc291cmNlXG4gICAgICAgIG9yaWdpbiA9IHVyaVNwZWMub3JpZ2luO1xuICAgICAgICBvcmlnaW4gPSBidWlsZE9yaWdpbihvcmlnaW4pO1xuXG4gICAgICAgIC8vIFRoZW4gd2UgZG8gdGhlIHBhdGhuYW1lXG4gICAgICAgIHBhdGhuYW1lID0gdXJpU3BlYy5wYXRobmFtZTtcbiAgICAgICAgcGF0aG5hbWUgPSAoXy5pc1VuZGVmaW5lZChwYXRobmFtZSkpID8gJycgOiAoXy5pc1N0cmluZyhwYXRobmFtZSkpID8gJy8nICsgcGF0aG5hbWUgOiBfLnByZXBlbmRBcnJheShwcm9jZXNzQW5kUmV0dXJuU3RyaW5nQXJyYXkocGF0aG5hbWUpLCBcIlwiKS5qb2luKFwiL1wiKTtcblxuICAgICAgICAvL1RoZW4gd2UgZG8gdGhlIFNlYXJjaFxuICAgICAgICBzZWFyY2ggPSB1cmlTcGVjLnNlYXJjaDtcbiAgICAgICAgaWYgKF8uaXNVbmRlZmluZWQoc2VhcmNoKSkge1xuICAgICAgICAgIHNlYXJjaCA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoc2VhcmNoKSkge1xuICAgICAgICAgIHNlYXJjaCA9IFwiP1wiICsgc2VhcmNoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlYXJjaCA9IFwiP1wiICsgXy53aXRob3V0KHByb2Nlc3NBbmRSZXR1cm5TdHJpbmdBcnJheShzZWFyY2gpLCBcIlwiKS5qb2luKHVyaVNwZWMuc2VwYXJhdGVkQnkgfHwgXCImXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9UaGVuIHdlIGRvIHRoZSBTZWFyY2hcbiAgICAgICAgaGFzaCA9IHVyaVNwZWMuaGFzaDtcbiAgICAgICAgaGFzaCA9IChfLmlzVW5kZWZpbmVkKGhhc2gpKSA/ICcnIDogKF8uaXNTdHJpbmcoaGFzaCkpID8gJyMnICsgaGFzaCA6ICcnO1xuXG4gICAgICAgIC8vRmluYWxseSB3ZSBjb25jYXRlbmF0ZSBhbmQgcHV0IGluIHRoZSBjYWx1Y2xhdGVkVVJJXG4gICAgICAgIGNhbHVjbGF0ZWRVUkkgPSBvcmlnaW4gKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhKSB7XG4gICAgICBkYXRhLnNldFRhZ1NyYyhjYWx1Y2xhdGVkVVJJKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8vYC5nZXRVUkkoKWA6IEdldHRlciBGdW5jaXRvbiB0byByZXR1cm4gdGhlIGNhbGN1bGF0ZWQgVVJJXG4gIHRoaXMuZ2V0VVJJID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGNhbHVjbGF0ZWRVUkk7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZGF0YS9VUkkuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///39\n')},function(module,exports,__webpack_require__){eval('/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, plusplus:true, vars:true */\n/*global module, require */\n\nmodule.exports = function(sparseRequest, locale, siteId, udo, overrides) {\n  var self = this;\n  var _ = __webpack_require__(0);\n  var Deferrable = __webpack_require__(2);\n  var xmlHttp = new XMLHttpRequest();\n  var tagServerURI = "https://secure-cdn.mplxtms.com/siteJSON/" + siteId + "/" + siteId + ".json";\n  var request = {\n    method: "getContainer"\n  };\n  var responseHandler = function() {\n    var resObj;\n    if (xmlHttp.status === 200 && xmlHttp.readyState === 4) {\n      try {\n        resObj = JSON.parse(xmlHttp.responseText).result;\n        xmlHttp.onreadystatechange = null;\n        self.resolve(resObj);\n      } catch (err) {\n        self.reject({\n          err: "unable to parse response from server"\n        });\n      }\n    }\n  };\n\n  // Create Our request\n  _.extend(request, sparseRequest);\n\n  // set specific parameters\n  _.extend(request.params, {\n    referrer: document.referrer,\n    href: document.location.href,\n    meta: siteId,\n    siteId: siteId\n  });\n  if (_.isObject(udo)) {\n    request.params.MasterTmsUdo = udo;\n  }\n\n  // If we have some overrides to parameters\n  if (_.isObject(overrides)) {\n    request.params = _.extend(request.params, overrides);\n  }\n\n  _.extend(self, Deferrable);\n  self.init();\n\n  if(_.isObject(locale.container)) {\n\n    self.resolve(locale.container);\n\n  } else {\n\n    xmlHttp.withCredentials = false;\n    xmlHttp.open(\'get\', tagServerURI);\n    xmlHttp.onreadystatechange = responseHandler;\n    xmlHttp.send();\n  }\n\n  return self;\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9ycGMvUlBDUG9zdEdldENvbnRhaW5lci5qcz9jMGUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsbUJBQU8sQ0FBQyxDQUFZO0FBQzlCLG1CQUFtQixtQkFBTyxDQUFDLENBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBldmlsOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcGx1c3BsdXM6dHJ1ZSwgdmFyczp0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHJlcXVpcmUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcGFyc2VSZXF1ZXN0LCBsb2NhbGUsIHNpdGVJZCwgdWRvLCBvdmVycmlkZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuICB2YXIgRGVmZXJyYWJsZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL0RlZmVycmFibGVcIik7XG4gIHZhciB4bWxIdHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIHZhciB0YWdTZXJ2ZXJVUkkgPSBcImh0dHBzOi8vc2VjdXJlLWNkbi5tcGx4dG1zLmNvbS9zaXRlSlNPTi9cIiArIHNpdGVJZCArIFwiL1wiICsgc2l0ZUlkICsgXCIuanNvblwiO1xuICB2YXIgcmVxdWVzdCA9IHtcbiAgICBtZXRob2Q6IFwiZ2V0Q29udGFpbmVyXCJcbiAgfTtcbiAgdmFyIHJlc3BvbnNlSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNPYmo7XG4gICAgaWYgKHhtbEh0dHAuc3RhdHVzID09PSAyMDAgJiYgeG1sSHR0cC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXNPYmogPSBKU09OLnBhcnNlKHhtbEh0dHAucmVzcG9uc2VUZXh0KS5yZXN1bHQ7XG4gICAgICAgIHhtbEh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgc2VsZi5yZXNvbHZlKHJlc09iaik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2VsZi5yZWplY3Qoe1xuICAgICAgICAgIGVycjogXCJ1bmFibGUgdG8gcGFyc2UgcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gQ3JlYXRlIE91ciByZXF1ZXN0XG4gIF8uZXh0ZW5kKHJlcXVlc3QsIHNwYXJzZVJlcXVlc3QpO1xuXG4gIC8vIHNldCBzcGVjaWZpYyBwYXJhbWV0ZXJzXG4gIF8uZXh0ZW5kKHJlcXVlc3QucGFyYW1zLCB7XG4gICAgcmVmZXJyZXI6IGRvY3VtZW50LnJlZmVycmVyLFxuICAgIGhyZWY6IGRvY3VtZW50LmxvY2F0aW9uLmhyZWYsXG4gICAgbWV0YTogc2l0ZUlkLFxuICAgIHNpdGVJZDogc2l0ZUlkXG4gIH0pO1xuICBpZiAoXy5pc09iamVjdCh1ZG8pKSB7XG4gICAgcmVxdWVzdC5wYXJhbXMuTWFzdGVyVG1zVWRvID0gdWRvO1xuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZSBzb21lIG92ZXJyaWRlcyB0byBwYXJhbWV0ZXJzXG4gIGlmIChfLmlzT2JqZWN0KG92ZXJyaWRlcykpIHtcbiAgICByZXF1ZXN0LnBhcmFtcyA9IF8uZXh0ZW5kKHJlcXVlc3QucGFyYW1zLCBvdmVycmlkZXMpO1xuICB9XG5cbiAgXy5leHRlbmQoc2VsZiwgRGVmZXJyYWJsZSk7XG4gIHNlbGYuaW5pdCgpO1xuXG4gIGlmKF8uaXNPYmplY3QobG9jYWxlLmNvbnRhaW5lcikpIHtcblxuICAgIHNlbGYucmVzb2x2ZShsb2NhbGUuY29udGFpbmVyKTtcblxuICB9IGVsc2Uge1xuXG4gICAgeG1sSHR0cC53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcbiAgICB4bWxIdHRwLm9wZW4oJ2dldCcsIHRhZ1NlcnZlclVSSSk7XG4gICAgeG1sSHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByZXNwb25zZUhhbmRsZXI7XG4gICAgeG1sSHR0cC5zZW5kKCk7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2RhdGEvcnBjL1JQQ1Bvc3RHZXRDb250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///40\n')},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, white: true, nomen: true, vars:true, plusplus:true */\n/*global conversant, module, require */\n\nmodule.exports = function (sparseRequest, locale, plugIns) {\n\t\tvar self = this;\n\t\tvar _ = __webpack_require__(0);\n\t\tvar $ = __webpack_require__(1);\n\t\tvar Deferrable = __webpack_require__(2);\n\t\tvar xmlHttp = new XMLHttpRequest();\n\t\tvar tagServerURI = "//n.mplxtms.com/tags";\n\t\tvar request = {\n\t\t\tmethod: "containerNotification"\n\t\t};\n\t\tvar newParams = {\n\t\t\tplugIns: plugIns,\n\t\t\tid: conversant.tagManager.container.id\n\t\t};\n\t\tvar responseHandler = function () {\n\t\t\t\tself.resolve(plugIns);\n\t\t\t\txmlHttp.removeEventListener("load", responseHandler);\n\t\t\t};\n\n\t\t_.extend(self, Deferrable);\n\t\tself.init();\n\n        // no more notifications\n        self.resolve({});\n\n        if(tagServerURI === \'\') {\n\n          self.resolve({});\n\n        } else {\n\n          // Create Our request\n          $.extend(true, request, sparseRequest);\n\n          // add specific parameters\n          newParams.meta = request.params.meta;\n          newParams.version = request.params.version;\n          request.params = newParams;\n\n          xmlHttp.open(\'post\', tagServerURI);\n          xmlHttp.addEventListener("load", responseHandler);\n\n          if(Object.toJSON) {\n\n              request = Object.toJSON(request);\n\n          } else {\n\n              request = JSON.stringify(request);\n\n          }\n\n          xmlHttp.send(request);\n\n        }\n\n\t\treturn self;\n\n\t};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZGF0YS9ycGMvUlBDUG9zdFNlbmROb3RpZmljYXRpb24uanM/NDE3NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsQ0FBWTtBQUM5QixVQUFVLG1CQUFPLENBQUMsQ0FBTztBQUN6QixtQkFBbUIsbUJBQU8sQ0FBQyxDQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2Qjs7QUFFQSx5QkFBeUI7O0FBRXpCLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEiLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgdmFyczp0cnVlLCBwbHVzcGx1czp0cnVlICovXG4vKmdsb2JhbCBjb252ZXJzYW50LCBtb2R1bGUsIHJlcXVpcmUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3BhcnNlUmVxdWVzdCwgbG9jYWxlLCBwbHVnSW5zKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5cdFx0dmFyICQgPSByZXF1aXJlKFwiemVwdG9cIik7XG5cdFx0dmFyIERlZmVycmFibGUgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9EZWZlcnJhYmxlXCIpO1xuXHRcdHZhciB4bWxIdHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cdFx0dmFyIHRhZ1NlcnZlclVSSSA9IFwiLy9uLm1wbHh0bXMuY29tL3RhZ3NcIjtcblx0XHR2YXIgcmVxdWVzdCA9IHtcblx0XHRcdG1ldGhvZDogXCJjb250YWluZXJOb3RpZmljYXRpb25cIlxuXHRcdH07XG5cdFx0dmFyIG5ld1BhcmFtcyA9IHtcblx0XHRcdHBsdWdJbnM6IHBsdWdJbnMsXG5cdFx0XHRpZDogY29udmVyc2FudC50YWdNYW5hZ2VyLmNvbnRhaW5lci5pZFxuXHRcdH07XG5cdFx0dmFyIHJlc3BvbnNlSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5yZXNvbHZlKHBsdWdJbnMpO1xuXHRcdFx0XHR4bWxIdHRwLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlc3BvbnNlSGFuZGxlcik7XG5cdFx0XHR9O1xuXG5cdFx0Xy5leHRlbmQoc2VsZiwgRGVmZXJyYWJsZSk7XG5cdFx0c2VsZi5pbml0KCk7XG5cbiAgICAgICAgLy8gbm8gbW9yZSBub3RpZmljYXRpb25zXG4gICAgICAgIHNlbGYucmVzb2x2ZSh7fSk7XG5cbiAgICAgICAgaWYodGFnU2VydmVyVVJJID09PSAnJykge1xuXG4gICAgICAgICAgc2VsZi5yZXNvbHZlKHt9KTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gQ3JlYXRlIE91ciByZXF1ZXN0XG4gICAgICAgICAgJC5leHRlbmQodHJ1ZSwgcmVxdWVzdCwgc3BhcnNlUmVxdWVzdCk7XG5cbiAgICAgICAgICAvLyBhZGQgc3BlY2lmaWMgcGFyYW1ldGVyc1xuICAgICAgICAgIG5ld1BhcmFtcy5tZXRhID0gcmVxdWVzdC5wYXJhbXMubWV0YTtcbiAgICAgICAgICBuZXdQYXJhbXMudmVyc2lvbiA9IHJlcXVlc3QucGFyYW1zLnZlcnNpb247XG4gICAgICAgICAgcmVxdWVzdC5wYXJhbXMgPSBuZXdQYXJhbXM7XG5cbiAgICAgICAgICB4bWxIdHRwLm9wZW4oJ3Bvc3QnLCB0YWdTZXJ2ZXJVUkkpO1xuICAgICAgICAgIHhtbEh0dHAuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVzcG9uc2VIYW5kbGVyKTtcblxuICAgICAgICAgIGlmKE9iamVjdC50b0pTT04pIHtcblxuICAgICAgICAgICAgICByZXF1ZXN0ID0gT2JqZWN0LnRvSlNPTihyZXF1ZXN0KTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgcmVxdWVzdCA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeG1sSHR0cC5zZW5kKHJlcXVlc3QpO1xuXG4gICAgICAgIH1cblxuXHRcdHJldHVybiBzZWxmO1xuXG5cdH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9kYXRhL3JwYy9SUENQb3N0U2VuZE5vdGlmaWNhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41\n')},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, require*/\n\n// DivElement is a subclass of BuildElement. Creates a DIV element and puts\n// the innerHTML in there.\nmodule.exports = function(props) {\n  var self = this;\n  var _ = __webpack_require__(0);\n  var $ = __webpack_require__(1);\n  var BuildElement = __webpack_require__(3);\n  var TokenReplacer = __webpack_require__(4);\n  var tokenReplacer;\n  var data = props.data;\n  var innerHTML = props.plugIn.attr.innerHTML;\n  var i = 0;\n  var processNextElement;\n  var scriptNodes;\n  var scriptNodeLength;\n  var element;\n  var firstScriptSrc = true;\n\n\tif(!props.plugIn.attr.tag) {\n\t\tprops.plugIn.attr.tag = "div";\n\t}\n\n  _.extend(self, BuildElement);\n\n  self.init(props);\n\n\n  // an `innerHTML` property, by the specification, can be an object or just a string.\n  // in the event that it is an object that means it may have data in it that need to be\n  // injected into the page from our `dataDef` and subsequently `data`, which is our\n  // data that was resolved client side.\n\n  if (_.isObject(innerHTML) && innerHTML.interp) {\n    // Create our `TokenReplacer` with the reference to `data`\n    tokenReplacer = new TokenReplacer(data);\n\n    // This does two things, one it will return a string which will normalize our format\n    // for further processing. The second thing being it will now go through and replace\n    // the data reference tokens with the data values.\n    innerHTML = tokenReplacer.replace(innerHTML.interp);\n  }\n\n  // this will set the innerHTML to the value passed in but no scripts will execute\n  // so therefore we\'re going to need to traverse the elements and execute them\n  self.docFrag[0].innerHTML = innerHTML;\n\n  // Get all of our script nodes to execute in order\n  scriptNodes = $("script", self.docFrag);\n\n  scriptNodeLength = scriptNodes.length;\n\n  // precache script srcs, kick off concurrent downloads\n  _.each(scriptNodes, function(scriptNode) {\n    if (scriptNode.src !== "") {\n      if (firstScriptSrc) {\n        firstScriptSrc = false;\n      } else {\n        element = document.createElement("img");\n        element.src = scriptNode.src;\n      }\n    }\n  });\n\n  // create a recursive function to chunk through each script element and either eval\n  // it if it\'s an inline script, or go and load the source.\n  processNextElement = function() {\n    var curNode = scriptNodes[i];\n    var newNode;\n    var parentNode = curNode.parentNode;\n    var iterate = function() {\n      i++;\n      if (i < scriptNodeLength) {\n        processNextElement();\n      } else {\n        self.resolve(props.plugIn);\n      }\n    };\n    var swapForLiveScript = function() {\n      parentNode.insertBefore(newNode, curNode);\n      parentNode.removeChild(curNode);\n    };\n\n    newNode = document.createElement("script");\n\n    // script with src\n    if (curNode.src !== "") {\n      newNode.addEventListener("load", function() {\n        setTimeout(iterate, 0);\n      });\n\t\t\tnewNode.addEventListener("error", iterate);\n      newNode.src = curNode.src;\n      swapForLiveScript();\n    } else {\n      // inline script\n      newNode.innerHTML = curNode.innerHTML;\n      swapForLiveScript();\n      iterate();\n    }\n  };\n  if (scriptNodeLength > 0) {\n    processNextElement();\n  } else {\n    self.resolve(props.plugIn);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL0RpdkVsZW1lbnQuanM/YzQ0NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQVk7QUFDOUIsVUFBVSxtQkFBTyxDQUFDLENBQU87QUFDekIscUJBQXFCLG1CQUFPLENBQUMsQ0FBZ0I7QUFDN0Msc0JBQXNCLG1CQUFPLENBQUMsQ0FBdUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwiZmlsZSI6IjQyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgbm9tZW46IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdmFyczp0cnVlLCBwbHVzcGx1czp0cnVlICovXG4vKmdsb2JhbCBtb2R1bGUsIHJlcXVpcmUqL1xuXG4vLyBEaXZFbGVtZW50IGlzIGEgc3ViY2xhc3Mgb2YgQnVpbGRFbGVtZW50LiBDcmVhdGVzIGEgRElWIGVsZW1lbnQgYW5kIHB1dHNcbi8vIHRoZSBpbm5lckhUTUwgaW4gdGhlcmUuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbiAgdmFyICQgPSByZXF1aXJlKFwiemVwdG9cIik7XG4gIHZhciBCdWlsZEVsZW1lbnQgPSByZXF1aXJlKFwiLi9CdWlsZEVsZW1lbnRcIik7XG4gIHZhciBUb2tlblJlcGxhY2VyID0gcmVxdWlyZShcIi4uL2RhdGEvVG9rZW5SZXBsYWNlclwiKTtcbiAgdmFyIHRva2VuUmVwbGFjZXI7XG4gIHZhciBkYXRhID0gcHJvcHMuZGF0YTtcbiAgdmFyIGlubmVySFRNTCA9IHByb3BzLnBsdWdJbi5hdHRyLmlubmVySFRNTDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcHJvY2Vzc05leHRFbGVtZW50O1xuICB2YXIgc2NyaXB0Tm9kZXM7XG4gIHZhciBzY3JpcHROb2RlTGVuZ3RoO1xuICB2YXIgZWxlbWVudDtcbiAgdmFyIGZpcnN0U2NyaXB0U3JjID0gdHJ1ZTtcblxuXHRpZighcHJvcHMucGx1Z0luLmF0dHIudGFnKSB7XG5cdFx0cHJvcHMucGx1Z0luLmF0dHIudGFnID0gXCJkaXZcIjtcblx0fVxuXG4gIF8uZXh0ZW5kKHNlbGYsIEJ1aWxkRWxlbWVudCk7XG5cbiAgc2VsZi5pbml0KHByb3BzKTtcblxuXG4gIC8vIGFuIGBpbm5lckhUTUxgIHByb3BlcnR5LCBieSB0aGUgc3BlY2lmaWNhdGlvbiwgY2FuIGJlIGFuIG9iamVjdCBvciBqdXN0IGEgc3RyaW5nLlxuICAvLyBpbiB0aGUgZXZlbnQgdGhhdCBpdCBpcyBhbiBvYmplY3QgdGhhdCBtZWFucyBpdCBtYXkgaGF2ZSBkYXRhIGluIGl0IHRoYXQgbmVlZCB0byBiZVxuICAvLyBpbmplY3RlZCBpbnRvIHRoZSBwYWdlIGZyb20gb3VyIGBkYXRhRGVmYCBhbmQgc3Vic2VxdWVudGx5IGBkYXRhYCwgd2hpY2ggaXMgb3VyXG4gIC8vIGRhdGEgdGhhdCB3YXMgcmVzb2x2ZWQgY2xpZW50IHNpZGUuXG5cbiAgaWYgKF8uaXNPYmplY3QoaW5uZXJIVE1MKSAmJiBpbm5lckhUTUwuaW50ZXJwKSB7XG4gICAgLy8gQ3JlYXRlIG91ciBgVG9rZW5SZXBsYWNlcmAgd2l0aCB0aGUgcmVmZXJlbmNlIHRvIGBkYXRhYFxuICAgIHRva2VuUmVwbGFjZXIgPSBuZXcgVG9rZW5SZXBsYWNlcihkYXRhKTtcblxuICAgIC8vIFRoaXMgZG9lcyB0d28gdGhpbmdzLCBvbmUgaXQgd2lsbCByZXR1cm4gYSBzdHJpbmcgd2hpY2ggd2lsbCBub3JtYWxpemUgb3VyIGZvcm1hdFxuICAgIC8vIGZvciBmdXJ0aGVyIHByb2Nlc3NpbmcuIFRoZSBzZWNvbmQgdGhpbmcgYmVpbmcgaXQgd2lsbCBub3cgZ28gdGhyb3VnaCBhbmQgcmVwbGFjZVxuICAgIC8vIHRoZSBkYXRhIHJlZmVyZW5jZSB0b2tlbnMgd2l0aCB0aGUgZGF0YSB2YWx1ZXMuXG4gICAgaW5uZXJIVE1MID0gdG9rZW5SZXBsYWNlci5yZXBsYWNlKGlubmVySFRNTC5pbnRlcnApO1xuICB9XG5cbiAgLy8gdGhpcyB3aWxsIHNldCB0aGUgaW5uZXJIVE1MIHRvIHRoZSB2YWx1ZSBwYXNzZWQgaW4gYnV0IG5vIHNjcmlwdHMgd2lsbCBleGVjdXRlXG4gIC8vIHNvIHRoZXJlZm9yZSB3ZSdyZSBnb2luZyB0byBuZWVkIHRvIHRyYXZlcnNlIHRoZSBlbGVtZW50cyBhbmQgZXhlY3V0ZSB0aGVtXG4gIHNlbGYuZG9jRnJhZ1swXS5pbm5lckhUTUwgPSBpbm5lckhUTUw7XG5cbiAgLy8gR2V0IGFsbCBvZiBvdXIgc2NyaXB0IG5vZGVzIHRvIGV4ZWN1dGUgaW4gb3JkZXJcbiAgc2NyaXB0Tm9kZXMgPSAkKFwic2NyaXB0XCIsIHNlbGYuZG9jRnJhZyk7XG5cbiAgc2NyaXB0Tm9kZUxlbmd0aCA9IHNjcmlwdE5vZGVzLmxlbmd0aDtcblxuICAvLyBwcmVjYWNoZSBzY3JpcHQgc3Jjcywga2ljayBvZmYgY29uY3VycmVudCBkb3dubG9hZHNcbiAgXy5lYWNoKHNjcmlwdE5vZGVzLCBmdW5jdGlvbihzY3JpcHROb2RlKSB7XG4gICAgaWYgKHNjcmlwdE5vZGUuc3JjICE9PSBcIlwiKSB7XG4gICAgICBpZiAoZmlyc3RTY3JpcHRTcmMpIHtcbiAgICAgICAgZmlyc3RTY3JpcHRTcmMgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBlbGVtZW50LnNyYyA9IHNjcmlwdE5vZGUuc3JjO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gY3JlYXRlIGEgcmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGNodW5rIHRocm91Z2ggZWFjaCBzY3JpcHQgZWxlbWVudCBhbmQgZWl0aGVyIGV2YWxcbiAgLy8gaXQgaWYgaXQncyBhbiBpbmxpbmUgc2NyaXB0LCBvciBnbyBhbmQgbG9hZCB0aGUgc291cmNlLlxuICBwcm9jZXNzTmV4dEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VyTm9kZSA9IHNjcmlwdE5vZGVzW2ldO1xuICAgIHZhciBuZXdOb2RlO1xuICAgIHZhciBwYXJlbnROb2RlID0gY3VyTm9kZS5wYXJlbnROb2RlO1xuICAgIHZhciBpdGVyYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpKys7XG4gICAgICBpZiAoaSA8IHNjcmlwdE5vZGVMZW5ndGgpIHtcbiAgICAgICAgcHJvY2Vzc05leHRFbGVtZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnJlc29sdmUocHJvcHMucGx1Z0luKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzd2FwRm9yTGl2ZVNjcmlwdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgY3VyTm9kZSk7XG4gICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGN1ck5vZGUpO1xuICAgIH07XG5cbiAgICBuZXdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcblxuICAgIC8vIHNjcmlwdCB3aXRoIHNyY1xuICAgIGlmIChjdXJOb2RlLnNyYyAhPT0gXCJcIikge1xuICAgICAgbmV3Tm9kZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChpdGVyYXRlLCAwKTtcbiAgICAgIH0pO1xuXHRcdFx0bmV3Tm9kZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgaXRlcmF0ZSk7XG4gICAgICBuZXdOb2RlLnNyYyA9IGN1ck5vZGUuc3JjO1xuICAgICAgc3dhcEZvckxpdmVTY3JpcHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5saW5lIHNjcmlwdFxuICAgICAgbmV3Tm9kZS5pbm5lckhUTUwgPSBjdXJOb2RlLmlubmVySFRNTDtcbiAgICAgIHN3YXBGb3JMaXZlU2NyaXB0KCk7XG4gICAgICBpdGVyYXRlKCk7XG4gICAgfVxuICB9O1xuICBpZiAoc2NyaXB0Tm9kZUxlbmd0aCA+IDApIHtcbiAgICBwcm9jZXNzTmV4dEVsZW1lbnQoKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnJlc29sdmUocHJvcHMucGx1Z0luKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2RvbS9EaXZFbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///42\n')},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, require */\n\n// HasDocWriteElement is a subclass of BuildElement. it creates an html document inline as an iframe\n// to safeguard against asycnronously loading scripts that have a "document.write()" call which is a\n// big no no when you have a document that is already closed because it will implicitly reopen the \n// document and clear the DOM, thus creating a blank page.\n//\n// Interesting most browsers now will just block any asyncronous scripts from loading that have a\n// Document.write()\nmodule.exports = function (props) {\n\n\t// create a var for `this`, mostly for minification but also for\n\t// conceptual clarity.\n\tvar self = this;\n\tvar _ = __webpack_require__(0);\n\tvar $ = __webpack_require__(1);\n\tvar ProcessArgs = __webpack_require__(11);\n\tvar BuildElement = __webpack_require__(3);\n\tvar newProps = {};\n\tvar processArgs = new ProcessArgs(props.data);\n\tvar plugIn = props.plugIn;\n\tvar preBuild = plugIn.preBuild;\n\tvar postBuild = plugIn.postBuild;\n\tvar contents = "<!DOCTYPE html><html><head><style>a img{border:0px;}</style>";\n\tvar iframeDoc;\n\n\t// assign libraries\n\tcontents += "<script>var t = window.parent.conversant.tagManager; var _ = t.lib._; var $ = t.lib.$;<\\/script>";\n\n\t// if we have a preBuild\n\tif (preBuild) {\n\n\t\t// should return a function reference\n\t\tcontents += "<script>var preBuildFunc = " + preBuild.func + "<\\/script>";\n\n\t\t// apply arguments\n\t\tcontents += "<script>preBuildFunc.apply(this, " + JSON.stringify(processArgs.process(preBuild.args)) + ");<\\/script>";\n\t}\n\n\t// put the script on synchronously\n\tcontents += "<script src=\\"" + props.src + "\\"><\\/script>";\n\n\t// if we have a postBuild\n\tif (postBuild) {\n\n\t\t// should return a function reference\n\t\tcontents += "<script>var postBuildFunc = " + postBuild.func + "<\\/script>";\n\n\t\t// apply arguments\n\t\tcontents += "<script>postBuildFunc.apply(this, " + JSON.stringify(processArgs.process(postBuild.args)) + ");<\\/script>";\n\t}\n\tcontents += "</head><body style=\\"margin:0px;overflow:hidden;\\"></body></html>";\n\n\t_.extend(self, BuildElement);\n\n\t// init ourselves to have functionality and create doc frag\n\t$.extend(true, newProps, props);\n\tnewProps.plugIn.attr.tag = "iframe";\n\tdelete newProps.src;\n\tself.init(newProps);\n\n\tif (!_.isUndefined(self.docFrag[0].contentWindow)) {\n\n\t\tiframeDoc = self.docFrag[0].contentWindow.document;\n\t\tiframeDoc.open();\n\t\tiframeDoc.write(contents);\n\t\tiframeDoc.close();\n\n\t}\n\n\tself.docFrag.css({\n\t\t"border-style": "none",\n\t\t"height": "100%",\n\t\t"width": "100%",\n\t\t"overflow": "hidden",\n\t\t"border": "0px"\n\t});\n\n\t// Resolve dat\n\tself.resolve(props.plugIn);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL0hhc0RvY1dyaXRlRWxlbWVudC5qcz9kY2I2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsQ0FBWTtBQUM3QixTQUFTLG1CQUFPLENBQUMsQ0FBTztBQUN4QixtQkFBbUIsbUJBQU8sQ0FBQyxFQUFxQjtBQUNoRCxvQkFBb0IsbUJBQU8sQ0FBQyxDQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFlBQVk7QUFDckU7O0FBRUE7QUFDQSxrRUFBa0UsaUJBQWlCLGlCQUFpQjs7QUFFcEc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEdBQTRHO0FBQzVHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEdBQThHO0FBQzlHO0FBQ0EsOENBQThDLGdCQUFnQjs7QUFFOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiI0My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIG5vbWVuOiB0cnVlLCByZWdleHA6IHRydWUsIHZhcnM6dHJ1ZSwgcGx1c3BsdXM6dHJ1ZSAqL1xuLypnbG9iYWwgbW9kdWxlLCByZXF1aXJlICovXG5cbi8vIEhhc0RvY1dyaXRlRWxlbWVudCBpcyBhIHN1YmNsYXNzIG9mIEJ1aWxkRWxlbWVudC4gaXQgY3JlYXRlcyBhbiBodG1sIGRvY3VtZW50IGlubGluZSBhcyBhbiBpZnJhbWVcbi8vIHRvIHNhZmVndWFyZCBhZ2FpbnN0IGFzeWNucm9ub3VzbHkgbG9hZGluZyBzY3JpcHRzIHRoYXQgaGF2ZSBhIFwiZG9jdW1lbnQud3JpdGUoKVwiIGNhbGwgd2hpY2ggaXMgYVxuLy8gYmlnIG5vIG5vIHdoZW4geW91IGhhdmUgYSBkb2N1bWVudCB0aGF0IGlzIGFscmVhZHkgY2xvc2VkIGJlY2F1c2UgaXQgd2lsbCBpbXBsaWNpdGx5IHJlb3BlbiB0aGUgXG4vLyBkb2N1bWVudCBhbmQgY2xlYXIgdGhlIERPTSwgdGh1cyBjcmVhdGluZyBhIGJsYW5rIHBhZ2UuXG4vL1xuLy8gSW50ZXJlc3RpbmcgbW9zdCBicm93c2VycyBub3cgd2lsbCBqdXN0IGJsb2NrIGFueSBhc3luY3Jvbm91cyBzY3JpcHRzIGZyb20gbG9hZGluZyB0aGF0IGhhdmUgYVxuLy8gRG9jdW1lbnQud3JpdGUoKVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcblxuXHQvLyBjcmVhdGUgYSB2YXIgZm9yIGB0aGlzYCwgbW9zdGx5IGZvciBtaW5pZmljYXRpb24gYnV0IGFsc28gZm9yXG5cdC8vIGNvbmNlcHR1YWwgY2xhcml0eS5cblx0dmFyIHNlbGYgPSB0aGlzO1xuXHR2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXHR2YXIgJCA9IHJlcXVpcmUoXCJ6ZXB0b1wiKTtcblx0dmFyIFByb2Nlc3NBcmdzID0gcmVxdWlyZShcIi4uL2RhdGEvUHJvY2Vzc0FyZ3NcIik7XG5cdHZhciBCdWlsZEVsZW1lbnQgPSByZXF1aXJlKFwiLi9CdWlsZEVsZW1lbnRcIik7XG5cdHZhciBuZXdQcm9wcyA9IHt9O1xuXHR2YXIgcHJvY2Vzc0FyZ3MgPSBuZXcgUHJvY2Vzc0FyZ3MocHJvcHMuZGF0YSk7XG5cdHZhciBwbHVnSW4gPSBwcm9wcy5wbHVnSW47XG5cdHZhciBwcmVCdWlsZCA9IHBsdWdJbi5wcmVCdWlsZDtcblx0dmFyIHBvc3RCdWlsZCA9IHBsdWdJbi5wb3N0QnVpbGQ7XG5cdHZhciBjb250ZW50cyA9IFwiPCFET0NUWVBFIGh0bWw+PGh0bWw+PGhlYWQ+PHN0eWxlPmEgaW1ne2JvcmRlcjowcHg7fTwvc3R5bGU+XCI7XG5cdHZhciBpZnJhbWVEb2M7XG5cblx0Ly8gYXNzaWduIGxpYnJhcmllc1xuXHRjb250ZW50cyArPSBcIjxzY3JpcHQ+dmFyIHQgPSB3aW5kb3cucGFyZW50LmNvbnZlcnNhbnQudGFnTWFuYWdlcjsgdmFyIF8gPSB0LmxpYi5fOyB2YXIgJCA9IHQubGliLiQ7PFxcL3NjcmlwdD5cIjtcblxuXHQvLyBpZiB3ZSBoYXZlIGEgcHJlQnVpbGRcblx0aWYgKHByZUJ1aWxkKSB7XG5cblx0XHQvLyBzaG91bGQgcmV0dXJuIGEgZnVuY3Rpb24gcmVmZXJlbmNlXG5cdFx0Y29udGVudHMgKz0gXCI8c2NyaXB0PnZhciBwcmVCdWlsZEZ1bmMgPSBcIiArIHByZUJ1aWxkLmZ1bmMgKyBcIjxcXC9zY3JpcHQ+XCI7XG5cblx0XHQvLyBhcHBseSBhcmd1bWVudHNcblx0XHRjb250ZW50cyArPSBcIjxzY3JpcHQ+cHJlQnVpbGRGdW5jLmFwcGx5KHRoaXMsIFwiICsgSlNPTi5zdHJpbmdpZnkocHJvY2Vzc0FyZ3MucHJvY2VzcyhwcmVCdWlsZC5hcmdzKSkgKyBcIik7PFxcL3NjcmlwdD5cIjtcblx0fVxuXG5cdC8vIHB1dCB0aGUgc2NyaXB0IG9uIHN5bmNocm9ub3VzbHlcblx0Y29udGVudHMgKz0gXCI8c2NyaXB0IHNyYz1cXFwiXCIgKyBwcm9wcy5zcmMgKyBcIlxcXCI+PFxcL3NjcmlwdD5cIjtcblxuXHQvLyBpZiB3ZSBoYXZlIGEgcG9zdEJ1aWxkXG5cdGlmIChwb3N0QnVpbGQpIHtcblxuXHRcdC8vIHNob3VsZCByZXR1cm4gYSBmdW5jdGlvbiByZWZlcmVuY2Vcblx0XHRjb250ZW50cyArPSBcIjxzY3JpcHQ+dmFyIHBvc3RCdWlsZEZ1bmMgPSBcIiArIHBvc3RCdWlsZC5mdW5jICsgXCI8XFwvc2NyaXB0PlwiO1xuXG5cdFx0Ly8gYXBwbHkgYXJndW1lbnRzXG5cdFx0Y29udGVudHMgKz0gXCI8c2NyaXB0PnBvc3RCdWlsZEZ1bmMuYXBwbHkodGhpcywgXCIgKyBKU09OLnN0cmluZ2lmeShwcm9jZXNzQXJncy5wcm9jZXNzKHBvc3RCdWlsZC5hcmdzKSkgKyBcIik7PFxcL3NjcmlwdD5cIjtcblx0fVxuXHRjb250ZW50cyArPSBcIjwvaGVhZD48Ym9keSBzdHlsZT1cXFwibWFyZ2luOjBweDtvdmVyZmxvdzpoaWRkZW47XFxcIj48L2JvZHk+PC9odG1sPlwiO1xuXG5cdF8uZXh0ZW5kKHNlbGYsIEJ1aWxkRWxlbWVudCk7XG5cblx0Ly8gaW5pdCBvdXJzZWx2ZXMgdG8gaGF2ZSBmdW5jdGlvbmFsaXR5IGFuZCBjcmVhdGUgZG9jIGZyYWdcblx0JC5leHRlbmQodHJ1ZSwgbmV3UHJvcHMsIHByb3BzKTtcblx0bmV3UHJvcHMucGx1Z0luLmF0dHIudGFnID0gXCJpZnJhbWVcIjtcblx0ZGVsZXRlIG5ld1Byb3BzLnNyYztcblx0c2VsZi5pbml0KG5ld1Byb3BzKTtcblxuXHRpZiAoIV8uaXNVbmRlZmluZWQoc2VsZi5kb2NGcmFnWzBdLmNvbnRlbnRXaW5kb3cpKSB7XG5cblx0XHRpZnJhbWVEb2MgPSBzZWxmLmRvY0ZyYWdbMF0uY29udGVudFdpbmRvdy5kb2N1bWVudDtcblx0XHRpZnJhbWVEb2Mub3BlbigpO1xuXHRcdGlmcmFtZURvYy53cml0ZShjb250ZW50cyk7XG5cdFx0aWZyYW1lRG9jLmNsb3NlKCk7XG5cblx0fVxuXG5cdHNlbGYuZG9jRnJhZy5jc3Moe1xuXHRcdFwiYm9yZGVyLXN0eWxlXCI6IFwibm9uZVwiLFxuXHRcdFwiaGVpZ2h0XCI6IFwiMTAwJVwiLFxuXHRcdFwid2lkdGhcIjogXCIxMDAlXCIsXG5cdFx0XCJvdmVyZmxvd1wiOiBcImhpZGRlblwiLFxuXHRcdFwiYm9yZGVyXCI6IFwiMHB4XCJcblx0fSk7XG5cblx0Ly8gUmVzb2x2ZSBkYXRcblx0c2VsZi5yZXNvbHZlKHByb3BzLnBsdWdJbik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZG9tL0hhc0RvY1dyaXRlRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43\n')},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, require */\n\n// IframeElement is a subclass of BuildElement.  It creates a DOM element with a src that is\n// an img.\nmodule.exports = function (props) {\n\n\t// create a var for this, mostly for minification but also for\n\t// conceptual clarity.\n\tvar self = this;\n\tvar _ = __webpack_require__(0);\n\tvar BuildElement = __webpack_require__(3);\n\tvar TokenReplacer = __webpack_require__(4);\n\n\t// Declare our hoisted vars which will define later\n\tvar tokenReplacer;\n\tvar plugIn = props.plugIn;\n\tvar innerHTML = plugIn.attr.innerHTML;\n\tvar data = props.data;\n\tvar iframeDoc;\n\n\tif (!plugIn.attr.tag) {\n\t\tplugIn.attr.tag = "iframe";\n\t}\n\n\t_.extend(self, BuildElement);\n\n\tself.init(props);\n\n\t// if we have no uri and we have an innerHTML, then we\'re going to need to create an\n\t// iframe with a body and paste the contents of that innerHTML into it.\n\t// This is a custom tag\n\tif (!_.isUndefined(innerHTML) && _.isUndefined(props.src)) {\n\n\t\t// an `innerHTML` property, by the specification, can be an object or just a string.\n\t\t// in the event that it is an object that means it may have data in it that need to be\n\t\t// injected into the page from our `dataDef` and subsequently `data`, which is our\n\t\t// data that was resolved client side.\n\t\tif (_.isObject(innerHTML) && !_.isUndefined(innerHTML.interp)) {\n\n\t\t\t// Create our `TokenReplacer` with the reference to `data`\n\t\t\ttokenReplacer = new TokenReplacer(data);\n\n\t\t\t// This does two things, one it will return a string which will normalize our format\n\t\t\t// for further processing. The second thing being it will now go through and replace\n\t\t\t// the data reference tokens with the data values.\n\t\t\tinnerHTML = tokenReplacer.replace(innerHTML.interp);\n\n\t\t}\n\n\t\t// This is our HTML to inject into the iframe, we\'ll need to reference the libraries in the event that we have\n\t\t// a pre and/or a post build function that needs to execute in this space.\n\t\tif (!_.isUndefined(self.docFrag) && self.docFrag[0].contentWindow) {\n\n\t\t\tiframeDoc = self.docFrag[0].contentWindow.document;\n\t\t\tiframeDoc.open();\n\t\t\tiframeDoc.write("<!DOCTYPE html><html><head><meta charset=\\"utf-8\\"><style>a img{border:0px;}</style><script>var lib = window.parent.conversant.tagManager.lib, _ = lib._,$ = lib.$;<\\/script></head><body style=\\"margin:0px;overflow:hidden;\\">" + innerHTML + "</body></html>");\n\t\t\tiframeDoc.close();\n\n\t\t}\n\t}\n\n\tself.docFrag.css({\n\t\t"border-style": "none",\n\t\t"height": "100%",\n\t\t"width": "100%",\n\t\t"overflow": "hidden",\n\t\t"border": "0px"\n\t});\n\n\n\n\t// We\'re done\n\tself.resolve(plugIn);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL0lmcmFtZUVsZW1lbnQuanM/ZDg0NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsQ0FBWTtBQUM3QixvQkFBb0IsbUJBQU8sQ0FBQyxDQUFnQjtBQUM1QyxxQkFBcUIsbUJBQU8sQ0FBQyxDQUF1Qjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvRkFBb0YsWUFBWSx1RkFBdUYsMENBQTBDLGdCQUFnQjtBQUNqUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0EiLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBzbG9wcHk6IHRydWUsIHdoaXRlOiB0cnVlLCBub21lbjogdHJ1ZSwgcmVnZXhwOiB0cnVlLCB2YXJzOnRydWUsIHBsdXNwbHVzOnRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG4vLyBJZnJhbWVFbGVtZW50IGlzIGEgc3ViY2xhc3Mgb2YgQnVpbGRFbGVtZW50LiAgSXQgY3JlYXRlcyBhIERPTSBlbGVtZW50IHdpdGggYSBzcmMgdGhhdCBpc1xuLy8gYW4gaW1nLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcblxuXHQvLyBjcmVhdGUgYSB2YXIgZm9yIHRoaXMsIG1vc3RseSBmb3IgbWluaWZpY2F0aW9uIGJ1dCBhbHNvIGZvclxuXHQvLyBjb25jZXB0dWFsIGNsYXJpdHkuXG5cdHZhciBzZWxmID0gdGhpcztcblx0dmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcblx0dmFyIEJ1aWxkRWxlbWVudCA9IHJlcXVpcmUoXCIuL0J1aWxkRWxlbWVudFwiKTtcblx0dmFyIFRva2VuUmVwbGFjZXIgPSByZXF1aXJlKFwiLi4vZGF0YS9Ub2tlblJlcGxhY2VyXCIpO1xuXG5cdC8vIERlY2xhcmUgb3VyIGhvaXN0ZWQgdmFycyB3aGljaCB3aWxsIGRlZmluZSBsYXRlclxuXHR2YXIgdG9rZW5SZXBsYWNlcjtcblx0dmFyIHBsdWdJbiA9IHByb3BzLnBsdWdJbjtcblx0dmFyIGlubmVySFRNTCA9IHBsdWdJbi5hdHRyLmlubmVySFRNTDtcblx0dmFyIGRhdGEgPSBwcm9wcy5kYXRhO1xuXHR2YXIgaWZyYW1lRG9jO1xuXG5cdGlmICghcGx1Z0luLmF0dHIudGFnKSB7XG5cdFx0cGx1Z0luLmF0dHIudGFnID0gXCJpZnJhbWVcIjtcblx0fVxuXG5cdF8uZXh0ZW5kKHNlbGYsIEJ1aWxkRWxlbWVudCk7XG5cblx0c2VsZi5pbml0KHByb3BzKTtcblxuXHQvLyBpZiB3ZSBoYXZlIG5vIHVyaSBhbmQgd2UgaGF2ZSBhbiBpbm5lckhUTUwsIHRoZW4gd2UncmUgZ29pbmcgdG8gbmVlZCB0byBjcmVhdGUgYW5cblx0Ly8gaWZyYW1lIHdpdGggYSBib2R5IGFuZCBwYXN0ZSB0aGUgY29udGVudHMgb2YgdGhhdCBpbm5lckhUTUwgaW50byBpdC5cblx0Ly8gVGhpcyBpcyBhIGN1c3RvbSB0YWdcblx0aWYgKCFfLmlzVW5kZWZpbmVkKGlubmVySFRNTCkgJiYgXy5pc1VuZGVmaW5lZChwcm9wcy5zcmMpKSB7XG5cblx0XHQvLyBhbiBgaW5uZXJIVE1MYCBwcm9wZXJ0eSwgYnkgdGhlIHNwZWNpZmljYXRpb24sIGNhbiBiZSBhbiBvYmplY3Qgb3IganVzdCBhIHN0cmluZy5cblx0XHQvLyBpbiB0aGUgZXZlbnQgdGhhdCBpdCBpcyBhbiBvYmplY3QgdGhhdCBtZWFucyBpdCBtYXkgaGF2ZSBkYXRhIGluIGl0IHRoYXQgbmVlZCB0byBiZVxuXHRcdC8vIGluamVjdGVkIGludG8gdGhlIHBhZ2UgZnJvbSBvdXIgYGRhdGFEZWZgIGFuZCBzdWJzZXF1ZW50bHkgYGRhdGFgLCB3aGljaCBpcyBvdXJcblx0XHQvLyBkYXRhIHRoYXQgd2FzIHJlc29sdmVkIGNsaWVudCBzaWRlLlxuXHRcdGlmIChfLmlzT2JqZWN0KGlubmVySFRNTCkgJiYgIV8uaXNVbmRlZmluZWQoaW5uZXJIVE1MLmludGVycCkpIHtcblxuXHRcdFx0Ly8gQ3JlYXRlIG91ciBgVG9rZW5SZXBsYWNlcmAgd2l0aCB0aGUgcmVmZXJlbmNlIHRvIGBkYXRhYFxuXHRcdFx0dG9rZW5SZXBsYWNlciA9IG5ldyBUb2tlblJlcGxhY2VyKGRhdGEpO1xuXG5cdFx0XHQvLyBUaGlzIGRvZXMgdHdvIHRoaW5ncywgb25lIGl0IHdpbGwgcmV0dXJuIGEgc3RyaW5nIHdoaWNoIHdpbGwgbm9ybWFsaXplIG91ciBmb3JtYXRcblx0XHRcdC8vIGZvciBmdXJ0aGVyIHByb2Nlc3NpbmcuIFRoZSBzZWNvbmQgdGhpbmcgYmVpbmcgaXQgd2lsbCBub3cgZ28gdGhyb3VnaCBhbmQgcmVwbGFjZVxuXHRcdFx0Ly8gdGhlIGRhdGEgcmVmZXJlbmNlIHRva2VucyB3aXRoIHRoZSBkYXRhIHZhbHVlcy5cblx0XHRcdGlubmVySFRNTCA9IHRva2VuUmVwbGFjZXIucmVwbGFjZShpbm5lckhUTUwuaW50ZXJwKTtcblxuXHRcdH1cblxuXHRcdC8vIFRoaXMgaXMgb3VyIEhUTUwgdG8gaW5qZWN0IGludG8gdGhlIGlmcmFtZSwgd2UnbGwgbmVlZCB0byByZWZlcmVuY2UgdGhlIGxpYnJhcmllcyBpbiB0aGUgZXZlbnQgdGhhdCB3ZSBoYXZlXG5cdFx0Ly8gYSBwcmUgYW5kL29yIGEgcG9zdCBidWlsZCBmdW5jdGlvbiB0aGF0IG5lZWRzIHRvIGV4ZWN1dGUgaW4gdGhpcyBzcGFjZS5cblx0XHRpZiAoIV8uaXNVbmRlZmluZWQoc2VsZi5kb2NGcmFnKSAmJiBzZWxmLmRvY0ZyYWdbMF0uY29udGVudFdpbmRvdykge1xuXG5cdFx0XHRpZnJhbWVEb2MgPSBzZWxmLmRvY0ZyYWdbMF0uY29udGVudFdpbmRvdy5kb2N1bWVudDtcblx0XHRcdGlmcmFtZURvYy5vcGVuKCk7XG5cdFx0XHRpZnJhbWVEb2Mud3JpdGUoXCI8IURPQ1RZUEUgaHRtbD48aHRtbD48aGVhZD48bWV0YSBjaGFyc2V0PVxcXCJ1dGYtOFxcXCI+PHN0eWxlPmEgaW1ne2JvcmRlcjowcHg7fTwvc3R5bGU+PHNjcmlwdD52YXIgbGliID0gd2luZG93LnBhcmVudC5jb252ZXJzYW50LnRhZ01hbmFnZXIubGliLCBfID0gbGliLl8sJCA9IGxpYi4kOzxcXC9zY3JpcHQ+PC9oZWFkPjxib2R5IHN0eWxlPVxcXCJtYXJnaW46MHB4O292ZXJmbG93OmhpZGRlbjtcXFwiPlwiICsgaW5uZXJIVE1MICsgXCI8L2JvZHk+PC9odG1sPlwiKTtcblx0XHRcdGlmcmFtZURvYy5jbG9zZSgpO1xuXG5cdFx0fVxuXHR9XG5cblx0c2VsZi5kb2NGcmFnLmNzcyh7XG5cdFx0XCJib3JkZXItc3R5bGVcIjogXCJub25lXCIsXG5cdFx0XCJoZWlnaHRcIjogXCIxMDAlXCIsXG5cdFx0XCJ3aWR0aFwiOiBcIjEwMCVcIixcblx0XHRcIm92ZXJmbG93XCI6IFwiaGlkZGVuXCIsXG5cdFx0XCJib3JkZXJcIjogXCIwcHhcIlxuXHR9KTtcblxuXG5cblx0Ly8gV2UncmUgZG9uZVxuXHRzZWxmLnJlc29sdmUocGx1Z0luKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9kb20vSWZyYW1lRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44\n')},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global require, module */\n\n// IsolatedElement is a subclass of BuildElement.  It creates a DOM element with a src that is\n// an iframe of our own hosted xdrTag.html.\nmodule.exports = function(props, locale) {\n\n  var self = this;\n  var _ = __webpack_require__(0);\n  var BuildElement = __webpack_require__(3);\n  var plugIn = props.plugIn;\n  var plugInHash;\n\n\tif(!plugIn.attr.tag) {\n\t\tplugIn.attr.tag = "iframe";\n\t}\n\n  _.extend(self, BuildElement);\n\n  // Get only the things we need from the plugIn and make an object\n  plugInHash = _.pick(plugIn, ["type", "tagId", "tagName", "meta", "data", "attr", "preBuild", "postBuild", "hasDocWrite"]);\n\n  plugInHash.location = "body";\n\n  // Make it a stringified object\n  plugInHash = JSON.stringify(plugInHash);\n\n  // enocde that string from consumption from the third party iframe\n  plugInHash = encodeURIComponent(plugInHash);\n\n  plugIn.attr.tag = "iframe";\n\n  // init ourselves with the source\n  self.init({\n    plugIn: plugIn,\n    appendToDIV: props.appendToDIV,\n    src: locale.cdn + "client/xdrTag.html#" + plugInHash\n  });\n\n  self.docFrag.css({\n    "border-style": "none",\n    "height": "100%",\n    "width": "100%",\n    "overflow": "hidden",\n    "border": "0px"\n  });\n\n  self.resolve(plugIn);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL0lzb2xhdGVkRWxlbWVudC5qcz8yNTRmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLENBQVk7QUFDOUIscUJBQXFCLG1CQUFPLENBQUMsQ0FBZ0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwiZmlsZSI6IjQ1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgbm9tZW46IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdmFyczp0cnVlLCBwbHVzcGx1czp0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuLy8gSXNvbGF0ZWRFbGVtZW50IGlzIGEgc3ViY2xhc3Mgb2YgQnVpbGRFbGVtZW50LiAgSXQgY3JlYXRlcyBhIERPTSBlbGVtZW50IHdpdGggYSBzcmMgdGhhdCBpc1xuLy8gYW4gaWZyYW1lIG9mIG91ciBvd24gaG9zdGVkIHhkclRhZy5odG1sLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcm9wcywgbG9jYWxlKSB7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuICB2YXIgQnVpbGRFbGVtZW50ID0gcmVxdWlyZShcIi4vQnVpbGRFbGVtZW50XCIpO1xuICB2YXIgcGx1Z0luID0gcHJvcHMucGx1Z0luO1xuICB2YXIgcGx1Z0luSGFzaDtcblxuXHRpZighcGx1Z0luLmF0dHIudGFnKSB7XG5cdFx0cGx1Z0luLmF0dHIudGFnID0gXCJpZnJhbWVcIjtcblx0fVxuXG4gIF8uZXh0ZW5kKHNlbGYsIEJ1aWxkRWxlbWVudCk7XG5cbiAgLy8gR2V0IG9ubHkgdGhlIHRoaW5ncyB3ZSBuZWVkIGZyb20gdGhlIHBsdWdJbiBhbmQgbWFrZSBhbiBvYmplY3RcbiAgcGx1Z0luSGFzaCA9IF8ucGljayhwbHVnSW4sIFtcInR5cGVcIiwgXCJ0YWdJZFwiLCBcInRhZ05hbWVcIiwgXCJtZXRhXCIsIFwiZGF0YVwiLCBcImF0dHJcIiwgXCJwcmVCdWlsZFwiLCBcInBvc3RCdWlsZFwiLCBcImhhc0RvY1dyaXRlXCJdKTtcblxuICBwbHVnSW5IYXNoLmxvY2F0aW9uID0gXCJib2R5XCI7XG5cbiAgLy8gTWFrZSBpdCBhIHN0cmluZ2lmaWVkIG9iamVjdFxuICBwbHVnSW5IYXNoID0gSlNPTi5zdHJpbmdpZnkocGx1Z0luSGFzaCk7XG5cbiAgLy8gZW5vY2RlIHRoYXQgc3RyaW5nIGZyb20gY29uc3VtcHRpb24gZnJvbSB0aGUgdGhpcmQgcGFydHkgaWZyYW1lXG4gIHBsdWdJbkhhc2ggPSBlbmNvZGVVUklDb21wb25lbnQocGx1Z0luSGFzaCk7XG5cbiAgcGx1Z0luLmF0dHIudGFnID0gXCJpZnJhbWVcIjtcblxuICAvLyBpbml0IG91cnNlbHZlcyB3aXRoIHRoZSBzb3VyY2VcbiAgc2VsZi5pbml0KHtcbiAgICBwbHVnSW46IHBsdWdJbixcbiAgICBhcHBlbmRUb0RJVjogcHJvcHMuYXBwZW5kVG9ESVYsXG4gICAgc3JjOiBsb2NhbGUuY2RuICsgXCJjbGllbnQveGRyVGFnLmh0bWwjXCIgKyBwbHVnSW5IYXNoXG4gIH0pO1xuXG4gIHNlbGYuZG9jRnJhZy5jc3Moe1xuICAgIFwiYm9yZGVyLXN0eWxlXCI6IFwibm9uZVwiLFxuICAgIFwiaGVpZ2h0XCI6IFwiMTAwJVwiLFxuICAgIFwid2lkdGhcIjogXCIxMDAlXCIsXG4gICAgXCJvdmVyZmxvd1wiOiBcImhpZGRlblwiLFxuICAgIFwiYm9yZGVyXCI6IFwiMHB4XCJcbiAgfSk7XG5cbiAgc2VsZi5yZXNvbHZlKHBsdWdJbik7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZG9tL0lzb2xhdGVkRWxlbWVudC5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///45\n')},function(module,exports,__webpack_require__){eval("/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global require, module */\n\n// ScriptElement is a subclass of BuildElement.  It creates a DOM element with a src that is\n// a script.\nmodule.exports = function (props) {\n\tvar self = this;\n\tvar _ = __webpack_require__(0);\n\tvar BuildElement = __webpack_require__(3);\n\tvar runPostBuild = __webpack_require__(12);\n\tvar plugIn;\n\tvar postBuild; \n\n\tif (_.isObject(props) && props.plugIn && props.appendToDIV) {\n\n\t\tplugIn = props.plugIn;\n\t\tpostBuild = plugIn.postBuild;\n\n\t\t// these should always be here, but if they're not we don't want the BuildElement\n\t\t// to fail so we'll explicitly set them since we were called specifically as a \n\t\t// ScriptElement.\n\t\tif (!plugIn.attr) {\n\t\t\tplugIn.attr = {};\n\t\t}\n\t\tif (!plugIn.attr.tag) {\n\t\t\tplugIn.attr.tag = \"script\";\n\t\t}\n\n\t\t_.extend(self, BuildElement);\n\n\t\t// If we have a postBuild we need to wait for the script to actually load before\n\t\t// we can run the postBuild because the postBuild may have calls to variables and\n\t\t// properties that won't exist until the script hits the page.\n\t\tif (postBuild) {\n\n\t\t\tprops.onload = function () {\n\n\t\t\t\trunPostBuild(postBuild, props.data);\n\t\t\t\tself.resolve(plugIn);\n\t\t\t};\n\t\t\tself.init(props);\n\n\t\t} else {\n\n\t\t\tself.init(props);\n\t\t\tself.resolve(plugIn);\n\t\t}\n\t} else {\n\t\tthrow new Error(\"ScriptElement created without necessary props\");\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvZG9tL1NjcmlwdEVsZW1lbnQuanM/ZDc4YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLENBQVk7QUFDN0Isb0JBQW9CLG1CQUFPLENBQUMsQ0FBZ0I7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMsRUFBdUI7QUFDbkQ7QUFDQSxlOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSIsImZpbGUiOiI0Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIG5vbWVuOiB0cnVlLCByZWdleHA6IHRydWUsIHZhcnM6dHJ1ZSwgcGx1c3BsdXM6dHJ1ZSAqL1xuLypnbG9iYWwgcmVxdWlyZSwgbW9kdWxlICovXG5cbi8vIFNjcmlwdEVsZW1lbnQgaXMgYSBzdWJjbGFzcyBvZiBCdWlsZEVsZW1lbnQuICBJdCBjcmVhdGVzIGEgRE9NIGVsZW1lbnQgd2l0aCBhIHNyYyB0aGF0IGlzXG4vLyBhIHNjcmlwdC5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHByb3BzKSB7XG5cdHZhciBzZWxmID0gdGhpcztcblx0dmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcblx0dmFyIEJ1aWxkRWxlbWVudCA9IHJlcXVpcmUoXCIuL0J1aWxkRWxlbWVudFwiKTtcblx0dmFyIHJ1blBvc3RCdWlsZCA9IHJlcXVpcmUoXCIuLi91dGlscy9ydW5Qb3N0QnVpbGRcIik7XG5cdHZhciBwbHVnSW47XG5cdHZhciBwb3N0QnVpbGQ7IFxuXG5cdGlmIChfLmlzT2JqZWN0KHByb3BzKSAmJiBwcm9wcy5wbHVnSW4gJiYgcHJvcHMuYXBwZW5kVG9ESVYpIHtcblxuXHRcdHBsdWdJbiA9IHByb3BzLnBsdWdJbjtcblx0XHRwb3N0QnVpbGQgPSBwbHVnSW4ucG9zdEJ1aWxkO1xuXG5cdFx0Ly8gdGhlc2Ugc2hvdWxkIGFsd2F5cyBiZSBoZXJlLCBidXQgaWYgdGhleSdyZSBub3Qgd2UgZG9uJ3Qgd2FudCB0aGUgQnVpbGRFbGVtZW50XG5cdFx0Ly8gdG8gZmFpbCBzbyB3ZSdsbCBleHBsaWNpdGx5IHNldCB0aGVtIHNpbmNlIHdlIHdlcmUgY2FsbGVkIHNwZWNpZmljYWxseSBhcyBhIFxuXHRcdC8vIFNjcmlwdEVsZW1lbnQuXG5cdFx0aWYgKCFwbHVnSW4uYXR0cikge1xuXHRcdFx0cGx1Z0luLmF0dHIgPSB7fTtcblx0XHR9XG5cdFx0aWYgKCFwbHVnSW4uYXR0ci50YWcpIHtcblx0XHRcdHBsdWdJbi5hdHRyLnRhZyA9IFwic2NyaXB0XCI7XG5cdFx0fVxuXG5cdFx0Xy5leHRlbmQoc2VsZiwgQnVpbGRFbGVtZW50KTtcblxuXHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0QnVpbGQgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgc2NyaXB0IHRvIGFjdHVhbGx5IGxvYWQgYmVmb3JlXG5cdFx0Ly8gd2UgY2FuIHJ1biB0aGUgcG9zdEJ1aWxkIGJlY2F1c2UgdGhlIHBvc3RCdWlsZCBtYXkgaGF2ZSBjYWxscyB0byB2YXJpYWJsZXMgYW5kXG5cdFx0Ly8gcHJvcGVydGllcyB0aGF0IHdvbid0IGV4aXN0IHVudGlsIHRoZSBzY3JpcHQgaGl0cyB0aGUgcGFnZS5cblx0XHRpZiAocG9zdEJ1aWxkKSB7XG5cblx0XHRcdHByb3BzLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRydW5Qb3N0QnVpbGQocG9zdEJ1aWxkLCBwcm9wcy5kYXRhKTtcblx0XHRcdFx0c2VsZi5yZXNvbHZlKHBsdWdJbik7XG5cdFx0XHR9O1xuXHRcdFx0c2VsZi5pbml0KHByb3BzKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHNlbGYuaW5pdChwcm9wcyk7XG5cdFx0XHRzZWxmLnJlc29sdmUocGx1Z0luKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiU2NyaXB0RWxlbWVudCBjcmVhdGVkIHdpdGhvdXQgbmVjZXNzYXJ5IHByb3BzXCIpO1xuXHR9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvZG9tL1NjcmlwdEVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///46\n")},function(module,exports,__webpack_require__){eval('/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global require, module */\n\n// I expect the objectOfFunctionsOROneFunctionForALL to have a callback type for each type of state change:\n// - popstate\n// - pushstate\n// - replacestate\n// OR it should just be a funciton for all\nmodule.exports = function (objectOfFunctionsOROneFunctionForALL) {\n\n\tvar w = window;\n\tvar callbacks = objectOfFunctionsOROneFunctionForALL;\n\tvar _ = __webpack_require__(0);\n\tvar temp;\n\tvar popStateEvent = function () {\n\t\t\tcallbacks.popstate();\n\t\t\tremoveAllListeners(); \n\t\t};\n\tvar oldPushState = w.history.pushState;\n\tvar oldReplaceState = w.history.replaceState;\n\tvar removeAllListeners = function() {\n\t\t\tw.removeEventListener("popstate", popStateEvent);\n\t\t\tw.history.pushState = oldPushState;\n\t\t\tw.history.replaceState = oldReplaceState;\n\t}\n\n\n\n\t// if it\'s a just a single function we\'ll break it out into an object\n\t// with a key for each kind of state change but they\'ll all reference\n\t// the same function.  If it\'s already an object we\'ll just use it \n\t// directly as is.\n\tif (_.isFunction(callbacks)) {\n\n\t\ttemp = {};\n\t\t_.each(["popstate", "pushstate", "replacestate"], function (key) {\n\t\t\ttemp[key] = callbacks;\n\t\t});\n\t\tcallbacks = temp;\n\t\ttemp = null;\n\t}\n\n\t// The state events are weird and inconsistent.  For a pop state (history.back)\n\t// I can assign a listener for the event and be done with it.  For pushState\n\t// and replace state I have to wrap the function to get a hook on it to call \n\t// a reset of our container\n\tif(_.isFunction(callbacks.popstate)) {\n\t\tw.addEventListener("popstate", popStateEvent);\n\t}\n\n\tif(_.isFunction(callbacks.pushstate)) {\n\t\tw.history.pushState = function () {\n\n\t\t\toldPushState.apply(this, arguments);\n\t\t\tcallbacks.pushstate();\n\t\t\tremoveAllListeners(); \n\t\t};\n\t}\n\n\tif(_.isFunction(callbacks.replacestate)) {\n\t\tw.history.replaceState = function () {\n\n\t\t\toldReplaceState.apply(this, arguments);\n\t\t\tcallbacks.replacestate();\n\t\t\tremoveAllListeners(); \n\t\t};\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbHMvU3RhdGVDaGFuZ2VXcmFwcGVycy5qcz8wN2EwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsQ0FBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQ3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSwgZXZpbDogdHJ1ZSwgc2xvcHB5OiB0cnVlLCB3aGl0ZTogdHJ1ZSwgbm9tZW46IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdmFyczp0cnVlLCBwbHVzcGx1czp0cnVlICovXG4vKmdsb2JhbCByZXF1aXJlLCBtb2R1bGUgKi9cblxuLy8gSSBleHBlY3QgdGhlIG9iamVjdE9mRnVuY3Rpb25zT1JPbmVGdW5jdGlvbkZvckFMTCB0byBoYXZlIGEgY2FsbGJhY2sgdHlwZSBmb3IgZWFjaCB0eXBlIG9mIHN0YXRlIGNoYW5nZTpcbi8vIC0gcG9wc3RhdGVcbi8vIC0gcHVzaHN0YXRlXG4vLyAtIHJlcGxhY2VzdGF0ZVxuLy8gT1IgaXQgc2hvdWxkIGp1c3QgYmUgYSBmdW5jaXRvbiBmb3IgYWxsXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3RPZkZ1bmN0aW9uc09ST25lRnVuY3Rpb25Gb3JBTEwpIHtcblxuXHR2YXIgdyA9IHdpbmRvdztcblx0dmFyIGNhbGxiYWNrcyA9IG9iamVjdE9mRnVuY3Rpb25zT1JPbmVGdW5jdGlvbkZvckFMTDtcblx0dmFyIF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcblx0dmFyIHRlbXA7XG5cdHZhciBwb3BTdGF0ZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0Y2FsbGJhY2tzLnBvcHN0YXRlKCk7XG5cdFx0XHRyZW1vdmVBbGxMaXN0ZW5lcnMoKTsgXG5cdFx0fTtcblx0dmFyIG9sZFB1c2hTdGF0ZSA9IHcuaGlzdG9yeS5wdXNoU3RhdGU7XG5cdHZhciBvbGRSZXBsYWNlU3RhdGUgPSB3Lmhpc3RvcnkucmVwbGFjZVN0YXRlO1xuXHR2YXIgcmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBwb3BTdGF0ZUV2ZW50KTtcblx0XHRcdHcuaGlzdG9yeS5wdXNoU3RhdGUgPSBvbGRQdXNoU3RhdGU7XG5cdFx0XHR3Lmhpc3RvcnkucmVwbGFjZVN0YXRlID0gb2xkUmVwbGFjZVN0YXRlO1xuXHR9XG5cblxuXG5cdC8vIGlmIGl0J3MgYSBqdXN0IGEgc2luZ2xlIGZ1bmN0aW9uIHdlJ2xsIGJyZWFrIGl0IG91dCBpbnRvIGFuIG9iamVjdFxuXHQvLyB3aXRoIGEga2V5IGZvciBlYWNoIGtpbmQgb2Ygc3RhdGUgY2hhbmdlIGJ1dCB0aGV5J2xsIGFsbCByZWZlcmVuY2Vcblx0Ly8gdGhlIHNhbWUgZnVuY3Rpb24uICBJZiBpdCdzIGFscmVhZHkgYW4gb2JqZWN0IHdlJ2xsIGp1c3QgdXNlIGl0IFxuXHQvLyBkaXJlY3RseSBhcyBpcy5cblx0aWYgKF8uaXNGdW5jdGlvbihjYWxsYmFja3MpKSB7XG5cblx0XHR0ZW1wID0ge307XG5cdFx0Xy5lYWNoKFtcInBvcHN0YXRlXCIsIFwicHVzaHN0YXRlXCIsIFwicmVwbGFjZXN0YXRlXCJdLCBmdW5jdGlvbiAoa2V5KSB7XG5cdFx0XHR0ZW1wW2tleV0gPSBjYWxsYmFja3M7XG5cdFx0fSk7XG5cdFx0Y2FsbGJhY2tzID0gdGVtcDtcblx0XHR0ZW1wID0gbnVsbDtcblx0fVxuXG5cdC8vIFRoZSBzdGF0ZSBldmVudHMgYXJlIHdlaXJkIGFuZCBpbmNvbnNpc3RlbnQuICBGb3IgYSBwb3Agc3RhdGUgKGhpc3RvcnkuYmFjaylcblx0Ly8gSSBjYW4gYXNzaWduIGEgbGlzdGVuZXIgZm9yIHRoZSBldmVudCBhbmQgYmUgZG9uZSB3aXRoIGl0LiAgRm9yIHB1c2hTdGF0ZVxuXHQvLyBhbmQgcmVwbGFjZSBzdGF0ZSBJIGhhdmUgdG8gd3JhcCB0aGUgZnVuY3Rpb24gdG8gZ2V0IGEgaG9vayBvbiBpdCB0byBjYWxsIFxuXHQvLyBhIHJlc2V0IG9mIG91ciBjb250YWluZXJcblx0aWYoXy5pc0Z1bmN0aW9uKGNhbGxiYWNrcy5wb3BzdGF0ZSkpIHtcblx0XHR3LmFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCBwb3BTdGF0ZUV2ZW50KTtcblx0fVxuXG5cdGlmKF8uaXNGdW5jdGlvbihjYWxsYmFja3MucHVzaHN0YXRlKSkge1xuXHRcdHcuaGlzdG9yeS5wdXNoU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdG9sZFB1c2hTdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0Y2FsbGJhY2tzLnB1c2hzdGF0ZSgpO1xuXHRcdFx0cmVtb3ZlQWxsTGlzdGVuZXJzKCk7IFxuXHRcdH07XG5cdH1cblxuXHRpZihfLmlzRnVuY3Rpb24oY2FsbGJhY2tzLnJlcGxhY2VzdGF0ZSkpIHtcblx0XHR3Lmhpc3RvcnkucmVwbGFjZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRvbGRSZXBsYWNlU3RhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdGNhbGxiYWNrcy5yZXBsYWNlc3RhdGUoKTtcblx0XHRcdHJlbW92ZUFsbExpc3RlbmVycygpOyBcblx0XHR9O1xuXHR9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvdXRpbHMvU3RhdGVDaGFuZ2VXcmFwcGVycy5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///47\n')},function(module,exports){eval('module.exports = function(windowLevelVar, callbackOnChange) {\n\n    var varStack = windowLevelVar.split(".");\n    var len = varStack.length;\n    var CHECK_MILLIS = 300;\n    var curTarget = window;\n    var recordedValue;\n    var toWatch;\n    var datInterval;\n\n    for (var i = 0; i < len; i++) {\n\n        if (i === 0) {\n            if (varStack[i] !== "window") {\n                toWatch = varStack[i];\n            }\n        } else if (i === len - 1) {\n            toWatch = varStack[i];\n        } else {\n            curTarget = curTarget[varStack[i]];\n        }\n    }\n    recordedValue = curTarget[toWatch];\n    datInterval = setInterval(function() {\n        if (curTarget[toWatch] !== recordedValue) {\n            clearInterval(datInterval);\n            callbackOnChange();\n        }\n    }, CHECK_MILLIS)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbHMvVmFyaWFibGVXYXRjaGVyLmpzPzNjMTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsImZpbGUiOiI0OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24od2luZG93TGV2ZWxWYXIsIGNhbGxiYWNrT25DaGFuZ2UpIHtcblxuICAgIHZhciB2YXJTdGFjayA9IHdpbmRvd0xldmVsVmFyLnNwbGl0KFwiLlwiKTtcbiAgICB2YXIgbGVuID0gdmFyU3RhY2subGVuZ3RoO1xuICAgIHZhciBDSEVDS19NSUxMSVMgPSAzMDA7XG4gICAgdmFyIGN1clRhcmdldCA9IHdpbmRvdztcbiAgICB2YXIgcmVjb3JkZWRWYWx1ZTtcbiAgICB2YXIgdG9XYXRjaDtcbiAgICB2YXIgZGF0SW50ZXJ2YWw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh2YXJTdGFja1tpXSAhPT0gXCJ3aW5kb3dcIikge1xuICAgICAgICAgICAgICAgIHRvV2F0Y2ggPSB2YXJTdGFja1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICB0b1dhdGNoID0gdmFyU3RhY2tbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJUYXJnZXQgPSBjdXJUYXJnZXRbdmFyU3RhY2tbaV1dO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlY29yZGVkVmFsdWUgPSBjdXJUYXJnZXRbdG9XYXRjaF07XG4gICAgZGF0SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGN1clRhcmdldFt0b1dhdGNoXSAhPT0gcmVjb3JkZWRWYWx1ZSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChkYXRJbnRlcnZhbCk7XG4gICAgICAgICAgICBjYWxsYmFja09uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9LCBDSEVDS19NSUxMSVMpXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi91dGlscy9WYXJpYWJsZVdhdGNoZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///48\n')},function(module,exports,__webpack_require__){eval("/*jslint browser: true, evil: true, sloppy: true, white: true, nomen: true, regexp: true, vars:true, plusplus:true */\n/*global module, require */\n\nmodule.exports = function (plugIn, overrideBroadcast) {\n\n\tvar _ = __webpack_require__(0);\n\tvar $ = __webpack_require__(1);\n\t__webpack_require__(5)();\n\n\t// our variable for storing the integer level of the onDone broadcast\n\tvar broadcastLevel;\n\tvar plugInBroadcastObj;\n\n\t// our return object which will be a \"notification\" specific to the broadcast level sent in.\n\t// each number for broadcastLevel represents a difference slice of the information\n\tvar retr = {};\n\n\t// converts into a basic notification with tagId, status and the pg (page group) and env (environment)\n\t// in a meta object\n\tvar makeBasicNotification = function () {\n\t\t\tretr = _.pick(plugIn, 'tagId', 'status');\n\t\t\tretr.meta = _.pick(plugIn.meta, 'pg', 'env');\n\t\t};\n\n\t// first make sure we have the necessary plugIn object\n\tif (_.isObject(plugIn)) {\n\n\t\t// figure out whether to use the broadcast object from the plugIn or use the override if it's set\n\t\tplugInBroadcastObj = _.isObject(overrideBroadcast) ? overrideBroadcast : plugIn.broadcast;\n\n\t\t// plugIn may have a broadcast level, if it's 0 or not there then it's 0\n\t\tif (_.isObject(plugInBroadcastObj)) {\n\n\t\t\t// Check for if it's a number, if it's anything else then it's 0\n\t\t\tbroadcastLevel = _.isNumber(plugInBroadcastObj.onDone) ? plugInBroadcastObj.onDone : 0;\n\t\t} else {\n\n\t\t\tbroadcastLevel = 0;\n\t\t}\n\n\n\t\t// Switch through the broadcast level and return the appropriate information. It's worth noting that\n\t\t// there is no case for 0.  If it's 0 or some unrecognized number, this function will return an\n\t\t// empty object to the caller.\n\t\tswitch (broadcastLevel) {\n\t\tcase 1:\n\n\t\t\t// Just your basic notification\n\t\t\tmakeBasicNotification();\n\t\t\tbreak;\n\n\t\tcase 2:\n\n\t\t\t// This is a get everything level (except redundant stuff, for space) and it's greedy\n\t\t\t$.extend(true, retr, plugIn);\n\n\t\t\t// remove the broadcast for space since\n\t\t\t// we won't need it\n\t\t\tdelete retr.broadcast;\n\n\t\t\t// if there is a sampleTag in there (debug=true) then\n\t\t\t// we definitely need to remove for space\n\t\t\tif (_.isSet(retr.meta)) {\n\t\t\t\tdelete retr.meta.sampleTag;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 3:\n\n\t\t\t// for the old monitoring and alerts, this will be depricated once the new (case 4) is implemented\n\t\t\t// Create basic notification\n\t\t\tmakeBasicNotification();\n\n\t\t\tif (!_.isUndefined(plugIn.attr.src)) {\n\n\t\t\t\t// Then add the plugIn.attr.src if it's built\n\t\t\t\tretr.attr = {\n\t\t\t\t\tsrc: plugIn.attr.src.final\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase 4:\n\n\t\t\t// This is for the Tag Sampling Spec: http://wiki.cnvrmedia.net/display/TM/Tag+Sampling+Notification+Specification\n\t\t\tretr = _.pick(plugIn, \"tagId\", \"location\", \"data\", \"preBuild\", \"postBuild\", \"attr\", \"innerHTML\", \"meta\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn retr;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbHMvZ2V0Tm90aWZpY2F0aW9uRnJvbVBsdWdJbi5qcz8zZmYzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUyxtQkFBTyxDQUFDLENBQVk7QUFDN0IsU0FBUyxtQkFBTyxDQUFDLENBQU87QUFDeEIsQ0FBQyxtQkFBTyxDQUFDLENBQW1DOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI0OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIGV2aWw6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIG5vbWVuOiB0cnVlLCByZWdleHA6IHRydWUsIHZhcnM6dHJ1ZSwgcGx1c3BsdXM6dHJ1ZSAqL1xuLypnbG9iYWwgbW9kdWxlLCByZXF1aXJlICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBsdWdJbiwgb3ZlcnJpZGVCcm9hZGNhc3QpIHtcblxuXHR2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXHR2YXIgJCA9IHJlcXVpcmUoXCJ6ZXB0b1wiKTtcblx0cmVxdWlyZShcIi4uLy4uL2xpYi91bmRlcnNjb3JlX21peGlucy9pc1NldFwiKSgpO1xuXG5cdC8vIG91ciB2YXJpYWJsZSBmb3Igc3RvcmluZyB0aGUgaW50ZWdlciBsZXZlbCBvZiB0aGUgb25Eb25lIGJyb2FkY2FzdFxuXHR2YXIgYnJvYWRjYXN0TGV2ZWw7XG5cdHZhciBwbHVnSW5Ccm9hZGNhc3RPYmo7XG5cblx0Ly8gb3VyIHJldHVybiBvYmplY3Qgd2hpY2ggd2lsbCBiZSBhIFwibm90aWZpY2F0aW9uXCIgc3BlY2lmaWMgdG8gdGhlIGJyb2FkY2FzdCBsZXZlbCBzZW50IGluLlxuXHQvLyBlYWNoIG51bWJlciBmb3IgYnJvYWRjYXN0TGV2ZWwgcmVwcmVzZW50cyBhIGRpZmZlcmVuY2Ugc2xpY2Ugb2YgdGhlIGluZm9ybWF0aW9uXG5cdHZhciByZXRyID0ge307XG5cblx0Ly8gY29udmVydHMgaW50byBhIGJhc2ljIG5vdGlmaWNhdGlvbiB3aXRoIHRhZ0lkLCBzdGF0dXMgYW5kIHRoZSBwZyAocGFnZSBncm91cCkgYW5kIGVudiAoZW52aXJvbm1lbnQpXG5cdC8vIGluIGEgbWV0YSBvYmplY3Rcblx0dmFyIG1ha2VCYXNpY05vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHIgPSBfLnBpY2socGx1Z0luLCAndGFnSWQnLCAnc3RhdHVzJyk7XG5cdFx0XHRyZXRyLm1ldGEgPSBfLnBpY2socGx1Z0luLm1ldGEsICdwZycsICdlbnYnKTtcblx0XHR9O1xuXG5cdC8vIGZpcnN0IG1ha2Ugc3VyZSB3ZSBoYXZlIHRoZSBuZWNlc3NhcnkgcGx1Z0luIG9iamVjdFxuXHRpZiAoXy5pc09iamVjdChwbHVnSW4pKSB7XG5cblx0XHQvLyBmaWd1cmUgb3V0IHdoZXRoZXIgdG8gdXNlIHRoZSBicm9hZGNhc3Qgb2JqZWN0IGZyb20gdGhlIHBsdWdJbiBvciB1c2UgdGhlIG92ZXJyaWRlIGlmIGl0J3Mgc2V0XG5cdFx0cGx1Z0luQnJvYWRjYXN0T2JqID0gXy5pc09iamVjdChvdmVycmlkZUJyb2FkY2FzdCkgPyBvdmVycmlkZUJyb2FkY2FzdCA6IHBsdWdJbi5icm9hZGNhc3Q7XG5cblx0XHQvLyBwbHVnSW4gbWF5IGhhdmUgYSBicm9hZGNhc3QgbGV2ZWwsIGlmIGl0J3MgMCBvciBub3QgdGhlcmUgdGhlbiBpdCdzIDBcblx0XHRpZiAoXy5pc09iamVjdChwbHVnSW5Ccm9hZGNhc3RPYmopKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpZiBpdCdzIGEgbnVtYmVyLCBpZiBpdCdzIGFueXRoaW5nIGVsc2UgdGhlbiBpdCdzIDBcblx0XHRcdGJyb2FkY2FzdExldmVsID0gXy5pc051bWJlcihwbHVnSW5Ccm9hZGNhc3RPYmoub25Eb25lKSA/IHBsdWdJbkJyb2FkY2FzdE9iai5vbkRvbmUgOiAwO1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGJyb2FkY2FzdExldmVsID0gMDtcblx0XHR9XG5cblxuXHRcdC8vIFN3aXRjaCB0aHJvdWdoIHRoZSBicm9hZGNhc3QgbGV2ZWwgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgaW5mb3JtYXRpb24uIEl0J3Mgd29ydGggbm90aW5nIHRoYXRcblx0XHQvLyB0aGVyZSBpcyBubyBjYXNlIGZvciAwLiAgSWYgaXQncyAwIG9yIHNvbWUgdW5yZWNvZ25pemVkIG51bWJlciwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBhblxuXHRcdC8vIGVtcHR5IG9iamVjdCB0byB0aGUgY2FsbGVyLlxuXHRcdHN3aXRjaCAoYnJvYWRjYXN0TGV2ZWwpIHtcblx0XHRjYXNlIDE6XG5cblx0XHRcdC8vIEp1c3QgeW91ciBiYXNpYyBub3RpZmljYXRpb25cblx0XHRcdG1ha2VCYXNpY05vdGlmaWNhdGlvbigpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIDI6XG5cblx0XHRcdC8vIFRoaXMgaXMgYSBnZXQgZXZlcnl0aGluZyBsZXZlbCAoZXhjZXB0IHJlZHVuZGFudCBzdHVmZiwgZm9yIHNwYWNlKSBhbmQgaXQncyBncmVlZHlcblx0XHRcdCQuZXh0ZW5kKHRydWUsIHJldHIsIHBsdWdJbik7XG5cblx0XHRcdC8vIHJlbW92ZSB0aGUgYnJvYWRjYXN0IGZvciBzcGFjZSBzaW5jZVxuXHRcdFx0Ly8gd2Ugd29uJ3QgbmVlZCBpdFxuXHRcdFx0ZGVsZXRlIHJldHIuYnJvYWRjYXN0O1xuXG5cdFx0XHQvLyBpZiB0aGVyZSBpcyBhIHNhbXBsZVRhZyBpbiB0aGVyZSAoZGVidWc9dHJ1ZSkgdGhlblxuXHRcdFx0Ly8gd2UgZGVmaW5pdGVseSBuZWVkIHRvIHJlbW92ZSBmb3Igc3BhY2Vcblx0XHRcdGlmIChfLmlzU2V0KHJldHIubWV0YSkpIHtcblx0XHRcdFx0ZGVsZXRlIHJldHIubWV0YS5zYW1wbGVUYWc7XG5cdFx0XHR9XG5cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSAzOlxuXG5cdFx0XHQvLyBmb3IgdGhlIG9sZCBtb25pdG9yaW5nIGFuZCBhbGVydHMsIHRoaXMgd2lsbCBiZSBkZXByaWNhdGVkIG9uY2UgdGhlIG5ldyAoY2FzZSA0KSBpcyBpbXBsZW1lbnRlZFxuXHRcdFx0Ly8gQ3JlYXRlIGJhc2ljIG5vdGlmaWNhdGlvblxuXHRcdFx0bWFrZUJhc2ljTm90aWZpY2F0aW9uKCk7XG5cblx0XHRcdGlmICghXy5pc1VuZGVmaW5lZChwbHVnSW4uYXR0ci5zcmMpKSB7XG5cblx0XHRcdFx0Ly8gVGhlbiBhZGQgdGhlIHBsdWdJbi5hdHRyLnNyYyBpZiBpdCdzIGJ1aWx0XG5cdFx0XHRcdHJldHIuYXR0ciA9IHtcblx0XHRcdFx0XHRzcmM6IHBsdWdJbi5hdHRyLnNyYy5maW5hbFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgNDpcblxuXHRcdFx0Ly8gVGhpcyBpcyBmb3IgdGhlIFRhZyBTYW1wbGluZyBTcGVjOiBodHRwOi8vd2lraS5jbnZybWVkaWEubmV0L2Rpc3BsYXkvVE0vVGFnK1NhbXBsaW5nK05vdGlmaWNhdGlvbitTcGVjaWZpY2F0aW9uXG5cdFx0XHRyZXRyID0gXy5waWNrKHBsdWdJbiwgXCJ0YWdJZFwiLCBcImxvY2F0aW9uXCIsIFwiZGF0YVwiLCBcInByZUJ1aWxkXCIsIFwicG9zdEJ1aWxkXCIsIFwiYXR0clwiLCBcImlubmVySFRNTFwiLCBcIm1ldGFcIik7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0cjtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi91dGlscy9nZXROb3RpZmljYXRpb25Gcm9tUGx1Z0luLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///49\n")},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, white: true, nomen: true, regexp: true, unparam: true, vars: true */\n/*global module, require */\n\nmodule.exports = function() {\n\n  var $ = __webpack_require__(1);\n\n  var retr = $("script[src*=\'MasterTMS\']");\n\n  if (retr.length === 0) {\n    retr = $("script[src*=\'ctm-\']");\n  }\n  if (retr.length === 0) {\n    retr = "";\n  }\n  if (retr !== "") {\n    retr = retr.attr("src");\n  }\n  return retr;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbHMvZ2V0T3VyU3JjLmpzPzZjNmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTs7QUFFQSxVQUFVLG1CQUFPLENBQUMsQ0FBTzs7QUFFekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qanNsaW50IGJyb3dzZXI6IHRydWUsIHNsb3BweTogdHJ1ZSwgd2hpdGU6IHRydWUsIG5vbWVuOiB0cnVlLCByZWdleHA6IHRydWUsIHVucGFyYW06IHRydWUsIHZhcnM6IHRydWUgKi9cbi8qZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXG4gIHZhciAkID0gcmVxdWlyZShcInplcHRvXCIpO1xuXG4gIHZhciByZXRyID0gJChcInNjcmlwdFtzcmMqPSdNYXN0ZXJUTVMnXVwiKTtcblxuICBpZiAocmV0ci5sZW5ndGggPT09IDApIHtcbiAgICByZXRyID0gJChcInNjcmlwdFtzcmMqPSdjdG0tJ11cIik7XG4gIH1cbiAgaWYgKHJldHIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0ciA9IFwiXCI7XG4gIH1cbiAgaWYgKHJldHIgIT09IFwiXCIpIHtcbiAgICByZXRyID0gcmV0ci5hdHRyKFwic3JjXCIpO1xuICB9XG4gIHJldHVybiByZXRyO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3V0aWxzL2dldE91clNyYy5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///50\n')},function(module,exports,__webpack_require__){eval('/*jslint browser: true, sloppy: true, nomen:true, white: true, vars:true, plusplus:true  */\n/*global module, require */\n\nmodule.exports = function(infix) {\n\tvar _ = __webpack_require__(0);\n\tvar outputQueue = "";\n\tvar operatorStack = [];\n\tvar i;\n\tvar token;\n\tvar operators = {\n\t\t"&&": {\n\t\t\tprecedence: 1\n\t\t},\n\t\t"||": {\n\t\t\tprecedence: 0\n\t\t}\n\t};\n\tvar o1;\n\tvar o2;\n\tvar operatorsString = _.keys(operators).join("");\n\tvar valid = 0;\n\n\tinfix = infix.replace(/\\s+/g, "");\n\tinfix = infix.split(/([\\&\\|]{2}|[\\(\\)])/);\n\tinfix = _.without(infix, "");\n\n\t// If there ever is a \')\' before a \'(\' the infix will be invalid and will break \n\t// the parenthesis part of the parsing code so lets kick it out now.\n\tfor (i = 0; i < infix.length; i++) {\n\t\tif (infix[i] === \'(\') {\n\t\t\tvalid++;\n\t\t} else if (infix[i] === \')\') {\n\t\t\tvalid--;\n\t\t\tif (valid < 0) {\n\t\t\t\tthrow new Error(\'Mismatched parenthesis, closing paren found before opening\');\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < infix.length; i++) {\n\t\ttoken = infix[i];\n\n\t\t// if the token is an operand\n\t\tif (token === "true" || token === "false") {\n\t\t\toutputQueue += token + " ";\n\n\t\t\t// or if the token is "&&" or "||"\n\t\t} else if (operatorsString.indexOf(token) !== -1) {\n\t\t\to1 = token;\n\t\t\to2 = operatorStack[operatorStack.length - 1];\n\t\t\twhile (operatorsString.indexOf(o2) !== -1 && ((operators[o1].precedence <= operators[o2].precedence) || (operators[o1].precedence < operators[o2].precedence))) {\n\t\t\t\toutputQueue += operatorStack.pop() + " ";\n\t\t\t\to2 = operatorStack[operatorStack.length - 1];\n\t\t\t}\n\t\t\toperatorStack.push(o1);\n\t\t} else if (token === "(") {\n\t\t\toperatorStack.push(token);\n\t\t} else if (token === ")") {\n\t\t\twhile (operatorStack[operatorStack.length - 1] !== "(") {\n\t\t\t\toutputQueue += operatorStack.pop() + " ";\n\t\t\t}\n\t\t\toperatorStack.pop();\n\t\t}\n\t}\n\twhile (operatorStack.length > 0) {\n\t\toutputQueue += operatorStack.pop() + " ";\n\t}\n\n\treturn _.without(outputQueue.split(" "), "");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9saWIvdXRpbHMvaW5maXhUb1Bvc3RmaXguanM/N2Q5ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLENBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtCQUFrQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzbGludCBicm93c2VyOiB0cnVlLCBzbG9wcHk6IHRydWUsIG5vbWVuOnRydWUsIHdoaXRlOiB0cnVlLCB2YXJzOnRydWUsIHBsdXNwbHVzOnRydWUgICovXG4vKmdsb2JhbCBtb2R1bGUsIHJlcXVpcmUgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmZpeCkge1xuXHR2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xuXHR2YXIgb3V0cHV0UXVldWUgPSBcIlwiO1xuXHR2YXIgb3BlcmF0b3JTdGFjayA9IFtdO1xuXHR2YXIgaTtcblx0dmFyIHRva2VuO1xuXHR2YXIgb3BlcmF0b3JzID0ge1xuXHRcdFwiJiZcIjoge1xuXHRcdFx0cHJlY2VkZW5jZTogMVxuXHRcdH0sXG5cdFx0XCJ8fFwiOiB7XG5cdFx0XHRwcmVjZWRlbmNlOiAwXG5cdFx0fVxuXHR9O1xuXHR2YXIgbzE7XG5cdHZhciBvMjtcblx0dmFyIG9wZXJhdG9yc1N0cmluZyA9IF8ua2V5cyhvcGVyYXRvcnMpLmpvaW4oXCJcIik7XG5cdHZhciB2YWxpZCA9IDA7XG5cblx0aW5maXggPSBpbmZpeC5yZXBsYWNlKC9cXHMrL2csIFwiXCIpO1xuXHRpbmZpeCA9IGluZml4LnNwbGl0KC8oW1xcJlxcfF17Mn18W1xcKFxcKV0pLyk7XG5cdGluZml4ID0gXy53aXRob3V0KGluZml4LCBcIlwiKTtcblxuXHQvLyBJZiB0aGVyZSBldmVyIGlzIGEgJyknIGJlZm9yZSBhICcoJyB0aGUgaW5maXggd2lsbCBiZSBpbnZhbGlkIGFuZCB3aWxsIGJyZWFrIFxuXHQvLyB0aGUgcGFyZW50aGVzaXMgcGFydCBvZiB0aGUgcGFyc2luZyBjb2RlIHNvIGxldHMga2ljayBpdCBvdXQgbm93LlxuXHRmb3IgKGkgPSAwOyBpIDwgaW5maXgubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoaW5maXhbaV0gPT09ICcoJykge1xuXHRcdFx0dmFsaWQrKztcblx0XHR9IGVsc2UgaWYgKGluZml4W2ldID09PSAnKScpIHtcblx0XHRcdHZhbGlkLS07XG5cdFx0XHRpZiAodmFsaWQgPCAwKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignTWlzbWF0Y2hlZCBwYXJlbnRoZXNpcywgY2xvc2luZyBwYXJlbiBmb3VuZCBiZWZvcmUgb3BlbmluZycpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZvciAoaSA9IDA7IGkgPCBpbmZpeC5sZW5ndGg7IGkrKykge1xuXHRcdHRva2VuID0gaW5maXhbaV07XG5cblx0XHQvLyBpZiB0aGUgdG9rZW4gaXMgYW4gb3BlcmFuZFxuXHRcdGlmICh0b2tlbiA9PT0gXCJ0cnVlXCIgfHwgdG9rZW4gPT09IFwiZmFsc2VcIikge1xuXHRcdFx0b3V0cHV0UXVldWUgKz0gdG9rZW4gKyBcIiBcIjtcblxuXHRcdFx0Ly8gb3IgaWYgdGhlIHRva2VuIGlzIFwiJiZcIiBvciBcInx8XCJcblx0XHR9IGVsc2UgaWYgKG9wZXJhdG9yc1N0cmluZy5pbmRleE9mKHRva2VuKSAhPT0gLTEpIHtcblx0XHRcdG8xID0gdG9rZW47XG5cdFx0XHRvMiA9IG9wZXJhdG9yU3RhY2tbb3BlcmF0b3JTdGFjay5sZW5ndGggLSAxXTtcblx0XHRcdHdoaWxlIChvcGVyYXRvcnNTdHJpbmcuaW5kZXhPZihvMikgIT09IC0xICYmICgob3BlcmF0b3JzW28xXS5wcmVjZWRlbmNlIDw9IG9wZXJhdG9yc1tvMl0ucHJlY2VkZW5jZSkgfHwgKG9wZXJhdG9yc1tvMV0ucHJlY2VkZW5jZSA8IG9wZXJhdG9yc1tvMl0ucHJlY2VkZW5jZSkpKSB7XG5cdFx0XHRcdG91dHB1dFF1ZXVlICs9IG9wZXJhdG9yU3RhY2sucG9wKCkgKyBcIiBcIjtcblx0XHRcdFx0bzIgPSBvcGVyYXRvclN0YWNrW29wZXJhdG9yU3RhY2subGVuZ3RoIC0gMV07XG5cdFx0XHR9XG5cdFx0XHRvcGVyYXRvclN0YWNrLnB1c2gobzEpO1xuXHRcdH0gZWxzZSBpZiAodG9rZW4gPT09IFwiKFwiKSB7XG5cdFx0XHRvcGVyYXRvclN0YWNrLnB1c2godG9rZW4pO1xuXHRcdH0gZWxzZSBpZiAodG9rZW4gPT09IFwiKVwiKSB7XG5cdFx0XHR3aGlsZSAob3BlcmF0b3JTdGFja1tvcGVyYXRvclN0YWNrLmxlbmd0aCAtIDFdICE9PSBcIihcIikge1xuXHRcdFx0XHRvdXRwdXRRdWV1ZSArPSBvcGVyYXRvclN0YWNrLnBvcCgpICsgXCIgXCI7XG5cdFx0XHR9XG5cdFx0XHRvcGVyYXRvclN0YWNrLnBvcCgpO1xuXHRcdH1cblx0fVxuXHR3aGlsZSAob3BlcmF0b3JTdGFjay5sZW5ndGggPiAwKSB7XG5cdFx0b3V0cHV0UXVldWUgKz0gb3BlcmF0b3JTdGFjay5wb3AoKSArIFwiIFwiO1xuXHR9XG5cblx0cmV0dXJuIF8ud2l0aG91dChvdXRwdXRRdWV1ZS5zcGxpdChcIiBcIiksIFwiXCIpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3V0aWxzL2luZml4VG9Qb3N0Zml4LmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///51\n')}]); 